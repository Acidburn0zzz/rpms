--- dhcp-3.0.5/client/scripts/linux.client	2002-11-14 20:09:09.000000000 -0500
+++ dhcp-3.0.5/client/scripts/linux	2006-11-29 10:52:47.000000000 -0500
@@ -19,16 +19,54 @@
 # address if it is not supplied. This might be much more easily done
 # by the dhclient C code, and passed on.
 
-# 4. TIMEOUT not tested. ping has a flag I don't know, and I'm suspicious
-# of the $1 in its args.
+if [ -n "${dhc_dbus}" ]; then
+   /bin/dbus-send \
+       --system \
+       --dest=com.redhat.dhcp \
+       --type=method_call \
+       /com/redhat/dhcp/$interface \
+       com.redhat.dhcp.set \
+       'string:'"`env | /bin/egrep -v '^(PATH|SHLVL|_|PWD|dhc_dbus)\='`";
+       if (( ( dhc_dbus & 31 ) == 31 )); then
+	   exit 0;
+       fi;
+fi;
+
+function save_previous() {
+  if [ -e $1 ]; then
+    /bin/mv $1 $1.predhclient
+  else
+    echo ''> $1.predhclient 
+  fi
+}
 
 make_resolv_conf() {
-  if [ "x$new_domain_name" != x ] && [ x"$new_domain_name_servers" != x ]; then
-    echo search $new_domain_name >/etc/resolv.conf
-    chmod 644 /etc/resolv.conf
+  if [ "${PEERDNS}" == "no" ]; then  
+      return 
+  fi
+
+  if [ x$reason == xRENEW ] &&
+     [ "$new_domain_name" == "$old_domain_name" ] && 
+     [ "$new_domain_name_servers" == "$old_domain_name_servers" ]; then
+      return;
+  fi
+
+  if [ -n "$new_domain_name" ] || [ -n "$new_domain_name_servers" ]; then
+    cp -fp /etc/resolv.conf /etc/resolv.conf.predhclient
+    rscf=`mktemp /tmp/XXXXXX`;
+    echo '; generated by /sbin/dhclient-script' > $rscf
+    if [ -n "$SEARCH" ]; then
+ 	echo search $SEARCH >> $rscf
+    else
+	if [ -n "$new_domain_name" ]; then
+ 	    echo search $new_domain_name >> $rscf
+        fi
+    fi
     for nameserver in $new_domain_name_servers; do
-      echo nameserver $nameserver >>/etc/resolv.conf
+      echo nameserver $nameserver >> $rscf
     done
+    change_resolv_conf $rscf
+    rm -f $rscf
   fi
 }
 
@@ -53,12 +91,344 @@
   fi
 fi
 
+# Import Red Hat Linux configuration
+cd /etc/sysconfig/network-scripts;
+. /etc/sysconfig/network-scripts/network-functions
+. /etc/rc.d/init.d/functions
+
+[ -f ../network ] && . ../network
+[ -f ../networking/network ] && . ../networking/network
+
+CONFIG=$interface
+
+need_config ${CONFIG}
+
+if [ -f "${CONFIG}" ]; then 
+    source_config
+else
+    echo $"$0: configuration for $interface not found. Continuing with defaults." >&2
+fi
+
+source_config
+
 release=`uname -r`
-release=`expr $release : '\(.*\)\..*'`
-relminor=`echo $release |sed -e 's/[0-9]*\.\([0-9][0-9]*\)\(\..*\)*$/\1/'`
-relmajor=`echo $release |sed -e 's/\([0-9][0-9]*\)\..*$/\1/'`
+relmajor=`echo $release |/bin/cut -f1 -d'.'`
+relminor=`echo $release |/bin/cut -f2 -d'.'`
+
+# simple IP arithmetic functions:
+
+function quad2num()
+{
+    if [ $# -eq 4 ]; then
+       let n="$1<<24|$2<<16|$3<<8|$4"
+       echo $n;
+       return 0;
+    fi
+    echo '0';
+    return 1;
+}
+
+function ip2num()
+{
+    IFS='.' quad2num $1;
+}
+
+function num2ip()
+{
+    let n="$1";
+    let o1='(n>>24)&0xff';
+    let o2='(n>>16)&0xff';
+    let o3='(n>>8)&0xff';
+    let o4='n & 0xff';
+    echo $o1.$o2.$o3.$o4;
+}
+
+function mask()
+{   
+    ip=$1
+    m=$2
+    let ip=`IFS='.' ip2num $ip`;
+    let m=`IFS='.' ip2num $m`;
+    let n='ip&m';
+    num2ip $n;
+}
+
+function mask_bits()
+{
+    ip=$1
+    let ip=`IFS='.' ip2num $ip`;
+    let bits=0
+    for ((bit=1; '((ip&bit)==0) && (bits < 32)'; 'bit<<=1')) do
+        let bits+=1
+    done
+    let n_bits=32-bits
+    echo $n_bits
+}
+
+function class_bits()
+{
+    let ip=`IFS='.' ip2num $1`;
+    let bits=32
+    let mask='255';
+    for ((i=0; i <= 3; i++, 'mask<<=8')); do
+	let v='ip&mask';
+	if [ "$v" -eq 0 ] ; then
+	    let bits-=8;
+        else
+            break;
+	fi;
+    done;
+    echo $bits;
+}
+
+function routerReachable()
+{ # Handle silly DHCP servers that give us a router not on our subnet:    
+    router=$1
+    routerSubnet=`mask $router $new_subnet_mask`
+    mySubnet=`mask $new_ip_address $new_subnet_mask`
+    unreachable=0
+    if [ "$routerSubnet" != "$mySubnet" ]; then
+	unreachable=1
+	if /sbin/arping -f -q -I $interface -w2 $router; then
+	    /sbin/ip route add ${router}/32 dev $interface
+	    if [ $? -eq 0 ]; then
+		unreachable=0
+	    else
+		/usr/bin/logger -p local7.notice -t "NET"  "dhclient: failed to create host route for unreachable router $router not on subnet $mySubnet";
+	    fi
+	else
+	    unreachable=1
+	    if [ -x /usr/bin/logger ]; then
+		/usr/bin/logger -p local7.notice -t "NET"  "dhclient: DHCP router $router is unreachable on DHCP subnet $mySubnet router subnet $routerSubnet";
+	    fi;
+	fi;
+    fi;
+    return $unreachable;
+}
+
+function add_default_gateway()
+{
+    router=$1
+    metric=''
+    if [ $# -gt 1 ] && [ "$2" -gt 0 ]; then 
+	metric="metric $2";
+    fi;    
+    if routerReachable $router ; then
+	/sbin/ip route replace default via $router dev $interface $metric;
+	if [ $? -ne 0 ]; then 
+	    /usr/bin/logger -p local7.notice -t "NET"  'dhclient: failed to create default route: '$router dev $interface $metric;
+	    return 1;
+	else
+	    return 0;
+	fi;
+    fi;
+    return 1;
+}
+
+function dhconfig()
+{
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 2 ) != 2 )); then
+	if [ x$old_ip_address != x ] && [ x$alias_ip_address != x ] && \
+		[ x$alias_ip_address != x$old_ip_address ]; then
+         # Possible new alias. Remove old alias.
+	    ifconfig $interface:0- inet 0
+	fi
+
+	if [ x$old_ip_address != x ] && [ x$old_ip_address != x$new_ip_address ]; then
+        # IP address changed. Bringing down the interface will delete all routes,
+        # and clear the ARP cache.
+	    ifconfig $interface inet 0 down
+	fi
+    fi
+    if [ x$reason = xBOUND ] || [ x$reason = xREBOOT ] ||
+       [ x$old_ip_address  != x$new_ip_address ] ||
+       [ x$old_subnet_mask != x$new_subnet_mask ] ||
+       [ x$new_network_number != x$new_network_number ] ||
+       [ x$old_broadcast_address != x$new_broadcast_address ] ||
+       [ "x$old_routers" != "x$new_routers" ] ||
+       [ x$old_interface_mtu != x$new_interface_mtu ] ; then
+	if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 2 ) != 2 )); then
+	    ifconfig $interface inet $new_ip_address $new_subnet_arg \
+		$new_broadcast_arg
+	    if [ -n "$new_interface_mtu" ]; then
+		/sbin/ip link set $interface mtu $new_interface_mtu;
+	    fi;
+	    if [ -x /etc/dhclient-${interface}-up-hooks ]; then
+		. /etc/dhclient-${interface}-up-hooks;
+	    elif [ -x /etc/dhclient-up-hooks ]; then
+		. /etc/dhclient-up-hooks;
+	    fi;
+	fi;
+	
+	if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 4 ) != 4 )); then
+	    prefix_bits=`mask_bits $new_subnet_mask`
+            # Add a network route to the computed network address.
+	    if [ $relmajor -lt 2 ] || \
+		( [ $relmajor -eq 2 ] && [ $relminor -eq 0 ] ); then
+		/sbin/ip route replace ${new_network_number}/${prefix_bits} dev $interface
+		if [ $added_old_broadcast_route -eq 1 ]; then
+		   /sbin/ip route del default;
+		fi;
+	    fi;
+	    if [[  ( ( -z "$GATEWAYDEV" )  || ( "$GATEWAYDEV" = "$interface" ) ) && ( ( -z "$GATEWAY" )  || ( ( -n "$DHCLIENT_IGNORE_GATEWAY" ) && ( "$DHCLIENT_IGNORE_GATEWAY" = [Yy]* ) ) ) ]]; then
+		metric=${METRIC:-''};
+		let i=${METRIC:-0};
+		default_routers=()
+		for router in $new_routers; do
+		    added_router=0
+		    for r in ${default_routers[@]}; do
+			if [ "$r" == "$router" ]; then
+			    added_router=1;
+                        fi;
+		    done
+		    if [ -z "$router" ] || [ "$added_router" -eq 1 ] || [ `IFS=. ip2num $router` -le 0 ] || [[ ( "$router" = "$new_broadcast_address" ) && ( "$new_subnet_mask" != "255.255.255.255" ) ]]; then
+			continue;
+		    fi;
+		    default_routers=(${default_routers[@]} $router)
+		    add_default_gateway $router $metric;		    
+		    let i=i+1;
+		    metric=$i; 
+		done
+	    elif [[ ( ( -z "$GATEWAYDEV" ) || ( "$GATEWAYDEV" = "$interface" ) ) && ( -n "$GATEWAY" ) ]]; then
+		routerSubnet=`mask $GATEWAY $new_subnet_mask`
+		mySubnet=`mask $new_ip_address $new_subnet_mask`
+		if [ "$routerSubnet" = "$mySubnet" ]; then
+		    /sbin/ip route replace default via $GATEWAY dev $interface 
+		fi;
+	    fi;
+            # static routes
+	    if [ "x$new_static_routes" != x ]; then
+		IFS=', 	' static_routes=($new_static_routes)
+		route_targets=()
+		for((i=0; i<${#static_routes[@]}; i+=2)); do
+		    target=${static_routes[$i]}
+		    gateway=${static_routes[$i+1]}
+		    metric=''
+		    for t in ${route_targets[@]}; do
+			if [ $t == $target ]; then
+			    if [ -z "$metric" ]; then
+				metric=1;
+			    else
+				((metric=metric+1));
+			    fi;
+			fi;
+		    done;
+		    if [ -n "$metric" ]; then
+			metric="metric $metric";
+		    fi;		    
+		    if routerReachable $gateway; then
+			/sbin/ip route replace ${target}/`class_bits $target` via ${gateway} dev $interface ${metric}
+			if [ $? -ne 0 ]; then
+			   /usr/bin/logger -p local7.notice -t 'NET' 'dhclient: failed to create static route:' ${target}/`class_bits $target` via ${gateway} dev $interface ${metric};			
+			else			    
+ 			   route_targets=(${route_targets[@]} $target);
+			fi;
+		    fi;
+		done
+	    fi
+	fi
+    fi
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 2 ) != 2 )); then
+	if [ x$new_ip_address != x$alias_ip_address ] && [ x$alias_ip_address != x ];
+	    then
+	    ifconfig $interface:0- inet 0
+	    ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
+	    /sbin/ip route replace ${alias_ip_address}/32 dev $interface:0
+	fi
+    fi
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 1 ) != 1 )); then
+	make_resolv_conf
 
-if [ x$new_broadcast_address != x ]; then
+	if [ -n "$new_host_name" ] && need_hostname; then
+	    hostname $new_host_name
+	fi
+    fi;
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 8 ) != 8 )); then
+	if [ "${PEERNIS}" = no ]; then
+	    :
+	elif [ -n "$new_nis_domain" ]; then
+	    domainname "$new_nis_domain"
+	    save_previous /etc/yp.conf
+	    let contents=0
+	    echo '# generated by /sbin/dhclient-script' > /etc/yp.conf
+	    if [ -n "$new_nis_servers" ]; then
+		for I in $new_nis_servers; do
+		    echo "domain $new_nis_domain server $I" >> /etc/yp.conf
+		    let contents=contents+1
+		done
+	    else
+		echo "domain $new_nis_domain broadcast" >> /etc/yp.conf
+		let contents=contents+1
+	    fi
+	    level=`/sbin/runlevel`
+	    level=${level##*\ }
+	    if [ "$level" = "unknown" ]; then
+		level=1;
+	    fi
+	    if [ $contents -gt 0 ] && [[ "$level" = [0-6] ]] && /sbin/chkconfig --level=$level ypbind >/dev/null 2>&1 && [ -r /var/run/ypbind.pid ] && yppid=`cat /var/run/ypbind.pid` && [ -d /proc/${yppid} ] && [ "`if [ -x /sbin/busybox ]; then /sbin/busybox readlink /proc/${yppid}/exe; else echo /sbin/ypbind; fi`" = "/sbin/ypbind" ]; then
+	       kill -HUP $yppid;
+	    fi
+	elif [ -n "$new_nis_servers" ]; then
+	    save_previous /etc/yp.conf
+	    echo '# generated by /sbin/dhclient-script' > /etc/yp.conf
+	    let contents=0
+	    for I in $new_nis_servers; do
+		echo "ypserver $I" >> /etc/yp.conf
+		let contents=contents+1
+	    done
+	    level=`/sbin/runlevel`
+	    level=${level##*\ }
+	    if [ "$level" = "unknown" ]; then
+		level=1;
+	    fi
+	    if [ $contents -gt 0 ] && [[ "$level" = [0-6] ]] && /sbin/chkconfig --level=$level ypbind >/dev/null 2>&1 && [ -r /var/run/ypbind.pid ] && yppid=`cat /var/run/ypbind.pid` && [ -d /proc/${yppid} ] && [ "`if [ -x /sbin/busybox ]; then /sbin/busybox readlink /proc/${yppid}/exe; else echo /sbin/ypbind; fi`" = "/sbin/ypbind" ] ; then
+	       kill -HUP $yppid;
+	    fi
+	fi
+    fi
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 16 ) != 16 )); then
+	if [ -n "$DHCP_TIME_OFFSET_SETS_TIMEZONE" ] && [[ "$DHCP_TIME_OFFSET_SETS_TIMEZONE" = [yY1]* ]]; then
+	    if [ -n "$new_time_offset" ]; then
+	    #   DHCP option "time-offset" is requested by default and should be handled.
+	    #   The geographical zone abbreviation cannot be determined from the GMT offset,
+	    #   but the $ZONEINFO/Etc/GMT$offset file can be used - note: this disables DST.
+		((z=new_time_offset/3600));
+		((hoursWest=`printf '%+d' $z`))
+		if (( $hoursWest < 0 )); then
+		   # tzdata treats negative 'hours west' as positive 'gmtoff' !
+		   ((hoursWest*=-1));
+		fi
+		tzfile=/usr/share/zoneinfo/Etc/GMT`printf '%+d' $hoursWest`;
+		if [ -e $tzfile ]; then
+		    /bin/mv -f /etc/localtime /etc/localtime.predhclient;
+		    /bin/cp -fp $tzfile /etc/localtime;
+		    /bin/touch /etc/localtime;
+		fi;
+	    fi;
+	fi;
+	if [ "${PEERNTP}" = no ]; then
+	    :
+	elif [ -n "$new_ntp_servers" ] && [ -e /etc/ntp.conf ]; then
+	    save_previous /etc/ntp.conf
+	    /bin/egrep -v '(^[\ \	]*(server|fudge))|(generated by /sbin/dhclient-script)'< /etc/ntp.conf.predhclient > /etc/ntp.conf
+	    echo '# servers generated by /sbin/dhclient-script' >> /etc/ntp.conf
+	    localClocks=(`/bin/egrep '^[\ \	]*server[\ \	]+127\.127' /etc/ntp.conf.predhclient | while read s addr rest; do echo $addr; done`)      
+	    localClockFudge="`/bin/egrep '^[\ \	]*fudge[\ \	]+127\.127' /etc/ntp.conf.predhclient`";
+	    for s in $new_ntp_servers ${localClocks[@]};
+	      do
+	      echo 'server '$s >> /etc/ntp.conf;
+	    done
+	    echo "$localClockFudge" >> /etc/ntp.conf;
+	    if [ -x /usr/bin/diff ] && /usr/bin/diff -q /etc/ntp.conf /etc/ntp.conf.predhclient >/dev/null 2>&1; then
+		: ;
+	    else
+		/sbin/service ntpd condrestart >/dev/null 2>&1
+	    fi;
+	fi
+    fi;
+}
+
+if [ x$new_broadcast_address != x ] && [ x$new_subnet_mask != x ] && [ "$new_subnet_mask" != "255.255.255.255" ]; then
   new_broadcast_arg="broadcast $new_broadcast_address"
 fi
 if [ x$old_broadcast_address != x ]; then
@@ -79,79 +449,85 @@
   exit_with_hooks 0
 fi
 
+added_old_broadcast_route=0;
 if [ x$reason = xPREINIT ]; then
-  if [ x$alias_ip_address != x ]; then
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 2 ) != 2 )); then
+	if [ x$alias_ip_address != x ]; then
     # Bring down alias interface. Its routes will disappear too.
-    ifconfig $interface:0- inet 0
-  fi
-  if [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] && [ $relminor -eq 0 ] )
-   then
-    ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
+	    ifconfig $interface:0- inet 0
+	fi
+	if [ x$keep_old_ip = xyes ]; then
+	    ifconfig $interface up
+	elif [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] && [ $relminor -eq 0 ] )   then
+	    ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
 		broadcast 255.255.255.255 up
     # Add route to make broadcast work. Do not omit netmask.
-    route add default dev $interface netmask 0.0.0.0
-  else
-    ifconfig $interface 0 up
-  fi
+	    /sbin/ip route replace default dev $interface && added_old_broadcast_route=1;
+	else
+	    ifconfig $interface 0 up
+	fi     
 
   # We need to give the kernel some time to get the interface up.
-  sleep 1
-
-  exit_with_hooks 0
+  #	sleep 1
+  # I don't think this is necessary with modern kernels - no problems found during testing -
+  # JVD, 2005-06-17
+	# but just in case:
+	if [ -n "$DHCLIENT_DELAY" ] && [ "$DHCLIENT_DELAY" -gt 0 ] ; then
+	    sleep $DHCLIENT_DELAY;
+	fi;
+	exit_with_hooks 0
+    fi;
 fi
 
 if [ x$reason = xARPCHECK ] || [ x$reason = xARPSEND ]; then
-  exit_with_hooks 0
+    if [ -z "$new_ip_address" ] || [ -z "$interface" ] ||  /sbin/arping -q -f -c 2 -w 3 -D -I ${interface} ${new_ip_address}; then
+	exit_with_hooks 0
+    else
+	exit_with_hooks 1
+    fi;
 fi
   
 if [ x$reason = xBOUND ] || [ x$reason = xRENEW ] || \
-   [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then
-  current_hostname=`hostname`
-  if [ x$current_hostname = x ] || \
-     [ x$current_hostname = x$old_host_name ]; then
-    if [ x$current_hostname = x ] || \
-       [ x$new_host_name != x$old_host_name ]; then
-      hostname $new_host_name
-    fi
-  fi
-    
-  if [ x$old_ip_address != x ] && [ x$alias_ip_address != x ] && \
-		[ x$alias_ip_address != x$old_ip_address ]; then
-    # Possible new alias. Remove old alias.
-    ifconfig $interface:0- inet 0
-  fi
-  if [ x$old_ip_address != x ] && [ x$old_ip_address != x$new_ip_address ]; then
-    # IP address changed. Bringing down the interface will delete all routes,
-    # and clear the ARP cache.
-    ifconfig $interface inet 0 down
-
-  fi
-  if [ x$old_ip_address = x ] || [ x$old_ip_address != x$new_ip_address ] || \
-     [ x$reason = xBOUND ] || [ x$reason = xREBOOT ]; then
-
-    ifconfig $interface inet $new_ip_address $new_subnet_arg \
-							$new_broadcast_arg
-    # Add a network route to the computed network address.
-    if [ $relmajor -lt 2 ] || \
-		( [ $relmajor -eq 2 ] && [ $relminor -eq 0 ] ); then
-      route add -net $new_network_number $new_subnet_arg dev $interface
-    fi
-    for router in $new_routers; do
-      route add default gw $router
-    done
-  fi
-  if [ x$new_ip_address != x$alias_ip_address ] && [ x$alias_ip_address != x ];
-   then
-    ifconfig $interface:0- inet 0
-    ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
-    route add -host $alias_ip_address $interface:0
-  fi
-  make_resolv_conf
-  exit_with_hooks 0
+   [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then    
+    dhconfig ;
+    exit_with_hooks 0
 fi
 
 if [ x$reason = xEXPIRE ] || [ x$reason = xFAIL ] || [ x$reason = xRELEASE ] \
    || [ x$reason = xSTOP ]; then
+  if [ -f /etc/resolv.conf.predhclient ]; then
+     change_resolv_conf /etc/resolv.conf.predhclient
+     rm -f /etc/resolv.conf.predhclient
+  fi
+  if [ -n "$DHCP_TIME_OFFSET_SETS_TIMEZONE" ] && [[ "$DHCP_TIME_OFFSET_SETS_TIMEZONE" = [yY1]* ]]; then
+      if [ -e /etc/localtime.predhclient ]; then
+	  /bin/rm -f /etc/localtime
+	  /bin/mv -f /etc/localtime.predhclient /etc/localtime;
+	  /bin/touch /etc/localtime;
+      fi;
+  fi;
+  if [ -f /etc/ntp.conf.predhclient ]; then
+     /bin/rm -f /etc/ntp.conf
+     /bin/mv -f /etc/ntp.conf.predhclient /etc/ntp.conf
+     service ntpd condrestart >/dev/null 2>&1 
+  fi
+  if [ -f /etc/yp.conf.predhclient ]; then
+     /bin/rm -f /etc/yp.conf
+     /bin/mv -f /etc/yp.conf.predhclient /etc/yp.conf
+     level=`/sbin/runlevel`
+     level=${level##*\ }
+     if [ "$level" = "unknown" ]; then
+	 level=1;
+     fi
+     if [[ "$level" = [0-6] ]] && /sbin/chkconfig --level=$level ypbind >/dev/null 2>&1 && [ -r /var/run/ypbind.pid ] && yppid=`cat /var/run/ypbind.pid` && [ -d /proc/${yppid} ] && [ "`if [ -x /sbin/busybox ]; then /sbin/busybox readlink /proc/${yppid}/exe; else echo /sbin/ypbind; fi`" = "/sbin/ypbind" ] ; then
+	 kill -HUP $yppid;
+     fi
+  fi 
+  if [ -x /etc/dhclient-${interface}-down-hooks ]; then
+      . /etc/dhclient-${interface}-down-hooks;
+  elif [ -x /etc/dhclient-down-hooks ]; then
+      . /etc/dhclient-down-hooks;
+  fi;
   if [ x$alias_ip_address != x ]; then
     # Turn off alias interface.
     ifconfig $interface:0- inet 0
@@ -162,37 +538,29 @@
   fi
   if [ x$alias_ip_address != x ]; then
     ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
-    route add -host $alias_ip_address $interface:0
+    /sbin/ip route replace ${alias_ip_address}/32 $interface:0
   fi
   exit_with_hooks 0
 fi
 
-if [ x$reason = xTIMEOUT ]; then
-  if [ x$alias_ip_address != x ]; then
-    ifconfig $interface:0- inet 0
-  fi
-  ifconfig $interface inet $new_ip_address $new_subnet_arg \
+if [ x$reason = xTIMEOUT ] && [ "x$new_routers" != 'x' ]; then
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 2 ) != 2 )); then
+	if [ x$alias_ip_address != x ]; then
+	    ifconfig $interface:0- inet 0
+	fi
+	ifconfig $interface inet $new_ip_address $new_subnet_arg \
 					$new_broadcast_arg
-  set $new_routers
-  ############## what is -w in ping?
-  if ping -q -c 1 $1; then
-    if [ x$new_ip_address != x$alias_ip_address ] && \
-			[ x$alias_ip_address != x ]; then
-      ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
-      route add -host $alias_ip_address dev $interface:0
-    fi
-    if [ $relmajor -lt 2 ] || \
-		( [ $relmajor -eq 2 ] && [ $relminor -eq 0 ] ); then
-      route add -net $new_network_number
+    fi;
+    set $new_routers
+    if ping -q -c 1 -w 10 -I $interface $1; then
+	dhconfig ;
+	exit_with_hooks 0
     fi
-    for router in $new_routers; do
-      route add default gw $router
-    done
-    make_resolv_conf
-    exit_with_hooks 0
-  fi
-  ifconfig $interface inet 0 down
+    if [ -z "${dhc_dbus}" ] || (( ( dhc_dbus & 2 ) != 2 )); then
+	ifconfig $interface inet 0 down
+    fi;
+    exit_with_hooks 1
+elif [ x$reason = xTIMEOUT ]; then
   exit_with_hooks 1
 fi
-
 exit_with_hooks 0
--- dhcp-3.0.5/client/clparse.c.client	2006-02-22 17:43:27.000000000 -0500
+++ dhcp-3.0.5/client/clparse.c	2006-11-29 10:52:26.000000000 -0500
@@ -51,6 +51,9 @@
 	DHO_DOMAIN_NAME,
 	DHO_DOMAIN_NAME_SERVERS,
 	DHO_HOST_NAME,
+	DHO_NIS_DOMAIN,
+	DHO_NIS_SERVERS,
+	DHO_NTP_SERVERS,
 	0
 };
 
@@ -84,6 +87,7 @@
 	top_level_config.requested_options = default_requested_options;
 	top_level_config.omapi_port = -1;
 	top_level_config.do_forward_update = 1;
+	top_level_config.bootp_broadcast_always = 0;
 
 	group_allocate (&top_level_config.on_receipt, MDL);
 	if (!top_level_config.on_receipt)
@@ -230,7 +234,9 @@
 	interface-declaration |
 	LEASE client-lease-statement |
 	ALIAS client-lease-statement |
-	KEY key-definition */
+	KEY key-definition 
+	BOOTP_BROADCAST_ALWAYS
+*/
 
 void parse_client_statement (cfile, ip, config)
 	struct parse *cfile;
@@ -554,6 +560,12 @@
 		parse_reject_statement (cfile, config);
 		return;
 
+	      case BOOTP_BROADCAST_ALWAYS:
+		token = next_token(&val, (unsigned*)0, cfile);
+		config -> bootp_broadcast_always = 1;
+		parse_semi (cfile);
+		return;
+		
 	      default:
 		lose = 0;
 		stmt = (struct executable_statement *)0;
--- dhcp-3.0.5/client/dhclient-script.8.client	2005-09-28 15:17:08.000000000 -0400
+++ dhcp-3.0.5/client/dhclient-script.8	2006-11-29 10:52:26.000000000 -0500
@@ -47,7 +47,7 @@
 exit hooks provided (see HOOKS for details).   These hooks will allow the
 user to override the default behaviour of the client in creating a
 .B /etc/resolv.conf
-file.
+file, and to handle DHCP options not handled by default. 
 .PP
 No standard client script exists for some operating systems, even though
 the actual client may work, so a pioneering user may well need to create
@@ -91,6 +91,27 @@
 .B ETCDIR/dhclient-exit-hooks
 script can modify the valid of exit_status to change the exit status
 of dhclient-script.
+.PP
+Immediately after dhclient brings an interface UP with a new IP address,
+subnet mask, and routes, in the REBOOT/BOUND states, it will check for the
+existence of an executable
+.B ETCDIR/dhclient-up-hooks
+script, and source it if found. This script can handle DHCP options in
+the environment that are not handled by default. A per-interface 
+.B ETCDIR/dhclient-up-${IF}-hooks
+script will override the generic script and be sourced when interface
+$IF has been brought up.
+.PP
+Immediately before dhclient brings an interface DOWN, removing its IP 
+address, subnet mask, and routes, in the STOP/RELEASE  states, it will 
+check for the existence of an executable
+.B ETCDIR/dhclient-down-hooks
+script, and source it if found. This script can handle DHCP options in
+the environment that are not handled by default. A per-interface 
+.B ETCDIR/dhclient-down-${IF}-hooks
+script will override the generic script and be sourced when interface
+$IF is about to be brought down.
+
 .SH OPERATION
 When dhclient needs to invoke the client configuration script, it
 defines a set of variables in the environment, and then invokes
--- dhcp-3.0.5/client/dhclient.conf.5.client	2005-06-16 15:40:13.000000000 -0400
+++ dhcp-3.0.5/client/dhclient.conf.5	2006-11-29 10:52:26.000000000 -0500
@@ -185,7 +185,8 @@
 options.   Only the option names should be specified in the request
 statement - not option parameters.   By default, the DHCP server
 requests the subnet-mask, broadcast-address, time-offset, routers,
-domain-name, domain-name-servers and host-name options. 
+domain-name, domain-name-servers, host-name, nis-domain, nis-servers,
+and ntp-servers options.
 .PP
 In some cases, it may be desirable to send no parameter request list
 at all.   To do this, simply write the request statement but specify
@@ -581,6 +582,18 @@
 Whenever the client tries to renew the lease, it will use that same
 media type.   The lease must expire before the client will go back to
 cycling through media types.
+.PP
+ \fBbootp-broadcast-always;\fR
+.PP
+The 
+.B bootp-broadcast-always
+statement instructs dhclient to always set the bootp broadcast flag in
+request packets, so that servers will always broadcast replies.
+This is equivalent to supplying the dhclient -B argument, and has
+the same effect as specifying 'always-broadcast' in the server's dhcpd.conf.
+This option is provided as a Red Hat extension to enable dhclient to work
+on IBM zSeries z/OS Linux guests .
+.PP
 .SH SAMPLE
 The following configuration file is used on a laptop running NetBSD
 1.3.   The laptop has an IP alias of 192.5.5.213, and has one
--- dhcp-3.0.5/client/dhclient.8.client	2006-11-29 10:52:26.000000000 -0500
+++ dhcp-3.0.5/client/dhclient.8	2006-11-29 10:52:26.000000000 -0500
@@ -85,6 +85,28 @@
 .B -x
 ]
 [
+.B -I
+.I dhcp-client-identifier
+]
+[
+.B -H
+.I host-name
+.R |
+.B -F fqdn.fqdn
+]
+[
+.B -V
+.I vendor-class-identifier
+]
+[
+.B -R
+.I request option list
+]
+[
+.B -T 
+.I timeout
+]
+[
 .I if0
 [
 .I ...ifN
@@ -273,6 +295,107 @@
 -s dhclient-script environment, which would allow applications running
 in that environment to handle options they do not know about in advance -
 this is a Red Hat extension to support dhcdbd and NetworkManager.
+.PP
+The -I <id> argument allows you to specify the dhcp-client-identifier string, <id>,
+to be sent to the dhcp server on the command line. It is equivalent to the
+top level dhclient.conf statement:
+.br
+ \fBsend dhcp-client-identifier "<id>";\fR
+.br
+The -I <id> command line option will override any top level dhclient.conf 
+ 'send dhcp-client-identifier' statement, but more specific per-interface
+ 'interface "X" { send dhcp-client-identifier...; }' statements in dhclient.conf
+will override the -I <id> command line option for interface "X".
+This option is provided as a Red Hat extension to enable dhclient to work
+on IBM zSeries z/OS Linux guests .
+.PP
+The -B option instructs dhclient to set the bootp broadcast flag in request
+packets, so that servers will always broadcast replies . This is equivalent
+to specifying the 'bootp-broadcast-always' option in dhclient.conf, and has
+the same effect as specifying 'always-broadcast' in the server's dhcpd.conf.
+This option is provided as a Red Hat extension to enable dhclient to work
+on IBM zSeries z/OS Linux guests .
+.PP 
+The -H <host-name> option allows you to specify the DHCP host-name option
+to send to the server on the dhclient command line. It is equivalent to the
+top level dhclient.conf statement:
+.br
+\f send host-name "<host-name>";\fR
+.br
+The -H <host-name> option  will override any top level dhclient.conf 
+ 'send host-name' statement, but more specific per-interface 
+ 'interface "X" { send host-name...;' statements in dhclient.conf
+will override the -H <host-name> command line option for interface "X".
+The host-name option only specifies the client's host name prefix, to which
+the server will append the 'ddns-domainname' or 'domain-name' options, if any,
+to derive the fully qualified domain name of the client host.
+The -H <host-name> option cannot be used with the -F <fqdn.fqdn> option.
+Only one -H <host-name> option may be specified.
+The -H <host-name> option is provided as a Red Hat extension to simplify
+configuration of clients of DHCP servers that require the host-name option
+to be sent (eg. some modern cable modems), and for dynamic DNS updates (DDNS). 
+.PP
+The -F <fqdn.fqdn> option allows you to specify the DHCP fqdn.fqdn option
+to send to the server on the dhclient command line. It is equivalent to the
+top level dhclient.conf statement:
+.br
+\f send fqdn.fqdn "<domain-name>";\fR
+.br
+The -F <fqdn.fqdn> option  will override any top level dhclient.conf 
+ 'send fqdn.fqdn' statement, but more specific per-interface 
+ 'interface "X" { send fqdn.fqdn...;' statements in dhclient.conf
+will override the -F <fqdn.fqdn> command line option for interface "X".
+This option cannot be used with the -H <host-name> option.
+The DHCP fqdn.fqdn option must specify the complete domain name of the client
+host, which the server may use for dynamic DNS updates.
+Only one -F <fqdn.fqdn> option may be specified.
+The -F <fqdn.fqdn> option is provided as a Red Hat extension to simplify
+configuration of DDNS. 
+.PP
+The -T <timeout> option allows you to specify the time after which 
+the dhclient will decide that no DHCP servers can be contacted when
+no responses have been received. It is equivalent to the 
+.br
+\f timeout <integer>;\fR
+.br
+dhclient.conf statement, and will override any such statements in dhclient.conf.
+.br
+This option is provided as a Red Hat extension.
+.PP
+The -V <vendor-class-identifier> option allows you to specify the DHCP 
+vendor-class-identifier option to send to the server on the dhclient command line. 
+It is equivalent to the top level dhclient.conf statement:
+.br
+\f send vendor-class-identifier "<vendor-class-identifier>";\fR
+.br
+The -V <vendor-class-identifier> option  will override any top level dhclient.conf 
+ 'send vendor-class-identifier' statement, but more specific per-interface 
+ 'interface "X" { send vendor-class-identifier...;' statements in dhclient.conf
+will override the -V <vendor-class-identifier> command line option for interface "X".
+The -V <vendor-class-identifier> option is provided as a Red Hat extension to simplify
+configuration of clients of DHCP servers that require the vendor-class-identifier option
+to be sent.
+.PP
+The -R <request option list> option allows you to specify the list of options the
+client is to request from the server on the dhclient command line.
+The option list must be a single string, consisting of option names separated
+by at least one comma and optional space characters. The default option list
+is :
+.br
+    subnet-mask, broadcast-address, time-offset, routers, 
+.br
+    domain-name, domain-name-servers, host-name, nis-domain, 
+.br
+    nis-servers, ntp-servers
+.br
+You can specify a different list of options to request with the -R <option list> argument.
+This is equivalent to the dhclient.conf statement:
+.br
+\f    request <option list> ;\fR
+.br
+The -R argument is provided as a Red Hat extension to ISC dhclient to facilitate requesting
+a list of options from the server different to the default.
+.PP
 .SH CONFIGURATION
 The syntax of the dhclient.conf(5) file is discussed separately.
 .SH OMAPI
--- dhcp-3.0.5/client/dhclient.c.client	2006-11-29 10:52:26.000000000 -0500
+++ dhcp-3.0.5/client/dhclient.c	2006-11-29 10:52:26.000000000 -0500
@@ -77,11 +77,18 @@
 #ifdef EXTENDED_NEW_OPTION_INFO
 int extended_option_environment = 0;
 #endif
+int bootp_broadcast_always = 0;
 
 static void usage PROTO ((void));
 
 void do_release(struct client_state *);
 
+extern int log_isc_blurb;
+
+extern int asprintf(char **strp, const char *fmt, ...);
+
+extern u_int32_t default_requested_options[];
+
 int main (argc, argv, envp)
 	int argc;
 	char **argv, **envp;
@@ -104,6 +111,14 @@
 	int no_dhclient_pid = 0;
 	int no_dhclient_script = 0;
 	char *s;
+	char *dhcp_client_identifier_arg = 0L;
+	char *dhcp_host_name_arg = 0L;
+	char *dhcp_fqdn_arg = 0L;
+	char *dhcp_vendor_class_identifier_arg = 0L;
+	char *dhclient_request_options = 0L;
+	int timeout_arg = 0;
+	char *arg_conf = 0L;
+	int arg_conf_len=0;
 
 	/* Make sure we have stdin, stdout and stderr. */
 	i = open ("/dev/null", O_RDWR);
@@ -145,45 +160,60 @@
 			release_mode = 1;
 			no_daemon = 1;
 		} else if (!strcmp (argv [i], "-p")) {
-			if (++i == argc)
+			if (++i == argc) {
 				usage ();
+				return EXIT_FAILURE;
+			}
 			local_port = htons (atoi (argv [i]));
 			log_debug ("binding to user-specified port %d",
 			       ntohs (local_port));
 		} else if (!strcmp (argv [i], "-d")) {
 			no_daemon = 1;
                 } else if (!strcmp (argv [i], "-pf")) {
-                        if (++i == argc)
+                        if (++i == argc) {
                                 usage ();
+                                return EXIT_FAILURE;
+                        }
                         path_dhclient_pid = argv [i];
 			no_dhclient_pid = 1;
                 } else if (!strcmp (argv [i], "-cf")) {
-                        if (++i == argc)
+                        if (++i == argc) {
                                 usage ();
+                                return EXIT_FAILURE;
+                        }
                         path_dhclient_conf = argv [i];
 			no_dhclient_conf = 1;
                 } else if (!strcmp (argv [i], "-lf")) {
-                        if (++i == argc)
+                        if (++i == argc) {
                                 usage ();
+                                return EXIT_FAILURE;
+                        }
                         path_dhclient_db = argv [i];
 			no_dhclient_db = 1;
 		} else if (!strcmp (argv [i], "-sf")) {
-			if (++i == argc)
+			if (++i == argc) {
 				usage ();
-                        path_dhclient_script = argv [i];
+				return EXIT_FAILURE;
+			}
+            path_dhclient_script = argv [i];
 			no_dhclient_script = 1;
 		} else if (!strcmp (argv [i], "-1")) {
 			onetry = 1;
 		} else if (!strcmp (argv [i], "-q")) {
 			quiet = 1;
 			quiet_interface_discovery = 1;
+			log_isc_blurb = 0;      
 		} else if (!strcmp (argv [i], "-s")) {
-			if (++i == argc)
+			if (++i == argc) {
 				usage ();
+				return EXIT_FAILURE;
+			}
 			server = argv [i];
 		} else if (!strcmp (argv [i], "-g")) {
-			if (++i == argc)
+			if (++i == argc) {
 				usage ();
+				return EXIT_FAILURE;
+			}
 			relay = argv [i];
 		} else if (!strcmp (argv [i], "-nw")) {
 			nowait = 1;
@@ -195,8 +225,10 @@
 			persist = 1;
 		} else if (!strcmp (argv [i], "-e")) {
 			struct string_list *tmp;
-			if (++i == argc)
+			if (++i == argc) {
 				usage ();
+				return EXIT_FAILURE;
+			}
 			tmp = dmalloc (strlen (argv [i]) + sizeof *tmp, MDL);
 			if (!tmp)
 				log_fatal ("No memory for %s", argv [i]);
@@ -212,8 +244,91 @@
 			extended_option_environment = 1;
 			new_option_info_tree = GENERATE_NEW_OPTION_INFO;
 #endif
+		} else if (!strcmp (argv [i], "-I")) {
+			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_OPTION_LEN) {
+				log_error("-I option dhcp-client-identifier string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_OPTION_LEN-1);
+				exit(1);
+			}
+
+			dhcp_client_identifier_arg = argv[i];
+		} else if (!strcmp (argv [i], "-B")) {
+			bootp_broadcast_always = 1;
+		} else if (!strcmp (argv [i], "-H")) {
+			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_OPTION_LEN) {
+				log_error("-H option host-name string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_OPTION_LEN-1);
+				exit(1);
+			}
+
+			if (dhcp_host_name_arg != NULL) {
+				log_error("The -H <host-name> and -F <fqdn> arguments are mutually exclusive");
+				exit(1);
+			}
+
+			dhcp_host_name_arg = argv[i];
+		} else if (!strcmp (argv [i], "-F")) {
+			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_OPTION_LEN) {
+				log_error("-F option fqdn.fqdn string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_OPTION_LEN-1);
+				exit(1);
+			}
+
+			if (dhcp_fqdn_arg != NULL) {
+				log_error("Only one -F <fqdn> argument can be specified");
+				exit(1);
+			}
+
+			if (dhcp_host_name_arg != NULL) {
+				log_error("The -F <fqdn> and -H <host-name> arguments are mutually exclusive");
+				exit(1);
+			}
+
+			dhcp_fqdn_arg = argv[i];
+		} else if (!strcmp (argv [i], "-T")) {
+			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if ((timeout_arg = atoi(argv[i])) <= 0) {
+				log_error("-T timeout option must be > 0 - bad value: %s",argv[i]);
+				exit(1);
+			}
+		} else if (!strcmp (argv [i], "-V")) {
+			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			if (strlen(argv[i]) >= DHCP_OPTION_LEN) {
+				log_error("-V option vendor-class-identifier string \"%s\" is too long - maximum length is: %d",  argv[i], DHCP_OPTION_LEN-1);
+				exit(1);
+			}
+
+			dhcp_vendor_class_identifier_arg = argv[i];
+		} else if (!strcmp (argv [i], "-R")) {
+			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
+				usage ();
+				return EXIT_FAILURE;
+			}
+
+			dhclient_request_options=argv[i];
  		} else if (argv [i][0] == '-') {
  		    usage ();
+ 		    return EXIT_FAILURE;
 		} else {
  		    struct interface_info *tmp = (struct interface_info *)0;
 		    status = interface_allocate (&tmp, MDL);
@@ -248,6 +363,7 @@
 		path_dhclient_script = s;
 	}
 
+	
 	/* first kill of any currently running client */
 	if (release_mode) {
 		FILE *pidfd;
@@ -267,8 +383,94 @@
 				}
 			}
 			fclose(pidfd);
-		}
-	}
+		}else
+		{  /* handle release for interfaces requested with Red Hat /sbin/ifup  -
+                    * pidfile will be /var/run/dhclient-$interface.pid 
+		    */
+
+		    if ( (path_dhclient_pid == NULL) || (*path_dhclient_pid == '\0'))
+			path_dhclient_pid = "/var/run/dhclient.pid";
+		    
+		    char *new_path_dhclient_pid;
+		    struct interface_info *ip;
+		    int pdp_len = strlen(path_dhclient_pid), pfx, dpfx;
+		    /* find append point: beginning of any trailing '.pid'
+		     * or '-$IF.pid' 
+		     */
+		    for (  pfx=pdp_len; 
+			   (pfx >= 0) 
+			 &&(path_dhclient_pid[pfx] != '.')
+			 &&(path_dhclient_pid[pfx] != '/'); 
+			   pfx--
+			);
+		    if( pfx == -1 )
+			pfx = pdp_len;
+		    if (path_dhclient_pid[pfx] == '/')
+			pfx += 1;
+		    for (  dpfx=pfx; 
+			   (dpfx >= 0)
+			&& (path_dhclient_pid[dpfx] != '-')
+			&& (path_dhclient_pid[dpfx] != '/');
+			   dpfx--
+                       );
+		    if ( ( dpfx > -1 ) && (path_dhclient_pid[dpfx] != '/') )
+			pfx = dpfx;					    
+		    for (ip = interfaces; ip; ip = ip -> next) 
+		    {
+			if ( interfaces_requested 
+			   &&(ip -> flags & (INTERFACE_REQUESTED))
+			   &&(ip -> name != 0L)  
+			   )
+			{
+			    int n_len = strlen(ip->name);
+
+			    new_path_dhclient_pid = (char*) malloc( pfx + n_len + 6 );
+			    strncpy( new_path_dhclient_pid, path_dhclient_pid, pfx );
+			    sprintf( new_path_dhclient_pid + pfx, "-%s.pid", ip -> name );
+
+			    if ((pidfd = fopen(new_path_dhclient_pid, "r")) != NULL) {
+				e = fscanf(pidfd, "%ld\n", &temp);
+				oldpid = (pid_t)temp;
+
+				if (e != 0 && e != EOF) {
+				    if (oldpid) {
+					if (kill(oldpid, SIGTERM) == 0)
+					    unlink(path_dhclient_pid);
+				    }
+				}
+				fclose(pidfd);
+			    }
+			    free(new_path_dhclient_pid);
+			
+			}
+		    }
+		}	          
+	}else
+	{
+	    FILE *pidfp=0L;
+	    long temp=0;
+	    pid_t dhcpid=0;
+	    int   dhc_running=0;
+	    char  procfn[256]="";
+	    
+	    if ((pidfp = fopen(path_dhclient_pid, "r")) != NULL ) 	   
+	    {
+		 if( (fscanf(pidfp, "%ld", &temp)==1)
+		   &&( (dhcpid=(pid_t)temp) > 0)
+		    )
+		 {
+		     snprintf(procfn,256,"/proc/%u",dhcpid);
+		     dhc_running = ( access(procfn, F_OK) == 0 );		     
+		 }
+		 fclose(pidfp);
+	    }
+	    if( dhc_running )
+	    {
+		log_fatal("dhclient(%u) is already running - exiting. ", dhcpid);
+		return(1);
+	    }	    
+	}	
+	write_client_pid_file();
 
 	if (!quiet) {
 		log_info ("%s %s", message, DHCP_VERSION);
@@ -348,6 +550,223 @@
 	/* Parse the dhclient.conf file. */
 	read_client_conf ();
 
+	/* Parse any extra -I / -H / -F / -T command line configuration arguments: */
+
+	if ( (dhcp_client_identifier_arg != 0L) && (*dhcp_client_identifier_arg != '\0') )
+	{ 
+		arg_conf_len = asprintf(&arg_conf,  "send dhcp-client-identifier \"%s\";",
+					dhcp_client_identifier_arg
+		                       );
+		if (( arg_conf == 0 ) || (arg_conf_len <= 0))
+			log_fatal("Unable to send -I option dhcp-client-identifier");
+	}
+	
+	if ( ( dhcp_host_name_arg != 0L ) && (*dhcp_host_name_arg != '\0') )
+	{
+		if( arg_conf == 0 )
+		{
+			arg_conf_len = asprintf(&arg_conf,  "send host-name \"%s\";",
+						dhcp_host_name_arg
+				               );
+			if( ( arg_conf == 0 ) || (arg_conf_len <= 0) )
+				log_fatal("Unable to send -H option host-name");
+		}else
+		{
+			char *last_arg_conf = arg_conf;
+			arg_conf = 0L;
+			arg_conf_len = asprintf( &arg_conf, "%s\nsend host-name \"%s\";", 
+					         last_arg_conf,
+						 dhcp_host_name_arg
+				               );
+			if ((arg_conf == 0) || (arg_conf_len <= 0))
+				log_fatal("Unable to send -H option host-name");				
+			free(last_arg_conf);
+		}
+	}
+
+	if ( ( dhcp_fqdn_arg != 0L ) && (*dhcp_fqdn_arg != '\0') )
+	{
+		if( arg_conf == 0 )
+		{
+			arg_conf_len = asprintf(&arg_conf,  "send fqdn.fqdn \"%s\";",
+					dhcp_fqdn_arg
+		                       );
+			if( ( arg_conf == 0 ) || (arg_conf_len <= 0) )
+				log_fatal("Unable to send -F option fqdn.fqdn");
+		}else
+		{
+			char *last_arg_conf = arg_conf;
+			arg_conf = 0L;
+			arg_conf_len = asprintf( &arg_conf, "%s\nsend fqdn.fqdn \"%s\";", 
+						 last_arg_conf,
+						 dhcp_fqdn_arg
+				               );
+			if ((arg_conf == 0)  || (arg_conf_len <= 0))
+				log_fatal("Unable to send -F option fqdn.fqdn");				
+			free(last_arg_conf);
+		}
+	}
+
+	if( timeout_arg )
+	{
+		if( arg_conf == 0 )
+		{
+			arg_conf_len = asprintf(&arg_conf,  "timeout %d;",
+						timeout_arg
+		                               );
+			if( ( arg_conf == 0 ) || (arg_conf_len <= 0) )
+				log_fatal("Unable to process -T timeout argument");
+		}else
+		{
+			char *last_arg_conf = arg_conf;
+			arg_conf = 0L;
+			arg_conf_len = asprintf( &arg_conf, "%s\ntimeout %d;", 
+						 last_arg_conf,
+						 timeout_arg
+				               );
+			if ((arg_conf == 0) || (arg_conf_len == 0))
+				log_fatal("Unable to process -T timeout argument");
+			free(last_arg_conf);
+		}
+	}
+
+	if (   ( dhcp_vendor_class_identifier_arg != 0L ) 
+	    && (*dhcp_vendor_class_identifier_arg != '\0') 
+           )
+	{
+		if( arg_conf == 0 )
+		{
+			arg_conf_len = asprintf(&arg_conf,  "send vendor-class-identifier \"%s\";",
+						dhcp_vendor_class_identifier_arg
+		                               );
+			if( ( arg_conf == 0 ) || (arg_conf_len <= 0) )
+				log_fatal("Unable to send -V option vendor-class-identifier");
+		}else
+		{
+			char *last_arg_conf = arg_conf;
+			arg_conf = 0L;
+			arg_conf_len = asprintf( &arg_conf, "%s\nsend vendor-class-identifier \"%s\";", 
+						 last_arg_conf,
+						 dhcp_vendor_class_identifier_arg
+				               );
+			if ((arg_conf == 0)  || (arg_conf_len <= 0))
+				log_fatal("Unable to send -V option vendor-class-identifier");
+			free(last_arg_conf);
+		}
+	}
+
+	if ( dhclient_request_options != 0L )
+	{
+		if( arg_conf == 0 )
+		{
+			arg_conf_len = asprintf(&arg_conf,  "request %s;", dhclient_request_options);
+			if( ( arg_conf == 0 ) || (arg_conf_len <= 0) )
+				log_fatal("Unable to parse -R <request options list> argument");
+		}else
+		{
+			char *last_arg_conf = arg_conf;
+			arg_conf = 0L;
+			arg_conf_len = asprintf( &arg_conf, "%s\nrequest %s;", 
+						 last_arg_conf,
+						 dhclient_request_options
+				               );
+			if ((arg_conf == 0)  || (arg_conf_len <= 0))
+				log_fatal("Unable to parse -R <request options list> argument");
+			free(last_arg_conf);
+		}
+	}
+
+	if ( arg_conf )
+	{
+		if( arg_conf_len == 0 )
+			if( (arg_conf_len = strlen(arg_conf)) == 0 )
+                             /* huh ? cannot happen ! */
+				log_fatal("Unable to process -I/-H/-F/-T/-V/-R configuration arguments");
+		
+		/* parse the extra dhclient.conf configuration arguments
+		 * into top level config:
+		 */
+	      	struct parse *cfile = (struct parse *)0;
+		const char *val=0L;
+		int  token;
+		
+		status = new_parse (&cfile, -1, arg_conf, arg_conf_len,
+				    "extra dhclient -I/-H/-F/-T/-V/-R configuration arguments", 0
+				   );
+
+		if ((status != ISC_R_SUCCESS) || ( cfile -> warnings_occurred ))
+			log_fatal ("Cannot parse -I/-H/-F/-T/-V/-R configuration arguments !");
+		        /* more detailed parse failures will be logged */
+
+		do {
+			token = peek_token (&val, (unsigned *)0, cfile);
+			if (token == END_OF_FILE)
+				break;
+
+			parse_client_statement (cfile,
+						(struct interface_info *)0,
+						&top_level_config);
+			
+
+		} while (1);
+
+		if( cfile -> warnings_occurred )
+			log_fatal ("Cannot parse -I/-H/-F/-T/-V/-R configuration arguments !");
+		end_parse (&cfile);
+
+		if ( timeout_arg )
+		{
+			/* we just set the toplevel timeout, but per-client timeouts may
+			   still be at defaults. Also, it makes no sense having the 
+                           reboot_timeout or backoff_cutoff greater than the timeout:
+                         */
+			if ( ( top_level_config.backoff_cutoff == 15 )
+			   &&( top_level_config.backoff_cutoff > ( timeout_arg / 2 ) )
+			     )  top_level_config.backoff_cutoff
+				= (((unsigned long)( timeout_arg / 2 ))==0)
+				  ? timeout_arg
+				  : (unsigned long)( timeout_arg / 2 );
+
+			for (ip = interfaces; ip; ip = ip -> next) 
+			{
+				if ( ip -> client -> config -> timeout == 60 )
+					ip -> client -> config -> timeout = timeout_arg;
+
+				if ( (ip -> client -> config -> reboot_timeout == 10 )
+				   &&(ip -> client -> config -> reboot_timeout 
+				     >ip -> client -> config -> timeout
+				     )
+				   )    ip -> client -> config -> reboot_timeout 
+				      = ip -> client -> config -> timeout;
+
+				if ( (ip -> client -> config -> backoff_cutoff == 15 )
+				   &&(ip -> client -> config -> backoff_cutoff
+				     > top_level_config.backoff_cutoff
+				     )
+				  )     ip -> client -> config -> backoff_cutoff
+				      = top_level_config.backoff_cutoff;
+			}
+		}
+
+		if (  ( dhclient_request_options != 0 )
+		    &&( top_level_config.requested_options !=  default_requested_options )
+		   )
+		{
+			for (ip = interfaces; ip; ip = ip -> next) 
+			{
+				if (    ip -> client -> config -> requested_options 
+				     == default_requested_options
+				   )
+					ip -> client -> config -> requested_options =
+						top_level_config.requested_options;
+			}
+		}
+
+		free(arg_conf);
+		arg_conf = 0L;
+		arg_conf_len = 0L;
+	}
+		
 	/* Parse the lease database. */
 	read_client_leases ();
 
@@ -385,6 +804,16 @@
 				continue;
 			script_init (ip -> client,
 				     "PREINIT", (struct string_list *)0);
+			if (/* Has an active lease */
+			    ip -> client -> active &&
+			    !ip -> client -> active -> is_bootp &&
+			    ip -> client -> active -> expiry > cur_time &&
+			    /* Which is same as current ip */
+			    ip -> primary_address.s_addr != 0 &&
+			    ip -> client -> active -> address.len == 4 &&
+			    memcmp (ip -> client -> active -> address.iabuf,
+				    &ip->primary_address, 4) == 0)
+				client_envadd (ip -> client, "", "keep_old_ip", "%s", "yes");
 			if (ip -> client -> alias)
 				script_write_params (ip -> client, "alias_",
 						     ip -> client -> alias);
@@ -423,10 +852,7 @@
 				do_release (client);
 			else {
 				client -> state = S_INIT;
-				/* Set up a timeout to start the initialization
-				   process. */
-				add_timeout (cur_time + random () % 5,
-					     state_reboot, client, 0, 0);
+				add_timeout (cur_time, state_reboot, client, 0, 0);
 			}
 		}
 	}
@@ -479,20 +905,27 @@
 
 static void usage ()
 {
-	log_info ("%s %s", message, DHCP_VERSION);
-	log_info (copyright);
-	log_info (arr);
-	log_info (url);
+	printf ("%s %s\n", message, DHCP_VERSION);
+	printf (copyright);
+	printf ("\n");
+	printf (arr);
+	printf ("\n");
+	printf (url);
+	printf ("\n");
 
 #ifdef EXTENDED_NEW_OPTION_INFO
-	log_error ("Usage: dhclient [-1dqr] [-nwx] [-p <port>] %s",
+	printf ("Usage: dhclient [-1dqr] [-nwx] [-p <port>] %s",
 #else
-	log_error ("Usage: dhclient [-1dqr] [-nw] [-p <port>] %s",
+	printf ("Usage: dhclient [-1dqr] [-nw] [-p <port>] %s",
 #endif
-		   "[-s server]");
-	log_error ("                [-cf config-file] [-lf lease-file]%s",
-		   "[-pf pid-file] [-e VAR=val]");
-	log_fatal ("                [-sf script-file] [interface]");
+		"[-s server]");
+	printf ("                [-cf config-file] [-lf lease-file]%s",
+		"[-pf pid-file] [-e VAR=val]");
+	printf ("                [ -I <dhcp-client-identifier> ] [-B]\n");
+	printf ("                [ -H <host-name> | -F <fqdn.fqdn> ] [ -T <timeout> ]\n");
+	printf ("                [ -V <vendor-class-identifier> ]\n");
+	printf ("                [ -R <request option list> ]\n");
+	printf ("                [-sf script-file] [interface]");
 }
 
 isc_result_t find_class (struct class **c,
@@ -599,6 +1032,7 @@
 	void *cpp;
 {
 	struct client_state *client = cpp;
+	enum dhcp_state init_state = client -> state;
 
 	ASSERT_STATE(state, S_INIT);
 
@@ -611,9 +1045,20 @@
 	client -> first_sending = cur_time;
 	client -> interval = client -> config -> initial_interval;
 
-	/* Add an immediate timeout to cause the first DHCPDISCOVER packet
-	   to go out. */
-	send_discover (client);
+	if ( init_state != S_DECLINED )
+	{
+		/* Add an immediate timeout to cause the first DHCPDISCOVER packet
+		   to go out. */	
+		send_discover (client);
+	}else
+	{
+		/* We've received an OFFER and it has been DECLINEd by dhclient-script.
+		 * wait for a random time between 1 and backoff_cutoff seconds before trying again. 
+		 */
+		add_timeout( cur_time + (( 1 + (random () >> 2) ) %  client -> config -> backoff_cutoff),
+			     send_discover, client, 0, 0
+			   ); 
+	}
 }
 
 /* state_selecting is called when one or more DHCPOFFER packets have been
@@ -693,7 +1138,6 @@
 	/* Add an immediate timeout to send the first DHCPREQUEST packet. */
 	send_request (client);
 }  
-
 /* state_requesting is called when we receive a DHCPACK message after
    having sent out one or more DHCPREQUEST packets. */
 
@@ -884,6 +1328,7 @@
 		send_decline (client);
 		destroy_client_lease (client -> new);
 		client -> new = (struct client_lease *)0;
+		client -> state = S_DECLINED;
 		state_init (client);
 		return;
 	}
@@ -1395,6 +1840,7 @@
 
 	/* If we're past the panic timeout, call the script and tell it
 	   we haven't found anything for this interface yet. */
+
 	if (interval > client -> config -> timeout) {
 		state_panic (client);
 		return;
@@ -1934,8 +2380,9 @@
 	client -> packet.xid = random ();
 	client -> packet.secs = 0; /* filled in by send_discover. */
 
-	if (can_receive_unicast_unconfigured (client -> interface))
-		client -> packet.flags = 0;
+	if (  (!(bootp_broadcast_always || client -> config -> bootp_broadcast_always))
+	   && can_receive_unicast_unconfigured (client -> interface)
+	   )	client -> packet.flags = 0;
 	else
 		client -> packet.flags = htons (BOOTP_BROADCAST);
 
@@ -2021,8 +2468,9 @@
 	} else {
 		memset (&client -> packet.ciaddr, 0,
 			sizeof client -> packet.ciaddr);
-		if (can_receive_unicast_unconfigured (client -> interface))
-			client -> packet.flags = 0;
+		if (  (!(bootp_broadcast_always || client -> config -> bootp_broadcast_always))
+		   && can_receive_unicast_unconfigured (client -> interface)
+		   )	client -> packet.flags = 0;
 		else
 			client -> packet.flags = htons (BOOTP_BROADCAST);
 	}
@@ -2081,8 +2529,9 @@
 	client -> packet.hops = 0;
 	client -> packet.xid = client -> xid;
 	client -> packet.secs = 0; /* Filled in by send_request. */
-	if (can_receive_unicast_unconfigured (client -> interface))
-		client -> packet.flags = 0;
+	if (  (!(bootp_broadcast_always || client -> config -> bootp_broadcast_always))
+	   && can_receive_unicast_unconfigured (client -> interface)
+	   )    client -> packet.flags = 0;
 	else
 		client -> packet.flags = htons (BOOTP_BROADCAST);
 
@@ -2549,6 +2998,7 @@
 
 	es.client = client;
 	es.prefix = prefix;
+	es.universe = 0L;
 
 	client_envadd (client,
 		       prefix, "ip_address", "%s", piaddr (lease -> address));
@@ -2677,6 +3127,8 @@
 			wstatus = 0;
 		}
 	} else {
+	        if (leaseFile)
+		  fclose (leaseFile);
 		execve (scriptName, argv, envp);
 		log_error ("execve (%s, ...): %m", scriptName);
 		exit (0);
@@ -2868,7 +3320,9 @@
 			      case S_INIT:
 			      case S_REBINDING:
 			      case S_STOPPED:
+			      case S_DECLINED:
 				break;
+				
 			}
 			client -> state = S_INIT;
 			state_reboot (client);
