diff -ru gateway-1.3.2-old/gw/smsc/smsc_http.c gateway-1.3.2/gw/smsc/smsc_http.c
--- gateway-1.3.2-old/gw/smsc/smsc_http.c	2004-06-29 18:22:34.000000000 +0400
+++ gateway-1.3.2/gw/smsc/smsc_http.c	2004-11-09 15:30:56.000000000 +0300
@@ -505,6 +505,198 @@
     http_destroy_headers(reply_headers);
 }
 
+// mgfkavkaz version of Kannel HTTP SMSC
+// "text" parameter is renamed to "msg"
+
+static void mgfkavkaz_send_sms(SMSCConn *conn, Msg *sms)
+{
+    ConnData *conndata = conn->data;
+    Octstr *url;
+    List *headers;
+
+    if (!conndata->no_sep) {
+        url = octstr_format("%S?"
+			    "username=%E&password=%E&to=%E&msg=%E",
+			     conndata->send_url,
+			     conndata->username, conndata->password,
+			     sms->sms.receiver, sms->sms.msgdata);
+    } else {
+        octstr_binary_to_hex(sms->sms.msgdata, HEX_NOT_UPPERCASE);
+        url = octstr_format("%S?"
+			    "username=%E&password=%E&to=%E&msg=%S",
+			     conndata->send_url,
+			     conndata->username, conndata->password,
+			     sms->sms.receiver, 
+                             sms->sms.msgdata); 
+    }   
+
+    if (octstr_len(sms->sms.udhdata)) {
+        if (!conndata->no_sep) {
+	    octstr_format_append(url, "&udh=%E", sms->sms.udhdata);
+        } else {
+	    octstr_binary_to_hex(sms->sms.udhdata, HEX_NOT_UPPERCASE);
+            octstr_format_append(url, "&udh=%S", sms->sms.udhdata);
+	}
+    }
+
+    if (!conndata->no_sender)
+        octstr_format_append(url, "&from=%E", sms->sms.sender);
+    if (sms->sms.mclass != MC_UNDEF)
+	octstr_format_append(url, "&mclass=%d", sms->sms.mclass);
+    if (!conndata->no_coding && sms->sms.coding != DC_UNDEF)
+	octstr_format_append(url, "&coding=%d", sms->sms.coding);
+    if (sms->sms.mwi != MWI_UNDEF)
+	octstr_format_append(url, "&mwi=%d", sms->sms.mwi);
+    if (sms->sms.account) /* prepend account with local username */
+	octstr_format_append(url, "&account=%E:%E", sms->sms.service, sms->sms.account);
+    if (sms->sms.binfo) /* prepend billing info */
+	octstr_format_append(url, "&binfo=%S", sms->sms.binfo);
+    if (sms->sms.smsc_id) /* proxy the smsc-id to the next instance */
+	octstr_format_append(url, "&smsc=%S", sms->sms.smsc_id);
+    if (sms->sms.dlr_url) {
+        octstr_format_append(url, "&dlr-url=%E", sms->sms.dlr_url);
+    }
+    if (sms->sms.dlr_mask != DLR_UNDEFINED && sms->sms.dlr_mask != DLR_NOTHING)
+        octstr_format_append(url, "&dlr-mask=%d", sms->sms.dlr_mask);
+
+    headers = list_create();
+    debug("smsc.http.kannel", 0, "HTTP[%s]: Start request",
+          octstr_get_cstr(conn->id));
+    http_start_request(conndata->http_ref, HTTP_METHOD_GET, url, headers, 
+                       NULL, 0, sms, NULL);
+
+    octstr_destroy(url);
+    http_destroy_headers(headers);
+
+}
+
+static void mgfkavkaz_parse_reply(SMSCConn *conn, Msg *msg, int status,
+			       List *headers, Octstr *body)
+{
+    /* Test on three cases:
+     * 1. an smsbox reply of an remote kannel instance
+     * 2. an smsc_http response (if used for MT to MO looping)
+     * 3. an smsbox reply of partly sucessfull sendings */
+    if ((status == HTTP_OK || status == HTTP_ACCEPTED)
+        && (octstr_case_compare(body, octstr_imm("Sent.")) == 0 ||
+            octstr_case_compare(body, octstr_imm("Ok.")) == 0 ||
+            octstr_ncompare(body, octstr_imm("Result: OK"),10) == 0)) {
+        bb_smscconn_sent(conn, msg, NULL);
+    } else {
+        bb_smscconn_send_failed(conn, msg,
+	            SMSCCONN_FAILED_MALFORMED, octstr_duplicate(body));
+    }
+}
+
+static void mgfkavkaz_receive_sms(SMSCConn *conn, HTTPClient *client,
+			       List *headers, Octstr *body, List *cgivars)
+{
+    ConnData *conndata = conn->data;
+    Octstr *user, *pass, *from, *to, *text, *udh, *account, *binfo, *tmp_string;
+    Octstr *retmsg;
+    int	mclass, mwi, coding, validity, deferred;
+    List *reply_headers;
+    int ret;
+
+    mclass = mwi = coding = validity = deferred = 0;
+
+    user = http_cgi_variable(cgivars, "username");
+    pass = http_cgi_variable(cgivars, "password");
+    from = http_cgi_variable(cgivars, "from");
+    to = http_cgi_variable(cgivars, "to");
+    text = http_cgi_variable(cgivars, "text");
+    udh = http_cgi_variable(cgivars, "udh");
+    account = http_cgi_variable(cgivars, "account");
+    binfo = http_cgi_variable(cgivars, "binfo");
+    tmp_string = http_cgi_variable(cgivars, "flash");
+    if(tmp_string) {
+	sscanf(octstr_get_cstr(tmp_string),"%d", &mclass);
+    }
+    tmp_string = http_cgi_variable(cgivars, "mclass");
+    if(tmp_string) {
+	sscanf(octstr_get_cstr(tmp_string),"%d", &mclass);
+    }
+    tmp_string = http_cgi_variable(cgivars, "mwi");
+    if(tmp_string) {
+	sscanf(octstr_get_cstr(tmp_string),"%d", &mwi);
+    }
+    tmp_string = http_cgi_variable(cgivars, "coding");
+    if(tmp_string) {
+	sscanf(octstr_get_cstr(tmp_string),"%d", &coding);
+    }
+    tmp_string = http_cgi_variable(cgivars, "validity");
+    if(tmp_string) {
+	sscanf(octstr_get_cstr(tmp_string),"%d", &validity);
+    }
+    tmp_string = http_cgi_variable(cgivars, "deferred");
+    if(tmp_string) {
+	sscanf(octstr_get_cstr(tmp_string),"%d", &deferred);
+    }
+    debug("smsc.http.kannel", 0, "HTTP[%s]: Received an HTTP request",
+          octstr_get_cstr(conn->id));
+    
+    if (user == NULL || pass == NULL ||
+	    octstr_compare(user, conndata->username) != 0 ||
+	    octstr_compare(pass, conndata->password) != 0) {
+
+        error(0, "HTTP[%s]: Authorization failure",
+              octstr_get_cstr(conn->id));
+        retmsg = octstr_create("Authorization failed for sendsms");
+    }
+    else if (from == NULL || to == NULL || text == NULL) {
+	
+        error(0, "HTTP[%s]: Insufficient args",
+              octstr_get_cstr(conn->id));
+        retmsg = octstr_create("Insufficient args, rejected");
+    }
+    else if (udh != NULL && (octstr_len(udh) != octstr_get_char(udh, 0) + 1)) {
+        error(0, "HTTP[%s]: UDH field misformed, rejected",
+              octstr_get_cstr(conn->id));
+        retmsg = octstr_create("UDH field misformed, rejected");
+    }
+    else if (udh != NULL && octstr_len(udh) > MAX_SMS_OCTETS) {
+        error(0, "HTTP[%s]: UDH field is too long, rejected",
+              octstr_get_cstr(conn->id));
+        retmsg = octstr_create("UDH field is too long, rejected");
+    }
+    else {
+
+	Msg *msg;
+	msg = msg_create(sms);
+
+	debug("smsc.http.kannel", 0, "HTTP[%s]: Constructing new SMS",
+          octstr_get_cstr(conn->id));
+	
+	msg->sms.sender = octstr_duplicate(from);
+	msg->sms.receiver = octstr_duplicate(to);
+	msg->sms.msgdata = octstr_duplicate(text);
+	msg->sms.udhdata = octstr_duplicate(udh);
+
+	msg->sms.smsc_id = octstr_duplicate(conn->id);
+	msg->sms.time = time(NULL);
+	msg->sms.mclass = mclass;
+	msg->sms.mwi = mwi;
+	msg->sms.coding = coding;
+	msg->sms.validity = validity;
+	msg->sms.deferred = deferred;
+	msg->sms.account = octstr_duplicate(account);
+	msg->sms.binfo = octstr_duplicate(binfo);
+	ret = bb_smscconn_receive(conn, msg);
+	if (ret == -1)
+	    retmsg = octstr_create("Not accepted");
+	else
+	    retmsg = octstr_create("Sent.");
+    }
+    reply_headers = list_create();
+    http_header_add(reply_headers, "Content-Type", "text/plain");
+    debug("smsc.http.kannel", 0, "HTTP[%s]: Sending reply",
+          octstr_get_cstr(conn->id));
+    http_send_reply(client, HTTP_ACCEPTED, reply_headers, retmsg);
+
+    octstr_destroy(retmsg);
+    http_destroy_headers(reply_headers);
+}
+
 
 /*----------------------------------------------------------------
  * Brunet - A german aggregator (mainly doing T-Mobil D1 connections)
@@ -1041,6 +1233,16 @@
         conndata->send_sms = wapme_smsproxy_send_sms;
         conndata->parse_reply = wapme_smsproxy_parse_reply;
     }
+    else if (octstr_case_compare(type, octstr_imm("mgfkavkaz")) == 0) {
+        if (conndata->username == NULL || conndata->password == NULL) {
+            error(0, "HTTP[%s]: 'username' and 'password' required for mgfkavkaz http smsc",
+                  octstr_get_cstr(conn->id));
+            goto error;
+        }
+        conndata->receive_sms = mgfkavkaz_receive_sms;
+        conndata->send_sms = mgfkavkaz_send_sms;
+        conndata->parse_reply = mgfkavkaz_parse_reply;
+    }
     /*
      * ADD NEW HTTP SMSC TYPES HERE
      */
