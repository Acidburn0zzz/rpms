diff -Naur fwlogwatch-1.2.orig/cisco_ios.c fwlogwatch-1.2/cisco_ios.c
--- fwlogwatch-1.2.orig/cisco_ios.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/cisco_ios.c	2011-09-08 11:35:35.601380119 +0200
@@ -0,0 +1,2158 @@
+#line 2 "cisco_ios.c"
+
+#line 4 "cisco_ios.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer cisco_ios_create_buffer
+#define yy_delete_buffer cisco_ios_delete_buffer
+#define yy_flex_debug cisco_ios_flex_debug
+#define yy_init_buffer cisco_ios_init_buffer
+#define yy_flush_buffer cisco_ios_flush_buffer
+#define yy_load_buffer_state cisco_ios_load_buffer_state
+#define yy_switch_to_buffer cisco_ios_switch_to_buffer
+#define yyin cisco_iosin
+#define yyleng cisco_iosleng
+#define yylex cisco_ioslex
+#define yylineno cisco_ioslineno
+#define yyout cisco_iosout
+#define yyrestart cisco_iosrestart
+#define yytext cisco_iostext
+#define yywrap cisco_ioswrap
+#define yyalloc cisco_iosalloc
+#define yyrealloc cisco_iosrealloc
+#define yyfree cisco_iosfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE cisco_iosrestart(cisco_iosin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int cisco_iosleng;
+
+extern FILE *cisco_iosin, *cisco_iosout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up cisco_iostext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up cisco_iostext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via cisco_iosrestart()), so that the user can continue scanning by
+	 * just pointing cisco_iosin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when cisco_iostext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int cisco_iosleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow cisco_ioswrap()'s to do buffer switches
+ * instead of setting up a fresh cisco_iosin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void cisco_iosrestart (FILE *input_file  );
+void cisco_ios_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE cisco_ios_create_buffer (FILE *file,int size  );
+void cisco_ios_delete_buffer (YY_BUFFER_STATE b  );
+void cisco_ios_flush_buffer (YY_BUFFER_STATE b  );
+void cisco_iospush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void cisco_iospop_buffer_state (void );
+
+static void cisco_iosensure_buffer_stack (void );
+static void cisco_ios_load_buffer_state (void );
+static void cisco_ios_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER cisco_ios_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE cisco_ios_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE cisco_ios_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE cisco_ios_scan_bytes (yyconst char *bytes,int len  );
+
+void *cisco_iosalloc (yy_size_t  );
+void *cisco_iosrealloc (void *,yy_size_t  );
+void cisco_iosfree (void *  );
+
+#define yy_new_buffer cisco_ios_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        cisco_iosensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            cisco_ios_create_buffer(cisco_iosin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        cisco_iosensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            cisco_ios_create_buffer(cisco_iosin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define cisco_ioswrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *cisco_iosin = (FILE *) 0, *cisco_iosout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int cisco_ioslineno;
+
+int cisco_ioslineno = 1;
+
+extern char *cisco_iostext;
+#define yytext_ptr cisco_iostext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up cisco_iostext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	cisco_iosleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 21
+#define YY_END_OF_BUFFER 22
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[219] =
+    {   0,
+        0,    0,   22,   20,   18,   17,   20,   20,   20,   20,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       17,    0,    0,   16,    0,    0,    0,    2,    0,    0,
+        0,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,    0,    0,    0,    0,    0,    0,    0,
+       19,   19,    0,    0,    0,    0,    0,    0,    0,    0,
+       19,    0,    0,    0,    0,    0,    4,    3,    0,    0,
+        0,    0,    0,    0,    0,    5,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       15,    0,    0,    0,    0,    0,    0,   15,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       14,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   12,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    1,    0,    7,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    1,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   13,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    6,    0,    0,    0,    0,    8,    0,    0,
+
+       11,    0,    0,    0,   11,   10,    0,   11,    0,   10,
+        0,   10,    9,    0,    0,    0,    0,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    1,    1,    1,    4,    1,    1,    5,
+        6,    7,    1,    8,    9,   10,   11,   12,   12,   12,
+       12,   12,   12,   13,   12,   12,   12,   14,    1,    1,
+        1,   15,    1,    1,   16,   17,   18,   19,   20,   21,
+       22,   17,   23,   24,   17,   25,   26,   27,   28,   29,
+       17,   30,   31,   17,   17,   17,   17,   17,   17,   17,
+        1,    1,    1,    1,   32,    1,   33,   34,   35,   36,
+
+       37,   38,   39,   40,   41,   17,   42,   43,   44,   45,
+       46,   47,   17,   48,   49,   50,   51,   52,   53,   17,
+       54,   17,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[55] =
+    {   0,
+        1,    1,    2,    1,    3,    4,    5,    1,    6,    6,
+        5,    6,    6,    3,    7,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6
+    } ;
+
+static yyconst flex_int16_t yy_base[223] =
+    {   0,
+        0,    0,  407,  408,  408,  403,  374,  398,  388,   52,
+        9,    0,  365,  364,   24,  367,  353,  363,  360,  355,
+      392,  374,  387,  408,  389,  344,   55,  408,   49,   58,
+       60,    0,  342,  350,  353,  353,  341,   31,   29,  333,
+      334,  336,  333,  363,   66,  347,   77,   69,  343,   72,
+      375,  327,  367,   82,  340,  334,  359,  319,  357,   84,
+      367,  356,   86,   90,  326,  353,  408,  408,   97,  101,
+      363,  356,  105,  354,  326,  408,   99,  359,   80,  358,
+      337,  107,  111,  309,  116,  321,  320,  327,  120,  345,
+      305,  339,  307,  303,  334,  122,  126,  408,  128,  308,
+
+      304,  329,  139,  336,  133,  308,  303,  325,  337,  136,
+      408,  150,  327,  304,  289,  318,  144,  148,  161,  155,
+      334,  286,  304,  159,  326,  167,  162,  164,  296,  300,
+      169,  408,  172,  180,  183,  278,  152,  276,  283,  284,
+      277,  276,  286,  194,  196,    0,  176,  408,  185,  200,
+      213,  272,  257,  255,  256,  249,  234,  227,  221,  236,
+      252,  249,    0,  205,  209,  217,  221,  250,  185,  181,
+      175,  166,  179,  408,  223,  225,  229,  231,  235,  237,
+      151,  227,  151,  249,  149,  253,  140,   96,  108,  102,
+      112,   93,  408,  239,  257,  259,  263,  408,  267,   97,
+
+      269,   91,  271,  275,  277,  281,   83,  408,  279,  290,
+      292,   81,  408,  294,  302,  304,   57,  408,  316,   53,
+      321,  326
+    } ;
+
+static yyconst flex_int16_t yy_def[223] =
+    {   0,
+      218,    1,  218,  218,  218,  218,  218,  219,  218,  218,
+      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      218,  218,  219,  218,  218,  218,  218,  218,  218,  218,
+      218,  220,  220,  220,  220,  220,  220,  220,  220,  220,
+      220,  220,  220,  218,  218,  218,  218,  218,  218,  218,
+      220,  220,  218,  218,  218,  218,  218,  218,  218,  218,
+      220,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      221,  218,  218,  218,  218,  218,  218,  218,  218,  221,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  222,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  222,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,    0,  218,  218,
+      218,  218
+    } ;
+
+static yyconst flex_int16_t yy_nxt[463] =
+    {   0,
+        4,    5,    6,    7,    8,    4,    4,    4,    9,    4,
+        4,   10,   10,    4,    4,   11,   12,   12,   13,   12,
+       14,   12,   12,   15,   12,   16,   17,   18,   12,   12,
+       19,    4,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   20,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   26,   33,   37,   26,   32,   34,
+       48,   48,  213,   27,   27,   28,   47,   47,   28,   49,
+       49,   50,   50,   51,   38,   51,   51,   54,   54,   26,
+       56,   56,   51,   58,   58,  209,   69,   29,   47,   47,
+       28,   63,  203,   64,   64,   70,   70,   73,   73,   63,
+
+      196,   74,   74,   77,   30,   31,  194,   30,   70,   70,
+       85,   85,   78,   78,   82,   86,   83,   83,   89,   89,
+       82,  191,   90,   90,   59,  198,   87,   92,   92,   96,
+      191,   97,   97,  103,  103,   96,  191,  104,  104,  105,
+      105,  109,  168,  110,  113,  113,  111,  118,  118,  178,
+      112,  112,  109,  125,  110,  124,  124,  111,  176,  126,
+      126,  119,  119,  109,  193,  110,  127,  127,  111,  131,
+      124,  124,  125,  134,  134,  135,  135,  125,  133,  133,
+      144,  144,  146,  145,  145,  149,  153,  164,  164,  147,
+      154,  188,  150,  148,  151,  151,  165,  165,  155,  161,
+
+      182,  125,  136,  168,  137,  144,  144,  162,  162,  138,
+      139,  166,  166,  140,  141,  149,  175,  175,  176,  181,
+      177,  177,  150,  149,  167,  167,  178,  168,  179,  179,
+      150,  168,  180,  180,  183,  183,  184,  184,  176,  149,
+      185,  185,  186,  186,  178,  189,  187,  187,  180,  180,
+      199,  199,  149,  190,  125,  191,  192,  191,  194,  174,
+      195,  195,  196,  173,  197,  197,  194,  168,  200,  200,
+      201,  201,  196,  168,  202,  202,  203,  168,  204,  204,
+      205,  205,  206,  206,  203,  209,  207,  207,  208,  208,
+      211,  211,  210,  210,  209,  172,  171,  213,  170,  213,
+
+      169,  212,  212,  214,  214,  215,  215,  213,  168,  213,
+      160,  121,  159,  216,  216,  217,  217,   23,  158,   23,
+       23,   23,   80,  157,  156,  152,   80,   80,  163,  163,
+      143,  163,  142,  132,  130,  129,  128,  123,  122,  121,
+      120,  117,  116,  115,  114,   96,  108,  107,  106,  102,
+      101,  100,   99,   98,   82,   95,   94,   93,   91,   88,
+       79,   77,   84,   63,   81,   79,   76,   75,   72,   71,
+       68,   59,   67,   66,   65,   62,   61,   60,   57,   55,
+       53,   52,   51,   51,   51,   51,   51,   51,   51,   51,
+       46,   45,   24,   44,   21,   43,   42,   41,   40,   39,
+
+       36,   35,   25,   24,   22,   21,  218,    3,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218
+    } ;
+
+static yyconst flex_int16_t yy_chk[463] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,   10,   11,   15,   27,  220,   11,
+       29,   29,  217,   10,   10,   10,   27,   27,   27,   30,
+       30,   31,   31,   38,   15,   38,   39,   45,   45,   47,
+       48,   48,   39,   50,   50,  212,   60,   10,   47,   47,
+       47,   54,  207,   54,   54,   60,   60,   63,   63,   64,
+
+      202,   64,   64,   70,   10,   10,  200,   27,   69,   69,
+       77,   77,   70,   70,   73,   79,   73,   73,   82,   82,
+       83,  192,   83,   83,   50,  191,   79,   85,   85,   89,
+      190,   89,   89,   96,   96,   97,  189,   97,   97,   99,
+       99,  103,  188,  103,  105,  105,  103,  110,  110,  187,
+      103,  103,  112,  118,  112,  117,  117,  112,  185,  118,
+      118,  112,  112,  119,  183,  119,  120,  120,  119,  124,
+      124,  124,  126,  127,  127,  128,  128,  133,  126,  126,
+      131,  131,  134,  133,  133,  135,  137,  147,  147,  134,
+      137,  181,  135,  134,  135,  135,  149,  149,  137,  144,
+
+      173,  145,  128,  172,  128,  144,  144,  145,  145,  128,
+      128,  150,  150,  128,  128,  151,  164,  164,  165,  171,
+      165,  165,  151,  167,  151,  151,  166,  170,  166,  166,
+      167,  169,  167,  167,  175,  175,  176,  176,  177,  180,
+      177,  177,  178,  178,  179,  182,  179,  179,  180,  180,
+      194,  194,  168,  182,  162,  182,  182,  182,  184,  161,
+      184,  184,  186,  160,  186,  186,  195,  159,  195,  195,
+      196,  196,  197,  158,  197,  197,  199,  157,  199,  199,
+      201,  201,  203,  203,  204,  206,  204,  204,  205,  205,
+      209,  209,  206,  206,  210,  156,  155,  211,  154,  214,
+
+      153,  210,  210,  211,  211,  214,  214,  215,  152,  216,
+      143,  142,  141,  215,  215,  216,  216,  219,  140,  219,
+      219,  219,  221,  139,  138,  136,  221,  221,  222,  222,
+      130,  222,  129,  125,  123,  122,  121,  116,  115,  114,
+      113,  109,  108,  107,  106,  104,  102,  101,  100,   95,
+       94,   93,   92,   91,   90,   88,   87,   86,   84,   81,
+       80,   78,   75,   74,   72,   71,   66,   65,   62,   61,
+       59,   58,   57,   56,   55,   53,   52,   51,   49,   46,
+       44,   43,   42,   41,   40,   37,   36,   35,   34,   33,
+       26,   25,   23,   22,   21,   20,   19,   18,   17,   16,
+
+       14,   13,    9,    8,    7,    6,    3,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
+      218,  218
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int cisco_ios_flex_debug;
+int cisco_ios_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *cisco_iostext;
+#line 1 "cisco_ios.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: cisco_ios.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "cisco_ios.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void cisco_ios_parse_date(char *input, unsigned char mode);
+void cisco_ios_parse_src(char *input, unsigned char mode);
+void cisco_ios_parse_dst(char *input, unsigned char mode);
+void cisco_ios_parse_if(char *input);
+#line 674 "cisco_ios.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int cisco_ioslex_destroy (void );
+
+int cisco_iosget_debug (void );
+
+void cisco_iosset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE cisco_iosget_extra (void );
+
+void cisco_iosset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *cisco_iosget_in (void );
+
+void cisco_iosset_in  (FILE * in_str  );
+
+FILE *cisco_iosget_out (void );
+
+void cisco_iosset_out  (FILE * out_str  );
+
+int cisco_iosget_leng (void );
+
+char *cisco_iosget_text (void );
+
+int cisco_iosget_lineno (void );
+
+void cisco_iosset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int cisco_ioswrap (void );
+#else
+extern int cisco_ioswrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( cisco_iostext, cisco_iosleng, 1, cisco_iosout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( cisco_iosin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( cisco_iosin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, cisco_iosin))==0 && ferror(cisco_iosin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(cisco_iosin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int cisco_ioslex (void);
+
+#define YY_DECL int cisco_ioslex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after cisco_iostext and cisco_iosleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 37 "cisco_ios.l"
+
+
+#line 862 "cisco_ios.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! cisco_iosin )
+			cisco_iosin = stdin;
+
+		if ( ! cisco_iosout )
+			cisco_iosout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			cisco_iosensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				cisco_ios_create_buffer(cisco_iosin,YY_BUF_SIZE );
+		}
+
+		cisco_ios_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of cisco_iostext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 219 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 218 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 39 "cisco_ios.l"
+cisco_ios_parse_date(cisco_iostext, CI_OPT_HOST);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 40 "cisco_ios.l"
+/* ignore */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 41 "cisco_ios.l"
+/* ignore */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 42 "cisco_ios.l"
+/* ignore */
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 43 "cisco_ios.l"
+/* ignore */
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 44 "cisco_ios.l"
+cisco_ios_parse_date(cisco_iostext, CI_OPT_MSEC);
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 45 "cisco_ios.l"
+cisco_ios_parse_date(cisco_iostext, CI_OPT_NONE);
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 46 "cisco_ios.l"
+/* ignore */
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 47 "cisco_ios.l"
+cisco_ios_parse_src(cisco_iostext, CI_OPT_PORT);
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 48 "cisco_ios.l"
+cisco_ios_parse_src(cisco_iostext, CI_OPT_NONE);
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 49 "cisco_ios.l"
+cisco_ios_parse_src(cisco_iostext, CI_OPT_MISSING);
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 50 "cisco_ios.l"
+cisco_ios_parse_dst(cisco_iostext, CI_OPT_PORT);
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 51 "cisco_ios.l"
+cisco_ios_parse_dst(cisco_iostext, CI_OPT_TYPE);
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 52 "cisco_ios.l"
+cisco_ios_parse_dst(cisco_iostext, CI_OPT_NONE);
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 53 "cisco_ios.l"
+{ opt.line->count = atoi(cisco_iostext); opt.parser=opt.parser|CISCO_IOS_COUNT; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 54 "cisco_ios.l"
+cisco_ios_parse_if(cisco_iostext);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 55 "cisco_ios.l"
+/* ignore whitespace */
+	YY_BREAK
+case 18:
+/* rule 18 can match eol */
+YY_RULE_SETUP
+#line 56 "cisco_ios.l"
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 57 "cisco_ios.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", cisco_iostext);
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 58 "cisco_ios.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", cisco_iostext);
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 60 "cisco_ios.l"
+ECHO;
+	YY_BREAK
+#line 1047 "cisco_ios.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed cisco_iosin at a new source and called
+			 * cisco_ioslex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = cisco_iosin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( cisco_ioswrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * cisco_iostext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of cisco_ioslex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					cisco_iosrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			cisco_iosrestart(cisco_iosin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cisco_iosrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 219 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 219 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 218);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					cisco_iosrestart(cisco_iosin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( cisco_ioswrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve cisco_iostext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void cisco_iosrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        cisco_iosensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            cisco_ios_create_buffer(cisco_iosin,YY_BUF_SIZE );
+	}
+
+	cisco_ios_init_buffer(YY_CURRENT_BUFFER,input_file );
+	cisco_ios_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void cisco_ios_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		cisco_iospop_buffer_state();
+	 *		cisco_iospush_buffer_state(new_buffer);
+     */
+	cisco_iosensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	cisco_ios_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (cisco_ioswrap()) processing, but the only time this flag
+	 * is looked at is after cisco_ioswrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void cisco_ios_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	cisco_iosin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE cisco_ios_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) cisco_iosalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_ios_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) cisco_iosalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_ios_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	cisco_ios_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with cisco_ios_create_buffer()
+ * 
+ */
+    void cisco_ios_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		cisco_iosfree((void *) b->yy_ch_buf  );
+
+	cisco_iosfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a cisco_iosrestart() or at EOF.
+ */
+    static void cisco_ios_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	cisco_ios_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then cisco_ios_init_buffer was _probably_
+     * called from cisco_iosrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void cisco_ios_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		cisco_ios_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void cisco_iospush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	cisco_iosensure_buffer_stack();
+
+	/* This block is copied from cisco_ios_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from cisco_ios_switch_to_buffer. */
+	cisco_ios_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void cisco_iospop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	cisco_ios_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		cisco_ios_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void cisco_iosensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cisco_iosalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in cisco_iosensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cisco_iosrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in cisco_iosensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE cisco_ios_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) cisco_iosalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_ios_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	cisco_ios_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to cisco_ioslex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       cisco_ios_scan_bytes() instead.
+ */
+YY_BUFFER_STATE cisco_ios_scan_string (yyconst char * yystr )
+{
+    
+	return cisco_ios_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to cisco_ioslex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE cisco_ios_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) cisco_iosalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_ios_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = cisco_ios_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in cisco_ios_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up cisco_iostext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		cisco_iostext[cisco_iosleng] = (yy_hold_char); \
+		(yy_c_buf_p) = cisco_iostext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		cisco_iosleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int cisco_iosget_lineno  (void)
+{
+        
+    return cisco_ioslineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *cisco_iosget_in  (void)
+{
+        return cisco_iosin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *cisco_iosget_out  (void)
+{
+        return cisco_iosout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int cisco_iosget_leng  (void)
+{
+        return cisco_iosleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *cisco_iosget_text  (void)
+{
+        return cisco_iostext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void cisco_iosset_lineno (int  line_number )
+{
+    
+    cisco_ioslineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see cisco_ios_switch_to_buffer
+ */
+void cisco_iosset_in (FILE *  in_str )
+{
+        cisco_iosin = in_str ;
+}
+
+void cisco_iosset_out (FILE *  out_str )
+{
+        cisco_iosout = out_str ;
+}
+
+int cisco_iosget_debug  (void)
+{
+        return cisco_ios_flex_debug;
+}
+
+void cisco_iosset_debug (int  bdebug )
+{
+        cisco_ios_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from cisco_ioslex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    cisco_iosin = stdin;
+    cisco_iosout = stdout;
+#else
+    cisco_iosin = (FILE *) 0;
+    cisco_iosout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * cisco_ioslex_init()
+     */
+    return 0;
+}
+
+/* cisco_ioslex_destroy is for both reentrant and non-reentrant scanners. */
+int cisco_ioslex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		cisco_ios_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		cisco_iospop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	cisco_iosfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * cisco_ioslex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *cisco_iosalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *cisco_iosrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void cisco_iosfree (void * ptr )
+{
+	free( (char *) ptr );	/* see cisco_iosrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 60 "cisco_ios.l"
+
+
+
+void cisco_ios_parse_date(char *input, unsigned char mode)
+{
+  int retval, day, hour, minute, second, msec;
+  char smonth[4];
+#ifdef IRIX
+  char tmp[SHOSTLEN];
+#endif
+#ifdef LOGDOTS
+  char *remove_dot;
+#endif
+
+  if (mode == CI_OPT_HOST) {
+    retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second,
+#ifndef IRIX
+		    opt.line->hostname);
+#else
+		    tmp);
+    if (retval != 6)
+      return;
+    if (tmp[2] == ':')
+      xstrncpy(opt.line->hostname, tmp + 3, SHOSTLEN);
+#endif
+#ifdef LOGDOTS
+    remove_dot = strstr(opt.line->hostname, ".");
+    if (remove_dot != NULL)
+      *remove_dot = '\0';
+#endif
+  } else if (mode == CI_OPT_MSEC) {
+    retval = sscanf(input, "%3s %2d %2d:%2d:%2d.%3d:", smonth, &day, &hour, &minute, &second, &msec);
+    if (retval != 6)
+      return;
+  } else if (mode == CI_OPT_NONE) {
+    retval = sscanf(input, "%3s %2d %2d:%2d:%2d:", smonth, &day, &hour, &minute, &second);
+    if (retval != 5)
+      return;
+  }
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | CISCO_IOS_DATE;
+}
+
+void cisco_ios_parse_src(char *input, unsigned char mode)
+{
+  char proto[8], ip[IPLEN];
+  int shost1, shost2, shost3, shost4;
+  int retval;
+
+  if (mode == CI_OPT_PORT) {
+    retval = sscanf(input, "list %" SHORTLEN_S "s %" SHORTLEN_S "s %5s %3d.%3d.%3d.%3d(%5d)",
+		    opt.line->chainlabel, opt.line->branchname, proto, &shost1, &shost2, &shost3, &shost4, &opt.line->sport);
+    if (retval != 8)
+      return;
+  } else if (mode == CI_OPT_NONE) {
+    retval = sscanf(input, "list %" SHORTLEN_S "s %" SHORTLEN_S "s %8s %3d.%3d.%3d.%3d", opt.line->chainlabel, opt.line->branchname, proto, &shost1, &shost2, &shost3, &shost4);
+    if (retval != 7)
+      return;
+  } else if (mode == CI_OPT_MISSING) {
+    return;
+  }
+
+  snprintf(ip, IPLEN, "%d.%d.%d.%d", shost1, shost2, shost3, shost4);
+  if (convert_ip(ip, &opt.line->shost) == IN_ADDR_ERROR)
+    return;
+
+  opt.parser = opt.parser | CISCO_IOS_SRC;
+
+  if (strncmp(proto, "tcp", 3) == 0)
+    opt.line->protocol = 6;
+  else if (strncmp(proto, "udp", 3) == 0)
+    opt.line->protocol = 17;
+  else if (strncmp(proto, "icmp", 4) == 0)
+    opt.line->protocol = 1;
+  else if (strncmp(proto, "igmp", 4) == 0)
+    opt.line->protocol = 2;
+  else if (strncmp(proto, "gre", 3) == 0)
+    opt.line->protocol = 47;	/* RFC1701/1702 */
+  else if (strncmp(proto, "ospf", 4) == 0)
+    opt.line->protocol = 89;
+  else if (strncmp(proto, "ipinip", 6) == 0)
+    opt.line->protocol = 4;
+  else if (strncmp(proto, "pim", 3) == 0)
+    opt.line->protocol = 103;
+  else if (isdigit((int) proto[0]))
+    opt.line->protocol = atoi(proto);
+
+  if (opt.line->protocol != 0)
+    opt.parser = opt.parser | CISCO_IOS_PROTO;
+}
+
+void cisco_ios_parse_dst(char *input, unsigned char mode)
+{
+  char ip[IPLEN];
+  int dhost1, dhost2, dhost3, dhost4;
+  int retval;
+
+  if (mode == CI_OPT_PORT) {
+    retval = sscanf(input, "-> %3d.%3d.%3d.%3d(%5d),", &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->dport);
+    if (retval != 5)
+      return;
+  } else if (mode == CI_OPT_TYPE) {
+    retval = sscanf(input, "-> %3d.%3d.%3d.%3d (%2d/%2d),", &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->sport, &opt.line->dport);
+    if (retval != 6)
+      return;
+  } else if (mode == CI_OPT_NONE) {
+    retval = sscanf(input, "-> %3d.%3d.%3d.%3d,", &dhost1, &dhost2, &dhost3, &dhost4);
+    if (retval != 4)
+      return;
+  } else {
+    return;
+  }
+
+  snprintf(ip, IPLEN, "%d.%d.%d.%d", dhost1, dhost2, dhost3, dhost4);
+  if (convert_ip(ip, &opt.line->dhost) == IN_ADDR_ERROR)
+    return;
+
+  opt.parser = opt.parser | CISCO_IOS_DST;
+}
+
+void cisco_ios_parse_if(char *input)
+{
+#ifndef SHORT_NAMES
+  xstrncpy(opt.line->interface, input, SHORTLEN);
+#else
+  xstrncpy(opt.line->interface, "-", SHORTLEN);
+#endif
+}
+
+unsigned char flex_cisco_ios(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  cisco_ios_scan_string(input);
+  cisco_ioslex();
+  cisco_ios_delete_buffer(YY_CURRENT_BUFFER);
+
+  if (opt.parser == (CISCO_IOS_DATE | CISCO_IOS_SRC | CISCO_IOS_PROTO | CISCO_IOS_DST | CISCO_IOS_COUNT)) {
+    return PARSE_OK;
+  } else {
+    if (opt.verbose)
+      fprintf(stderr, "cisco_ios parse error in line %d, ignoring.\n", linenum);
+    if (opt.verbose == 2)
+      fprintf(stderr, "input was: \"%s\"\n", input);
+    return PARSE_WRONG_FORMAT;
+  }
+}
+
diff -Naur fwlogwatch-1.2.orig/cisco_pix.c fwlogwatch-1.2/cisco_pix.c
--- fwlogwatch-1.2.orig/cisco_pix.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/cisco_pix.c	2011-09-08 11:35:42.301401158 +0200
@@ -0,0 +1,3867 @@
+#line 2 "cisco_pix.c"
+
+#line 4 "cisco_pix.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer cisco_pix_create_buffer
+#define yy_delete_buffer cisco_pix_delete_buffer
+#define yy_flex_debug cisco_pix_flex_debug
+#define yy_init_buffer cisco_pix_init_buffer
+#define yy_flush_buffer cisco_pix_flush_buffer
+#define yy_load_buffer_state cisco_pix_load_buffer_state
+#define yy_switch_to_buffer cisco_pix_switch_to_buffer
+#define yyin cisco_pixin
+#define yyleng cisco_pixleng
+#define yylex cisco_pixlex
+#define yylineno cisco_pixlineno
+#define yyout cisco_pixout
+#define yyrestart cisco_pixrestart
+#define yytext cisco_pixtext
+#define yywrap cisco_pixwrap
+#define yyalloc cisco_pixalloc
+#define yyrealloc cisco_pixrealloc
+#define yyfree cisco_pixfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE cisco_pixrestart(cisco_pixin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int cisco_pixleng;
+
+extern FILE *cisco_pixin, *cisco_pixout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up cisco_pixtext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up cisco_pixtext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via cisco_pixrestart()), so that the user can continue scanning by
+	 * just pointing cisco_pixin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when cisco_pixtext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int cisco_pixleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow cisco_pixwrap()'s to do buffer switches
+ * instead of setting up a fresh cisco_pixin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void cisco_pixrestart (FILE *input_file  );
+void cisco_pix_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE cisco_pix_create_buffer (FILE *file,int size  );
+void cisco_pix_delete_buffer (YY_BUFFER_STATE b  );
+void cisco_pix_flush_buffer (YY_BUFFER_STATE b  );
+void cisco_pixpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void cisco_pixpop_buffer_state (void );
+
+static void cisco_pixensure_buffer_stack (void );
+static void cisco_pix_load_buffer_state (void );
+static void cisco_pix_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER cisco_pix_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE cisco_pix_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE cisco_pix_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE cisco_pix_scan_bytes (yyconst char *bytes,int len  );
+
+void *cisco_pixalloc (yy_size_t  );
+void *cisco_pixrealloc (void *,yy_size_t  );
+void cisco_pixfree (void *  );
+
+#define yy_new_buffer cisco_pix_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        cisco_pixensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            cisco_pix_create_buffer(cisco_pixin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        cisco_pixensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            cisco_pix_create_buffer(cisco_pixin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define cisco_pixwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *cisco_pixin = (FILE *) 0, *cisco_pixout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int cisco_pixlineno;
+
+int cisco_pixlineno = 1;
+
+extern char *cisco_pixtext;
+#define yytext_ptr cisco_pixtext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up cisco_pixtext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	cisco_pixleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 65
+#define YY_END_OF_BUFFER 66
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[1769] =
+    {   0,
+        0,    0,   66,   64,   62,   61,   64,   64,   64,   64,
+       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
+       63,   63,   64,   63,   63,   63,   63,   63,   63,   61,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
+       63,   63,   63,   63,   63,   63,   63,    0,   63,   63,
+       63,   63,   63,   63,   63,    0,    0,    4,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   28,   63,   32,   29,   30,
+
+       31,   27,    0,    0,   63,   63,   63,   63,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   63,   63,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   26,   63,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   63,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   25,    0,    0,    0,    0,
+        0,    0,    0,   63,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   25,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   36,    0,    0,    0,    0,   25,    0,    0,    0,
+
+        0,    0,    0,   23,    0,   46,    0,    0,    0,    0,
+        0,   45,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       47,    0,    0,    0,    0,    0,    0,    0,    0,   60,
+        0,    0,    0,   23,    0,    0,   21,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   23,    0,    0,    0,   21,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   23,    0,    0,    0,   20,   21,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   23,    0,    0,    0,   20,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   37,    0,    0,    0,
+        2,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,   33,   20,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   37,    0,    0,    0,
+        0,    0,    0,    0,    1,    0,    0,   22,    0,    0,
+        0,   33,   20,   44,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    1,    0,    0,
+       22,   35,    0,   20,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   22,    0,    0,   48,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   22,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   11,    0,    0,    9,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    3,   34,    0,    0,
+       22,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   11,    0,    0,    9,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    3,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   11,    0,    0,
+        9,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   41,    0,    0,    0,   42,    0,   59,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,   11,    0,
+        0,    9,    0,    0,    0,    0,    0,    0,    0,    0,
+       43,    0,    0,    0,    0,    0,    0,    0,   57,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   11,    0,    0,
+        9,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   12,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   12,    0,    0,    0,    0,    0,    0,
+       10,    0,    8,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   12,    0,
+        0,    0,    0,    0,    0,    0,    0,   10,    8,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   19,    0,    0,    0,   52,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       10,    8,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,   38,    0,   39,    0,    0,    0,    0,   52,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   10,    8,    0,    0,    0,    0,    0,    0,    0,
+       40,    0,    0,    0,    0,    0,    0,   52,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       10,    8,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   24,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    7,    0,   13,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    7,   13,   14,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    7,   13,
+       14,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        7,   14,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    7,   14,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   14,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    6,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    6,   18,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   56,    0,
+        0,    0,    0,    0,    0,    6,   18,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    6,   18,   17,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    6,   17,
+       15,    0,   16,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   17,
+       15,   16,    0,    0,    5,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       15,   16,    0,    0,    5,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   15,   16,    0,
+        0,    5,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   15,   16,    0,    0,    5,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   58,    0,    5,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   58,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   58,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   51,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   51,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   51,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       49,    0,    0,    0,    0,    0,    0,    0,    0,   49,
+        0,    0,    0,    0,    0,    0,   49,    0,    0,    0,
+        0,    0,    0,   49,    0,    0,    0,    0,    0,    0,
+       49,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       55,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   54,   53,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   54,    0,   50,    0,
+        0,    0,    0,    0,    0,    0,    0,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    4,    1,    1,    5,    1,    1,    6,
+        7,    1,    1,    8,    9,   10,   11,   12,   13,   13,
+       13,   13,   13,   13,   13,   14,   14,   15,    1,    1,
+        1,   16,    1,    1,   17,   18,   19,   20,   21,   22,
+       23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
+       33,   34,   35,   36,   37,   38,   39,   40,   41,   38,
+       42,    1,   43,    1,   44,    1,   45,   46,   47,   48,
+
+       49,   50,   51,   52,   53,   38,   54,   55,   56,   57,
+       58,   59,   60,   61,   62,   63,   64,   65,   66,   67,
+       68,   38,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[69] =
+    {   0,
+        1,    2,    3,    4,    1,    5,    6,    1,    7,    7,
+        8,    9,    9,    9,   10,    1,   11,   11,   11,   11,
+       11,   11,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,    1,    1,    7,   11,   11,   11,   11,   11,   11,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12
+    } ;
+
+static yyconst flex_int16_t yy_base[1855] =
+    {   0,
+        0,    0, 4135, 4136, 4136,   66,   55,   80, 4131,   85,
+       98,   67,  100,  115,  120,  126,  131,  136,  141,  152,
+      163,  179, 4121,  185,  190,  192,  203,  208,  213,   97,
+     4116,  212, 4128, 4066, 4080,   53, 4070, 4078, 4079, 4072,
+     4075, 4088, 4083, 4096,  105, 4117,  219,  121,  224,  231,
+      243,  254,  260,  267,  273,  280,  286,  291,  296,  301,
+      316,  321,  323,  334,  349,  339,  360, 4052,  365,  370,
+      385,  387,  398,  400,  405, 4115, 4055, 4136, 4063, 4058,
+     4080, 4067, 4109, 4066, 4063, 4048, 4047, 4090, 4071, 4065,
+      347,  411, 4047,  416,  428,  440,  442,  447,  453,  460,
+
+      466,  471,    0,  116,  473,  484,  486,  491,  187,  499,
+        0, 4054, 4047, 4033, 4068, 4041, 4035, 4036, 4047, 4033,
+     4038, 4084, 4063,  505,  142, 4088,  383,  513,  517,  521,
+     4082, 4042,  157,  227,  535,  537, 4031,  167, 4076, 4039,
+     4022, 4081, 4080, 4018, 4020, 4032, 4017, 4015, 4024, 4063,
+      542,  548, 4011,  554,  165,  560,  566, 4071, 4026, 4057,
+     4013,  579,  584, 4007,  300,  588, 4058,  321, 4010, 4064,
+      540, 4005, 4008, 4019, 4005, 4000, 4058, 3997, 4050,  602,
+      198, 3996,  605,  610,  404, 4054, 4044, 4006, 4039,  423,
+     4050,  622, 4003,  597, 4041,  620, 4044, 3992,  587, 4029,
+
+     4027,  106, 3999, 3997, 3995, 3995, 3985, 3975, 4031, 3987,
+     3975,  470,  640,  645, 3988,  648,  245,  491, 3969, 3973,
+      653, 4023, 4013,  665, 3971,  534,  663,  669,  674,  677,
+     4025, 3982, 3961, 3971, 3969, 3962, 3962, 3992, 3991, 3966,
+     3975, 3961, 3960, 3958, 4014, 3954, 3958, 3959, 3960, 3963,
+      680,  692,  274, 4003,  693,  699,  702,    0, 3948,  706,
+      711, 3998,  714, 3978,  719, 3957,  727, 3996,  732, 3995,
+      736, 4001, 3946, 3956, 3954, 3937, 3954, 3995, 3994, 3937,
+     3937, 3991, 3990, 3928, 3955, 3935, 3986, 3935, 3924, 3938,
+      739, 3982,  751, 3981, 3936, 3919, 3978,  743,  747, 3937,
+
+     3970,  756, 3968,  759, 3942,  762, 3931,  765,  770,  773,
+      778, 4136,  782, 3922, 3929, 3915, 3927, 3925, 3907, 3963,
+     3907, 3964, 3902, 3903, 3902, 3914, 3943, 3916,  473, 3898,
+     4136, 3956,  785,   82,  788, 3911, 3894, 3953,  791, 4136,
+     3904,  794,  799,  802, 3951, 3906,  806, 3942,  811, 3941,
+      815, 3893, 3893, 3884, 3892, 3888, 3892, 3887, 3894, 3880,
+     3884, 3879, 3878, 3876, 3905, 3873, 3916, 3914, 3865, 3874,
+     3868,  346,  818,  823, 3881, 3880,  826, 3913, 3866,  831,
+     3916,  834,  310, 3876,  837,  841,  844,  849,  853, 3861,
+     3870, 3865, 3912, 3856, 3872, 3860, 3852, 3855, 3867, 3867,
+
+     3866, 3849, 3908, 3857, 3877, 3876, 3850, 3859, 3902, 3857,
+     3856, 3854,  856, 3845, 3838, 3843,  859,  862, 3840,  865,
+      870,  873, 3833, 3847, 3892,  876, 3883,  885, 3883, 3885,
+     3842, 3843, 3841, 3836, 3830, 3883, 3882, 3835, 3836, 3879,
+     3878, 3877, 3876, 3831, 3819, 3873, 3830, 3829,    0, 3817,
+     3813, 3812, 3855, 3811, 3806, 3808, 3851,  880, 3801,  892,
+     3854, 4136, 3814, 3800,    0,  888,  895,  904, 3800, 3857,
+     3856, 3800, 3809, 3793, 3808, 3793, 3850,  875,    0,    0,
+     3804, 3793, 3793, 3802, 3792, 3792,    0, 3787, 3842, 3841,
+     4136, 3781, 3793, 3778,  901, 3837, 3780, 3832,  907,  919,
+
+     3776, 3777,    0,  911,  922, 3829, 3769,  534,  321, 3771,
+     3771, 3773, 3768,    0, 3799, 3808, 3780, 3779, 3810, 3809,
+     3770, 3765, 3818, 3762, 3766, 3809,    0, 3814,    0,    0,
+     3753, 3767, 3765,  927,    0, 3810, 3749,  930,  248, 3743,
+     3752,    0,  933, 4136,  941, 3764, 3789, 3788, 3786, 3786,
+     3784, 3740, 3757, 3744, 3751, 3784, 3740, 3765, 3740, 3736,
+     3779,  937, 3778,  944, 3730, 3734, 3739, 3732, 3741, 3735,
+        0, 3775, 3774, 3781, 3780, 3734, 3766,    0, 3776, 3711,
+      947, 4136, 3721, 4136,  955, 3722, 3747, 3743, 3742, 3741,
+     3740, 3768, 3713, 3712, 3765, 3752,  951, 3763, 3762, 3705,
+
+     3760,  960, 3751,  965, 3750, 3713, 3710, 3697, 3700, 3753,
+     3697, 3743, 3742,  968, 3741,  971, 3687, 3713, 3746,  974,
+        0, 3689,  977, 3685,  985, 4136, 3714, 3742, 3741,    0,
+     3681, 3693, 3682,  990, 3673, 3689, 3735, 3675,  981,  995,
+     3725,  998, 1001, 1006, 3724, 1009, 3689, 3686, 3674, 3682,
+      602, 3668, 3718, 1012, 1017, 3722, 1022, 3721, 3664, 3691,
+     3661, 1025, 3719, 3673, 1028, 3672, 3709, 3645, 3655, 3685,
+     3643, 3650, 3651, 1031, 1036, 3635, 3625, 3616, 3609, 1041,
+     3652, 1044, 1049, 3648, 1052, 3595, 3591, 3589, 3605, 3627,
+     3621, 3612, 3563, 1057, 3610, 1060, 1065, 1068, 3604, 1071,
+
+     1076, 1079, 3594, 3545, 3560, 3518, 3555, 4136, 3556, 3551,
+     4136, 3485, 3474, 3511, 1082, 3479, 3459, 3453, 1087, 3502,
+     3465, 3450, 3446, 3456, 1090, 1095, 1098, 1101, 1106, 1109,
+     3453, 3446, 3436, 3430, 3462, 3455, 3447, 3472, 1112, 1117,
+     1120, 3465, 1125, 3455, 1129, 1134, 3449, 1138, 3405, 3444,
+     3436, 4136, 1141, 3390, 3372, 1146, 3360, 3358, 3353, 1149,
+     1154, 3336, 3341, 3346, 3388, 1159, 3370, 1162, 1167, 3366,
+     1170, 3321, 3310, 3363, 3309, 3326, 3349,    0, 1175, 3338,
+     1179, 1182, 1187, 4136, 1191, 1194, 1199, 4136, 1203, 4136,
+        0, 3282, 1206, 3283, 3282, 1209, 1214, 3285, 3279, 3333,
+
+     1219, 3321, 3276, 3318, 3312,    0, 1222, 1227, 1230, 1233,
+     1238, 1241, 3263,   14,   40,   51,   51,  113, 1244, 1249,
+     4136, 1253, 1258,  140, 1262, 1267,  144, 1271,    0,  120,
+      200, 1274,  155,  186, 1279,  229,  204,  207,  221, 1282,
+     1287,  265, 1290,    0,  263, 1294,  275, 4136, 1298,  281,
+     4136,  293,  297,  247,  252,  254,  302, 1301, 1306,  315,
+     1310, 1313, 1318, 1322, 1325, 1330, 1334,  282,  318, 1337,
+      319,  331, 1340, 1345,  325,  380,  337, 1348,  412,  424,
+     1353,  424,  429, 1356, 1359, 1363, 1366, 1370,  401,  404,
+      394,  461,  420, 1375, 1378, 1383, 1387, 1392,  460,  464,
+
+     1396,  475,  488,  445,  449, 1399,  477,  469, 1404,  529,
+      546,  550,  516, 1407,  583, 1410, 1415,  566, 1418, 1423,
+     1426,  572, 1429,  577,  528,  543,  538, 1432,  539, 1435,
+     1440, 1445,  596,  614, 1448, 1457, 1452, 1461,  623,  583,
+      636,  587,  603, 1464, 1469,  614,  619,  623, 4136,  627,
+      631,  631, 1474,  687, 1479, 1482, 1487, 1490, 1493,  640,
+      643,  653, 1505,  641, 1499,  697, 1502, 1514, 1517,  703,
+     1525,  723, 4136,  681,  682,  678, 1509,  737,  701,  706,
+      727,  737,  751,  774, 1521, 1530, 1533, 1538, 1543,  824,
+     1546, 1549,  786,  811,  893,  861,  871, 1552, 1557, 1561,
+
+      921, 4136, 1565, 4136, 1569,  934,  894,  909, 1572,  913,
+      918,  993,  942, 1003, 1014, 1577, 1018, 1582, 1023, 1585,
+     1590, 1593, 1596, 1044, 1003, 1010, 1010, 1031, 1601, 1077,
+     4136, 1605, 1609, 1613, 1616, 1041, 1103, 4136, 1061, 1072,
+     1090, 1146, 1095, 1103, 1619, 1624, 1627, 1632, 1637, 1160,
+     4136, 4136, 1640, 1130, 1132, 1141, 1162, 1643, 1648, 1652,
+     1656, 1660, 1664, 1227, 1667, 1235, 1246, 1203, 1211, 1229,
+     1237, 1671, 1311, 1676, 1323, 1679, 1684, 1689, 1353, 1303,
+     1383, 1350, 1692, 1405, 1700, 1419, 1427, 4136, 1703, 1405,
+     1706,    0, 1709, 1398, 1407, 1425, 1433, 1712, 1716, 1719,
+
+     1724, 1728, 1475, 1731, 1736, 1440, 1495,    0, 1452, 1477,
+     1744, 1529, 1747, 1480, 1499, 1539, 1752, 1524, 1541, 1590,
+     1598, 1739, 1613, 1755, 1625, 1758, 1762, 1767, 1633, 1587,
+     1622, 1672, 1643, 1644, 1708, 1771, 1677, 1697, 1748, 1774,
+     1777, 1782, 1779, 1790,    0,    0, 1785, 1788, 1791, 1795,
+     1795, 1800, 1753, 1768, 1801, 1805, 1817, 1760, 1815, 1767,
+     1763, 1815, 1820, 1816, 1823,    0, 1816, 1823, 1827, 4136,
+     1830, 1835, 1836, 1794, 1795, 1842, 1803, 1812, 1855, 1856,
+     1848, 1853, 1856, 1861, 1866, 1849, 1857, 1869, 1862, 1872,
+     1875, 1878, 1881, 1886, 1894, 1842, 1890, 1895, 1845, 1847,
+
+        0,    0, 1901, 1902, 1906, 1907, 1909, 1914, 1910, 1917,
+     1922, 1927, 4136, 1930, 1935, 1923, 1938, 1942, 1943, 1936,
+     1896, 1905, 1944, 1945, 1949, 1954, 1957, 1962, 1967, 1955,
+     1972, 1975, 1980, 1983, 1988, 4136, 1910, 1996, 1993, 1916,
+     1999, 2004, 1927, 1933, 1989, 2007, 2000, 2010, 2015, 2016,
+     2019, 2024, 2023, 2028, 2031, 2036, 2041, 2029, 2046, 2037,
+     1994, 2054, 2049, 2054, 2004, 2059, 2060, 2071, 2018, 2066,
+     2071, 2074, 2079, 2082, 2086, 2091, 2067, 2096, 2072, 2099,
+     2104, 2107, 2112, 2087, 2117, 2092, 2060, 2120, 2125,    0,
+     2112, 2128, 2133, 2136, 2141, 2149, 2113, 2144, 2117, 2152,
+
+     2157, 2160, 2165, 2170, 2126, 2175, 2134,    0, 2178, 2183,
+     2156, 2187, 2150, 2153, 2190, 2196, 2166, 2201, 2171, 2123,
+     2204, 2207, 2210, 2184, 2215, 2202, 2218, 2223, 2226, 2231,
+     2211, 2236, 2224,    0, 2239, 2243, 2227, 2246, 2249, 2253,
+     2258, 2261, 2266, 2189, 2266, 2269, 2272, 2275, 2280, 2284,
+     2267, 2288, 2281, 2288, 2292, 2295, 2300, 2296, 2312, 2305,
+     2307, 2317, 2308, 2322, 2312, 2320, 2325, 4136, 2328, 2318,
+     2331, 2335, 2338, 2342, 2347, 2351, 2323, 2343, 2354, 2306,
+     2367, 2359, 2364, 2370, 2375, 2378, 2383,    0, 4136, 2386,
+     2389, 2364, 2392, 2375, 2395, 2400, 2403, 2407, 2412, 2391,
+
+     2353, 2420, 2417, 2418, 2424, 2429, 2429, 2434, 2430, 4136,
+     2434, 2437, 2442, 2443, 2445, 2449, 2449, 2454, 2417, 2466,
+     2467, 2468, 2460, 2465, 2471, 2475, 2478, 2482, 2461, 2485,
+     2488, 2491, 2494, 2499, 2502, 2507, 2500, 2456,    0, 2519,
+     2513, 2514, 2525, 2518, 2528, 2519, 2522, 2531, 2534, 2539,
+     2523, 2542, 2545, 2550, 2487, 2546, 2553, 2558, 2506, 2570,
+     2568, 2573, 2565, 2578, 4136, 4136, 2581, 2586, 2589, 2594,
+     2565, 2577, 2566, 2597, 2601, 2579, 2539, 2613, 2605, 2617,
+     2622, 2595, 2609, 2614, 4136, 2625, 2630,    0, 2635, 2638,
+     2642, 2625, 2654, 2648, 2660, 2657, 2665, 2668, 2673, 2623,
+
+     2626, 2676, 2681, 2689, 2635,    0, 2656, 2684, 2694, 2661,
+     2699, 2655, 4136, 2702, 2668, 2705, 2710, 2674, 2636, 2718,
+     2685, 2715, 2700, 2721, 2726, 2723, 2731, 2734, 2734, 2739,
+     2684, 2747, 2739, 2743, 2750, 2755, 2758, 2748, 2761, 2766,
+     2760, 2774, 2771, 2772, 2783, 2784, 2778, 2789, 2779, 2781,
+     2794, 2790, 2742, 2797, 2802,    0, 2810, 2805, 2810, 2813,
+     2818, 4136, 2821, 2826, 2753, 2830, 2819, 2822, 2835, 2836,
+     2839, 2844, 2845, 2846, 2801, 2849, 2853, 2853, 2857, 2860,
+     2865, 2868, 2872, 2875, 2880, 2827, 2888, 2884, 2893, 2898,
+     2886, 2902, 2886, 2910, 2888, 2896, 2856, 2914, 2906, 2919,
+
+     2922, 2927, 2918, 2931, 2939, 2934, 2861, 2946, 2951, 2920,
+     2943, 2940, 2899, 2959, 2964, 2962, 2907, 2966, 2969, 2974,
+     2977, 2981, 2919, 2989, 2982, 2992, 2952, 2995, 2997, 2989,
+     3000, 2997, 3012, 3009, 2970, 3010, 2956, 3013, 3018, 3021,
+        0, 2962, 3028, 2968, 3032, 3019, 3025, 3032, 3000, 3041,
+     2992, 3039, 3043, 3046, 3046, 3050, 3016, 3009, 3064, 3057,
+     4136, 3059, 3067, 3071, 3027, 3076, 3068, 3073, 3079, 3082,
+     3020, 3095, 3089, 3090, 3098, 3101, 3045, 3114, 3106, 3111,
+     4136, 3122, 3076, 3085, 3128, 3127, 3122, 3131, 3065, 3079,
+     3134, 3139, 3143, 3091, 3105, 3148, 3153, 3157, 3116, 3108,
+
+     3155, 3159, 3112, 3118, 3173, 3166, 3175, 3176, 3174, 3178,
+     3170, 3181, 3185, 3197, 3200, 3192, 3205, 3213, 3166, 3208,
+     3218, 3186, 3183, 3182, 3205, 3223, 3219, 3204, 3208, 3207,
+     3228, 3233, 3241, 3245, 3239, 3240, 3218, 3233, 3244, 3249,
+     3207, 3239, 3216, 3257, 3256, 3216, 3243, 3212, 3263, 3267,
+     3233, 3221, 3235, 3278, 3275, 3229, 4136, 3225, 4136, 3282,
+     3229, 3288, 3291, 3236, 3275, 3295, 3294, 4136, 3307, 3317,
+     3321, 3322, 3332, 3338, 3344, 3348, 3352, 3360, 3366, 3370,
+     3371, 3373, 3375, 3377, 3383, 3389, 3391, 3397, 3403, 3405,
+     3407, 3415, 3421, 3425, 3429, 3431, 3437, 3443, 3449, 3455,
+
+     3461, 3465, 3469, 3471, 3473, 3477, 3485, 3493, 3502, 3508,
+     3516, 3518, 3530, 3532, 3538, 3540, 3546, 3552, 3554, 3556,
+     3562, 3568, 3570, 3572, 3574, 3580, 3586, 3592, 3594, 3596,
+     3602, 3608, 3610, 3612, 3618, 3624, 3626, 3632, 3636, 3638,
+     3648, 3654, 3656, 3662, 3664, 3670, 3672, 3676, 3682, 3692,
+     3694, 3700, 3702, 3708
+    } ;
+
+static yyconst flex_int16_t yy_def[1855] =
+    {   0,
+     1768,    1, 1768, 1768, 1768, 1768, 1768, 1769, 1769, 1769,
+     1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770,
+     1770, 1770, 1768, 1770, 1770, 1770, 1770, 1770, 1770, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1769, 1769, 1768, 1769, 1769,
+     1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770, 1770,
+     1770, 1770, 1770, 1770, 1770, 1770, 1770, 1768, 1770, 1770,
+     1770, 1770, 1770, 1770, 1770, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1769, 1769, 1768, 1769, 1769, 1770, 1770, 1770, 1770, 1770,
+
+     1770, 1770, 1771, 1768, 1770, 1770, 1770, 1770, 1768, 1768,
+     1772, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1769, 1769, 1768, 1769, 1769, 1769, 1768,
+     1771, 1768, 1773, 1768, 1770, 1770, 1768, 1768, 1774, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1769, 1769, 1768, 1769, 1769, 1768, 1768, 1768, 1768, 1775,
+     1768, 1770, 1770, 1768, 1768, 1768, 1774, 1776, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1769,
+     1769, 1768, 1769, 1769, 1768, 1768, 1768, 1768, 1775, 1777,
+     1768, 1770, 1768, 1768, 1768, 1768, 1778, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1769, 1769, 1768, 1769, 1769, 1768, 1768, 1768,
+     1768, 1779, 1768, 1770, 1768, 1768, 1768, 1768, 1768, 1768,
+     1778, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1769, 1769, 1768, 1768, 1769, 1768, 1780, 1768, 1768,
+     1768, 1779, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1769, 1769, 1768, 1768, 1768, 1769, 1768, 1768, 1780,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1769, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1781, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1782, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1783, 1784,
+     1768, 1768, 1768, 1768, 1768, 1768, 1785, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1786, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1787, 1768, 1768, 1768, 1768, 1788, 1789,
+     1768, 1768, 1768, 1768, 1768, 1768, 1785, 1768, 1790, 1791,
+     1768, 1768, 1768, 1768, 1792, 1768, 1768, 1768, 1768, 1768,
+     1768, 1786, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1793, 1768, 1768, 1768, 1768,
+     1788, 1794, 1789, 1795, 1768, 1768, 1768, 1768, 1768, 1768,
+     1796, 1797, 1798, 1768, 1768, 1768, 1768, 1792, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1793, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1799, 1768, 1800, 1768, 1768, 1768, 1768, 1768,
+     1768, 1801, 1797, 1802, 1798, 1803, 1768, 1768, 1768, 1768,
+     1804, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1805,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1799, 1768, 1768, 1768, 1800, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1801, 1806, 1768, 1807, 1768, 1808, 1768, 1768,
+     1768, 1768, 1809, 1768, 1768, 1768, 1768, 1768, 1768, 1810,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1811, 1768, 1768, 1768, 1807, 1768,
+
+     1768, 1768, 1808, 1768, 1768, 1768, 1768, 1768, 1809, 1768,
+     1768, 1768, 1768, 1810, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1811, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1812, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1813, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1814, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1815, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1813, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1816, 1817, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1815, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1818, 1817, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1818, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1819, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1820, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1821, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1822, 1768, 1768, 1768, 1768, 1768, 1768, 1821, 1768,
+     1768, 1768, 1768, 1768, 1823, 1824, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1822, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1825, 1826, 1827, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1828, 1826, 1768, 1827, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1829, 1830, 1768, 1768, 1768, 1768, 1768, 1768, 1828, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1831, 1832, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1831, 1768, 1832, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1833,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1834, 1768, 1768,
+     1768, 1768, 1768, 1835, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1836, 1768, 1768, 1837, 1768, 1768, 1835, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1836, 1768, 1768, 1768, 1838, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1838, 1839, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1840, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1841,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1842, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1841,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1842, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1843, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1844, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1844, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1845, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1846, 1768, 1768, 1768, 1768, 1847, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1846, 1848, 1768, 1768, 1768, 1768,
+     1849, 1768, 1768, 1768, 1768, 1768, 1768, 1850, 1768, 1768,
+     1768, 1768, 1849, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1850, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1851, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1852, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1852, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1853, 1768, 1768, 1768, 1768, 1768, 1768, 1854, 1768, 1768,
+     1768, 1768, 1768, 1768, 1854, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768,    0, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768
+    } ;
+
+static yyconst flex_int16_t yy_nxt[4205] =
+    {   0,
+        4,    5,    6,    4,    7,    8,    9,    4,    9,    9,
+        4,   10,   10,   10,    9,    4,   11,   12,   12,   13,
+       12,   14,   12,   12,   12,   15,   12,   12,   16,   17,
+       18,   19,   12,   20,   21,   12,   22,   12,   12,   12,
+       12,   23,    4,    9,   12,   24,   12,   25,   12,   26,
+       12,   27,   12,   12,   12,   12,   12,   28,   12,   12,
+       12,   12,   29,   12,   12,   12,   12,   12,   30,   45,
+      853,   42,   46,   46,   31,   81,   43,   32,   32,   32,
+       33,   46,   45,   34,   45,   35,   44,   48,  292,  854,
+       36,   47,   47,   47,   49,   37,   50,   50,   50,   30,
+
+       45,   38,   45,   46,   46,   46,   46,   45,  855,   82,
+       39,   33,   46,  856,   46,   40,   52,   45,   45,   33,
+       46,   46,   45,   45,   41,   46,   46,  858,   45,   46,
+       33,   46,   46,   45,   46,   33,   46,   46,   45,   56,
+       46,   46,   46,   45,   45,   46,   46,   46,   55,  782,
+       46,   91,  240,  786,   45,   46,   53,   46,   46,   45,
+      132,   54,  241,   57,   58,   45,   46,   45,   46,   46,
+       60,   33,  868,   93,  127,   63,  165,   46,  166,  166,
+      166,   45,   62,   59,   46,   46,   64,   45,   61,   45,
+       46,   46,   45,   46,   45,   46,   46,   46,   46,   46,
+
+       45,   33,  869,   65,   46,   45,   46,  151,   46,   46,
+       45,   66,   67,   46,   46,   45,  871,   46,   46,   46,
+       77,   45,   46,   32,   32,   32,   45,   46,   91,   45,
+       92,   92,   92,   48,  872,   94,   94,   94,  796,  137,
+       49,   33,   95,   95,   95,   45,   72,   45,   46,   46,
+      498,   70,   69,   71,  183,   73,   45,   46,  499,   46,
+       46,  875,   45,  876,   74,   46,   46,  877,   46,   45,
+       75,  880,   46,   46,   46,   45,   45,  884,   46,   46,
+       96,   46,   45,  213,  807,   46,   46,   46,   45,  161,
+      810,   46,   46,   45,   46,  889,   46,   46,   45,  890,
+
+       46,   46,   46,   45,  891,   46,   46,   46,  892,   98,
+       46,  194,  194,  194,  893,   46,  858,   97,   45,   97,
+       97,   46,   46,   45,  819,   45,   46,   46,   46,   46,
+       46,   97,  196,  196,  196,   46,   45,   46,  904,   46,
+       46,   45,  423,  424,   46,   46,   99,   97,   46,   45,
+       97,   45,   97,   46,   46,   46,  550,  551,  124,  124,
+      124,   97,   45,   46,  905,   46,   46,  104,   97,  100,
+       46,   46,   45,  907,   46,   46,   46,  908,  101,   46,
+       97,  911,  102,   97,   46,   45,  912,   45,  913,   45,
+       46,   46,   46,   46,  154,  154,  154,   97,  410,   46,
+
+       45,   46,  109,   46,   46,   46,   46,  110,  411,  412,
+       46,   46,   46,   45,   46,  218,  218,  218,   45,   46,
+       91,  840,  125,  125,  125,  127,  915,  128,  128,  128,
+       48,  107,  105,  106,  221,  221,  221,   49,  919,  129,
+      129,  129,   45,  884,  130,   46,   46,   46,   46,   45,
+      925,  926,   46,   46,   46,   45,   46,  927,   46,   46,
+      108,   46,   45,  928,  929,   46,   46,   46,   45,  862,
+      784,   46,   46,   45,   46,  133,   46,   46,   46,   46,
+       46,  251,  251,  251,  865,   46,  134,   46,   45,   46,
+       46,   46,   46,   45,  788,  939,   46,   46,   46,  136,
+
+       46,   45,  257,  257,  257,   46,  940,   45,  367,  368,
+      138,  138,  138,   33,  151,   45,  152,  152,  152,   48,
+      369,  942,  127,  156,  155,  155,  155,  370,  129,  129,
+      129,  943,  157,  157,  157,   33,  135,   45,  873,   45,
+       46,   46,   46,   46,   45,  267,  267,  267,  946,   46,
+       45,   46,  947,  180,  180,  180,   45,  151,  547,  181,
+      181,  181,   45,  183,  948,  184,  184,  184,  185,  548,
+      549,  157,  157,  157,   33,  200,  201,  186,  186,  186,
+      919,   45,  885,  163,   46,   46,   45,  887,  960,   46,
+       46,  961,  202,   46,  962,  964,  162,  165,   46,  195,
+
+      195,  195,  203,  204,   45,  895,  226,   45,  227,  227,
+      227,  213,   45,  214,  214,  214,  216,  216,  216,  183,
+      821,  217,  217,  217,   45,  973,  690,   46,   46,  228,
+      974,  229,  229,  229,  233,  950,   46,  691,  692,  234,
+      192,  235,   45,  831,  236,  951,  952,   45,  237,  975,
+      255,  252,  252,  252,  213,  976,  253,  253,  253,  256,
+      256,  256,  260,  979,  261,  261,  261,  265,  980,  981,
+       46,   46,  226,  982,  268,  268,  268,  983,  984,   46,
+      269,  269,  269,  228,  224,  270,  270,  270,  271,  271,
+      271,  291,  291,  291,   45,   45,  916,  993,  292,  994,
+
+      995,  255,  997,  293,  293,  293,  930,   33,  935,  295,
+      297,  297,  297,  298,  298,  298,  299,  302,  302,  302,
+      260,   45,  303,  303,  303,  304,  304,  304,  937, 1006,
+      306,  306,  306,   33, 1007, 1008,  308,  296,  309,  309,
+      309,  310,  312,  311,  311,  311,  944,  313,  313,  313,
+      333,  333,  333,   45,  338,  338,  338,  292,  339,  339,
+      339, 1010,  334,  334,  334,  342, 1011,  343,  343,  343,
+      344,  344,  344,  306,  306,  306,  347,  347,  347,  308,
+     1012,  348,  348,  348,  349,  349,  349,  310,  312,  350,
+      350,  350, 1013,  351,  351,  351,  373,  373,  373,  374,
+
+      374,  374,  378,  378,  378,  380,  380,  380,  342, 1014,
+      381,  381,  381,  382,  382,  382,  385,  386,  386,  386,
+      387,  312,  388,  388,  388,  414,  389,  389,  389,  413,
+      413,  413, 1015,  956,  374,  374,  374,  417,  417,  417,
+      420, 1024,  421,  421,  421,  422,  422,  422,  426,  426,
+      426,  385,  427,  427,  427,  428,  428,  428,  387,  312,
+      429,  429,  429, 1025,  430,  430,  430,  453,  453,  453,
+      457,  457,  457,  458,  458,  458,  460,  460,  460,  420,
+      515,  461,  461,  461,  462,  462,  462,  466,  466,  466,
+      467,  496,  496,  496,  498, 1026,  468,  468,  468,  504,
+
+      504,  504,  499,  500,  500,  500,  505,  505,  505,  467,
+     1027,  516,  534,  534,  534,  506,  506,  506,  538,  538,
+      538,  498,  543,  543,  543, 1028,  967,  517,  544,  499,
+      539,  539,  539,  545,  545,  545, 1035,  518,  577,  577,
+      577,  581,  581,  581,  584,  584,  584,  544,  602,  602,
+      602, 1036,  585,  585,  585,  604,  604,  604,  623,  623,
+      623,  544,  634,  634,  634, 1037,  625,  625,  625,  639,
+     1039,  640,  640,  640,  643, 1040,  644,  644,  644,  655,
+      655,  655,  657,  657,  657,  662,  662,  662,  665,  665,
+      665,  544,  680,  680,  680, 1041,  667,  667,  667,  674,
+
+     1042,  675,  675,  675,  639, 1043,  681,  681,  681,  682,
+      682,  682,  683,  683,  683,  643, 1044,  684,  684,  684,
+      685,  685,  685,  694,  694,  694,  696,  985,  697,  697,
+      697,  700,  987,  701,  701,  701,  707,  707,  707,  711,
+      711,  711,  719,  719,  719,  674, 1053,  720,  720,  720,
+      725, 1054,  726,  726,  726,  727,  727,  727,  728, 1055,
+      729,  729,  729,  730,  730,  730,  739, 1056,  740,  740,
+      740,  743,  743,  743,  696, 1057,  744,  744,  744,  745,
+      745,  745,  746,  746,  746,  700,  998,  747,  747,  747,
+      748,  748,  748,  756,  756,  756,  760, 1064,  761,  761,
+
+      761,  766,  766,  766,  725, 1065,  767,  767,  767,  768,
+      768,  768,  769,  769,  769,  728, 1066,  770,  770,  770,
+      771,  771,  771,  779,  779,  779,  739, 1067,  780,  780,
+      780,  781,  781,  781,  782,  784,  783,  783,  783, 1068,
+      785,  785,  785,  786,  788,  787,  787,  787, 1069,  789,
+      789,  789,  793,  793,  793,  796, 1070,  797,  797,  797,
+      801,  801,  801,  760, 1071,  802,  802,  802,  807, 1020,
+      808,  808,  808,  809,  809,  809,  810, 1079,  811,  811,
+      811,  812,  812,  812,  819,  821,  820,  820,  820, 1080,
+      822,  822,  822,  823,  823,  823,  782,  784,  824,  824,
+
+      824, 1081,  825,  825,  825,  826,  826,  826,  786,  788,
+      827,  827,  827,  831,  828,  828,  828,  832,  832,  832,
+      835,  835,  835,  796, 1082,  836,  836,  836,  840, 1090,
+      841,  841,  841,  846,  846,  846,  807, 1092,  847,  847,
+      847,  848,  848,  848,  849,  849,  849,  810, 1093,  850,
+      850,  850,  851,  851,  851,  859,  859,  859,  819,  821,
+      860,  860,  860, 1094,  861,  861,  861,  862,  784,  863,
+      863,  863, 1095,  864,  864,  864,  865,  788,  866,  866,
+      866,  831,  867,  867,  867,  870,  870,  870,  873, 1096,
+      874,  874,  874,  878,  878,  878,  840, 1097,  879,  879,
+
+      879,  881,  881,  881,  885,  886,  886,  886,  887,  888,
+      888,  888,  894,  894,  894,  895,  821,  896,  896,  896,
+     1045,  897,  897,  897,  898,  898,  898,  862,  784,  899,
+      899,  899, 1047,  900,  900,  900,  901,  901,  901,  865,
+      788,  902,  902,  902,  831,  903,  903,  903,  906,  906,
+      906,  909,  909,  909,  873, 1106,  910,  910,  910,  914,
+      914,  914,  916, 1107,  917,  917,  917,  920,  920,  920,
+      921,  921,  921,  885,  922,  922,  922,  923,  923,  923,
+      887,  924,  924,  924,  930, 1108,  931,  931,  931,  932,
+      932,  932,  895,  821,  933,  933,  933,  935,  934,  934,
+
+      934,  937, 1109,  936,  936,  936,  831,  938,  938,  938,
+      941,  941,  941,  944, 1058,  945,  945,  945,  949,  949,
+      949,  953,  953,  953,  916, 1002,  954,  954,  954,  955,
+      955,  955,  956, 1004,  957,  957,  957,  958,  958,  958,
+      959,  959,  959,  963,  963,  963,  965,  965,  965,  930,
+      967,  966,  966,  966, 1114, 1118,  968,  968,  968,  969,
+      969,  969,  935,  971,  971,  971,  937, 1119,  970,  970,
+      970, 1120,  972,  972,  972,  977,  977,  977,  944, 1121,
+      978,  978,  978,  985, 1076,  986,  986,  986,  987, 1130,
+      988,  988,  988,  989,  989,  989,  956, 1131,  990,  990,
+
+      990,  991,  991,  991,  992,  992,  992,  996,  998, 1133,
+      999,  999,  999, 1000, 1000, 1000,  963,  963,  963,  967,
+     1009, 1009, 1009, 1002, 1134, 1001, 1001, 1001, 1003, 1003,
+     1003, 1004, 1016, 1016, 1016, 1031, 1005, 1005, 1005,  985,
+     1137, 1017, 1017, 1017, 1018, 1018, 1018,  987, 1138, 1019,
+     1019, 1019, 1020, 1140, 1021, 1021, 1021, 1022, 1022, 1022,
+     1023, 1023, 1023, 1029, 1029, 1029,  998, 1031, 1030, 1030,
+     1030, 1002, 1032, 1032, 1032, 1004, 1033, 1033, 1033, 1143,
+     1034, 1034, 1034, 1038, 1038, 1038, 1045, 1144, 1046, 1046,
+     1046, 1047, 1145, 1048, 1048, 1048, 1049, 1049, 1049, 1020,
+
+     1146, 1050, 1050, 1050, 1051, 1051, 1051, 1052, 1052, 1052,
+     1058, 1031, 1059, 1059, 1059, 1002, 1060, 1060, 1060, 1004,
+     1061, 1061, 1061, 1098, 1062, 1062, 1062, 1063, 1063, 1063,
+     1072, 1072, 1072, 1045, 1100, 1073, 1073, 1073, 1074, 1074,
+     1074, 1047, 1104, 1075, 1075, 1075, 1076, 1153, 1077, 1077,
+     1077, 1078, 1078, 1078, 1083, 1083, 1083, 1058, 1031, 1084,
+     1084, 1084, 1002, 1085, 1085, 1085, 1004, 1086, 1086, 1086,
+     1088, 1087, 1087, 1087, 1154, 1089, 1089, 1089, 1091, 1091,
+     1091, 1098, 1099, 1099, 1099, 1100, 1156, 1101, 1101, 1101,
+     1102, 1102, 1102, 1076, 1110, 1103, 1103, 1103, 1104, 1157,
+
+     1105, 1105, 1105, 1111, 1111, 1111, 1031, 1158, 1115, 1088,
+     1110, 1112, 1112, 1112, 1113, 1113, 1113, 1091, 1091, 1091,
+     1117, 1117, 1117, 1122, 1122, 1122, 1098, 1123, 1123, 1123,
+     1124, 1124, 1124, 1100, 1160, 1125, 1125, 1125, 1126, 1127,
+     1127, 1127, 1128, 1128, 1128, 1104, 1110, 1129, 1129, 1129,
+     1147, 1147, 1147, 1088, 1161, 1135, 1135, 1135, 1136, 1136,
+     1136, 1141, 1140, 1142, 1142, 1142, 1148, 1148, 1148, 1149,
+     1149, 1149, 1126, 1150, 1150, 1150, 1151, 1088, 1152, 1152,
+     1152, 1165, 1159, 1159, 1159, 1162, 1162, 1162, 1163, 1163,
+     1163, 1141, 1166, 1164, 1164, 1164, 1169, 1169, 1169, 1170,
+
+     1170, 1170, 1171, 1171, 1171, 1126, 1172, 1172, 1172, 1151,
+     1174, 1173, 1173, 1173, 1175, 1156, 1176, 1176, 1176, 1177,
+     1178, 1088, 1179, 1180, 1181, 1141, 1182, 1182, 1182, 1183,
+     1188, 1184, 1184, 1184, 1185, 1185, 1185, 1190, 1191, 1191,
+     1191, 1192, 1192, 1192, 1193, 1151, 1194, 1194, 1194, 1195,
+     1196, 1197, 1199, 1198, 1198, 1198, 1200, 1201, 1202, 1203,
+     1203, 1203, 1181, 1210, 1204, 1204, 1204, 1205, 1205, 1205,
+     1183, 1188, 1206, 1206, 1206, 1207, 1190, 1208, 1208, 1208,
+     1211, 1211, 1211, 1212, 1212, 1212, 1213, 1213, 1213, 1214,
+     1214, 1214, 1215, 1215, 1215, 1193, 1217, 1216, 1216, 1216,
+
+     1218, 1219, 1219, 1219, 1197, 1221, 1220, 1220, 1220, 1222,
+     1225, 1181, 1226, 1226, 1226, 1227, 1183, 1228, 1228, 1228,
+     1229, 1229, 1229, 1207, 1210, 1230, 1230, 1230, 1231, 1231,
+     1231, 1232, 1193, 1233, 1233, 1233, 1234, 1237, 1235, 1235,
+     1235, 1236, 1236, 1236, 1240, 1197, 1238, 1238, 1238, 1239,
+     1239, 1239, 1241, 1243, 1242, 1242, 1242, 1244, 1246, 1248,
+     1249, 1249, 1249, 1225, 1207, 1250, 1250, 1250, 1251, 1251,
+     1251, 1227, 1261, 1252, 1252, 1252, 1253, 1265, 1254, 1254,
+     1254, 1255, 1268, 1256, 1256, 1256, 1257, 1257, 1257, 1232,
+     1269, 1258, 1258, 1258, 1259, 1259, 1259, 1234, 1237, 1260,
+
+     1260, 1260, 1263, 1246, 1264, 1264, 1264, 1262, 1262, 1262,
+     1266, 1266, 1266, 1241, 1248, 1267, 1267, 1267, 1270, 1270,
+     1270, 1271, 1271, 1271, 1272, 1225, 1273, 1273, 1273, 1274,
+     1275, 1275, 1275, 1227, 1276, 1276, 1276, 1253, 1232, 1277,
+     1277, 1277, 1278, 1278, 1278, 1255, 1234, 1279, 1279, 1279,
+     1280, 1284, 1281, 1281, 1281, 1282, 1237, 1283, 1283, 1283,
+     1285, 1285, 1285, 1263, 1287, 1286, 1286, 1286, 1288, 1241,
+     1289, 1289, 1289, 1290, 1291, 1292, 1253, 1293, 1293, 1293,
+     1294, 1255, 1295, 1295, 1295, 1296, 1296, 1296, 1272, 1308,
+     1297, 1297, 1297, 1298, 1298, 1298, 1274, 1299, 1299, 1299,
+
+     1300, 1263, 1301, 1301, 1301, 1302, 1311, 1303, 1303, 1303,
+     1304, 1304, 1304, 1280, 1315, 1305, 1305, 1305, 1306, 1306,
+     1306, 1282, 1272, 1307, 1307, 1307, 1309, 1274, 1310, 1310,
+     1310, 1312, 1312, 1312, 1288, 1280, 1313, 1313, 1313, 1316,
+     1316, 1316, 1292, 1282, 1317, 1317, 1317, 1318, 1318, 1318,
+     1294, 1320, 1319, 1319, 1319, 1322, 1322, 1322, 1334, 1288,
+     1321, 1321, 1321, 1323, 1323, 1323, 1300, 1338, 1324, 1324,
+     1324, 1325, 1325, 1325, 1302, 1292, 1326, 1326, 1326, 1327,
+     1294, 1328, 1328, 1328, 1329, 1344, 1330, 1330, 1330, 1332,
+     1332, 1332, 1309, 1300, 1333, 1333, 1333, 1335, 1336, 1336,
+
+     1336, 1339, 1339, 1339, 1339, 1340, 1320, 1341, 1341, 1341,
+     1342, 1302, 1343, 1343, 1343, 1345, 1345, 1345, 1346, 1346,
+     1346, 1347, 1347, 1347, 1348, 1355, 1349, 1349, 1349, 1350,
+     1350, 1350, 1327, 1309, 1351, 1351, 1351, 1352, 1352, 1352,
+     1329, 1338, 1353, 1353, 1353, 1356, 1366, 1357, 1357, 1357,
+     1359, 1359, 1359, 1335, 1360, 1360, 1360, 1361, 1361, 1361,
+     1339, 1339, 1339, 1339, 1362, 1362, 1362, 1340, 1320, 1363,
+     1363, 1363, 1364, 1364, 1364, 1342, 1327, 1365, 1365, 1365,
+     1367, 1367, 1367, 1368, 1368, 1368, 1369, 1369, 1369, 1348,
+     1329, 1370, 1370, 1370, 1371, 1372, 1372, 1372, 1373, 1374,
+
+     1374, 1374, 1355, 1375, 1375, 1375, 1376, 1376, 1376, 1356,
+     1379, 1377, 1377, 1377, 1380, 1335, 1382, 1340, 1383, 1383,
+     1383, 1342, 1388, 1381, 1381, 1381, 1384, 1348, 1385, 1385,
+     1385, 1386, 1356, 1387, 1387, 1387, 1389, 1389, 1389, 1390,
+     1390, 1390, 1391, 1391, 1391, 1371, 1392, 1392, 1392, 1393,
+     1393, 1393, 1373, 1394, 1394, 1394, 1395, 1379, 1396, 1396,
+     1396, 1397, 1398, 1398, 1398, 1399, 1399, 1399, 1401, 1380,
+     1403, 1403, 1403, 1382, 1371, 1404, 1404, 1404, 1402, 1402,
+     1402, 1405, 1405, 1405, 1384, 1373, 1406, 1406, 1406, 1407,
+     1407, 1407, 1386, 1419, 1408, 1408, 1408, 1410, 1410, 1410,
+
+     1411, 1411, 1411, 1412, 1412, 1412, 1413, 1413, 1413, 1395,
+     1421, 1414, 1414, 1414, 1415, 1415, 1415, 1397, 1416, 1416,
+     1416, 1417, 1380, 1418, 1418, 1418, 1423, 1382, 1424, 1424,
+     1424, 1422, 1422, 1422, 1425, 1426, 1426, 1426, 1384, 1427,
+     1428, 1428, 1428, 1386, 1430, 1431, 1431, 1431, 1432, 1432,
+     1432, 1433, 1395, 1434, 1434, 1434, 1435, 1435, 1435, 1397,
+     1436, 1436, 1436, 1417, 1438, 1437, 1437, 1437, 1419, 1439,
+     1380, 1441, 1441, 1441, 1423, 1430, 1442, 1442, 1442, 1440,
+     1440, 1440, 1443, 1443, 1443, 1425, 1444, 1444, 1444, 1445,
+     1445, 1445, 1427, 1446, 1446, 1446, 1447, 1447, 1447, 1448,
+
+     1448, 1448, 1449, 1449, 1449, 1450, 1450, 1450, 1433, 1417,
+     1451, 1451, 1451, 1452, 1452, 1452, 1453, 1455, 1454, 1454,
+     1454, 1380, 1457, 1423, 1458, 1458, 1458, 1459, 1425, 1427,
+     1461, 1463, 1433, 1464, 1464, 1464, 1460, 1460, 1460, 1462,
+     1462, 1462, 1465, 1465, 1465, 1466, 1466, 1466, 1467, 1472,
+     1468, 1468, 1468, 1469, 1469, 1469, 1470, 1470, 1470, 1453,
+     1474, 1471, 1471, 1471, 1475, 1475, 1475, 1457, 1477, 1476,
+     1476, 1476, 1459, 1479, 1453, 1461, 1481, 1481, 1481, 1488,
+     1474, 1478, 1478, 1478, 1480, 1480, 1480, 1463, 1457, 1482,
+     1482, 1482, 1483, 1483, 1483, 1467, 1492, 1484, 1484, 1484,
+
+     1485, 1485, 1485, 1486, 1463, 1487, 1487, 1487, 1489, 1489,
+     1489, 1490, 1491, 1491, 1491, 1459, 1494, 1494, 1494, 1461,
+     1498, 1498, 1498, 1467, 1493, 1493, 1493, 1506, 1495, 1495,
+     1495, 1496, 1486, 1497, 1497, 1497, 1499, 1499, 1499, 1486,
+     1516, 1500, 1500, 1500, 1502, 1490, 1503, 1503, 1503, 1504,
+     1504, 1504, 1490, 1505, 1505, 1505, 1459, 1508, 1459, 1509,
+     1509, 1509, 1461, 1461, 1496, 1507, 1507, 1507, 1511, 1511,
+     1511, 1510, 1510, 1510, 1496, 1419, 1512, 1512, 1512, 1513,
+     1513, 1513, 1516, 1502, 1514, 1514, 1514, 1517, 1517, 1517,
+     1502, 1519, 1518, 1518, 1518, 1522, 1522, 1522, 1531, 1534,
+
+     1520, 1520, 1520, 1508, 1419, 1523, 1523, 1523, 1524, 1508,
+     1525, 1525, 1525, 1526, 1526, 1526, 1527, 1527, 1527, 1529,
+     1519, 1530, 1530, 1530, 1535, 1419, 1536, 1536, 1536, 1532,
+     1532, 1532, 1537, 1537, 1537, 1524, 1541, 1538, 1538, 1538,
+     1539, 1545, 1540, 1540, 1540, 1543, 1543, 1543, 1529, 1519,
+     1544, 1544, 1544, 1534, 1547, 1547, 1547, 1524, 1546, 1546,
+     1546, 1548, 1548, 1548, 1535, 1553, 1549, 1549, 1549, 1550,
+     1550, 1550, 1551, 1551, 1551, 1539, 1541, 1552, 1552, 1552,
+     1554, 1529, 1555, 1555, 1555, 1556, 1519, 1558, 1535, 1559,
+     1559, 1559, 1562, 1562, 1562, 1557, 1557, 1557, 1560, 1539,
+
+     1561, 1561, 1561, 1563, 1565, 1564, 1564, 1564, 1566, 1566,
+     1566, 1554, 1519, 1567, 1567, 1567, 1569, 1569, 1569, 1558,
+     1575, 1570, 1570, 1570, 1571, 1571, 1571, 1560, 1554, 1572,
+     1572, 1572, 1573, 1573, 1573, 1563, 1579, 1574, 1574, 1574,
+     1576, 1577, 1577, 1577, 1580, 1558, 1581, 1581, 1581, 1582,
+     1583, 1583, 1583, 1560, 1584, 1563, 1585, 1585, 1585, 1586,
+     1587, 1587, 1587, 1576, 1588, 1588, 1588, 1579, 1589, 1589,
+     1589, 1590, 1590, 1590, 1580, 1596, 1591, 1591, 1591, 1592,
+     1592, 1592, 1582, 1593, 1593, 1593, 1594, 1594, 1594, 1584,
+     1597, 1595, 1595, 1595, 1576, 1580, 1582, 1584, 1606, 1598,
+
+     1598, 1598, 1599, 1607, 1600, 1600, 1600, 1601, 1603, 1602,
+     1602, 1602, 1541, 1604, 1604, 1604, 1597, 1609, 1609, 1609,
+     1613, 1605, 1605, 1605, 1617, 1608, 1608, 1608, 1599, 1599,
+     1610, 1610, 1610, 1611, 1611, 1611, 1601, 1603, 1612, 1612,
+     1612, 1541, 1614, 1614, 1614, 1616, 1616, 1616, 1597, 1601,
+     1615, 1615, 1615, 1621, 1622, 1622, 1622, 1618, 1618, 1618,
+     1619, 1623, 1620, 1620, 1620, 1603, 1541, 1627, 1597, 1625,
+     1624, 1624, 1624, 1626, 1626, 1626, 1633, 1628, 1628, 1628,
+     1629, 1629, 1629, 1619, 1635, 1630, 1630, 1630, 1631, 1631,
+     1631, 1621, 1632, 1632, 1632, 1603, 1637, 1597, 1619, 1625,
+
+     1634, 1634, 1634, 1636, 1636, 1636, 1638, 1621, 1639, 1639,
+     1639, 1640, 1640, 1640, 1641, 1603, 1642, 1625, 1644, 1649,
+     1651, 1643, 1643, 1643, 1645, 1645, 1645, 1638, 1638, 1646,
+     1646, 1646, 1647, 1647, 1647, 1625, 1654, 1654, 1654, 1650,
+     1650, 1650, 1652, 1653, 1653, 1653, 1656, 1657, 1625, 1658,
+     1659, 1659, 1659, 1652, 1660, 1660, 1660, 1661, 1661, 1661,
+     1656, 1662, 1662, 1662, 1663, 1664, 1665, 1652, 1667, 1669,
+     1668, 1668, 1668, 1670, 1671, 1666, 1666, 1666, 1665, 1673,
+     1673, 1673, 1667, 1677, 1674, 1674, 1674, 1672, 1672, 1672,
+     1675, 1675, 1675, 1676, 1676, 1676, 1676, 1665, 1679, 1667,
+
+     1680, 1680, 1680, 1683, 1681, 1684, 1678, 1678, 1678, 1682,
+     1682, 1682, 1676, 1676, 1676, 1676, 1665, 1686, 1686, 1686,
+     1679, 1689, 1687, 1687, 1687, 1685, 1685, 1685, 1681, 1690,
+     1665, 1679, 1694, 1688, 1688, 1688, 1691, 1681, 1692, 1692,
+     1692, 1695, 1693, 1693, 1693, 1696, 1696, 1696, 1691, 1681,
+     1697, 1697, 1697, 1699, 1698, 1698, 1698, 1700, 1701, 1702,
+     1702, 1702, 1691, 1681, 1703, 1704, 1705, 1705, 1705, 1701,
+     1706, 1706, 1706, 1707, 1708, 1709, 1701, 1711, 1712, 1713,
+     1709, 1715, 1715, 1715, 1710, 1710, 1710, 1723, 1709, 1714,
+     1714, 1714, 1716, 1716, 1716, 1716, 1717, 1717, 1717, 1709,
+
+     1724, 1725, 1719, 1716, 1716, 1716, 1716, 1728, 1718, 1718,
+     1718, 1715, 1715, 1715, 1720, 1709, 1721, 1721, 1721, 1726,
+     1726, 1726, 1729, 1730, 1722, 1722, 1722, 1720, 1720, 1727,
+     1727, 1727, 1731, 1733, 1732, 1732, 1732, 1733, 1734, 1735,
+     1735, 1735, 1731, 1737, 1736, 1736, 1736, 1738, 1739, 1731,
+     1740, 1740, 1740, 1741, 1742, 1744, 1744, 1744, 1739, 1746,
+     1745, 1745, 1745, 1747, 1748, 1739, 1743, 1749, 1750, 1750,
+     1750, 1751, 1752, 1753, 1754, 1754, 1754, 1749, 1755, 1755,
+     1755, 1756, 1757, 1758, 1759, 1749, 1761, 1762, 1759, 1760,
+     1760, 1760, 1764, 1763, 1763, 1763, 1765, 1759, 1757, 1757,
+
+     1759, 1759, 1766, 1766, 1766, 1757, 1767, 1767, 1767,   46,
+      852,   46,   46,   46,  844,   46,   46,   46,   46,   51,
+      843,   51,   51,   51,  842,   51,   51,   51,   51,  131,
+      760,  131,  139,  139,  160,  839,  838,  837,  834,  833,
+      830,  160,  160,  160,  167,  167,  167,  739,  167,  167,
+      189,  817,  189,  189,  189,  189,  197,  777,  197,  197,
+      222,  816,  222,  222,  231,  815,  231,  814,  231,  813,
+      231,  231,  262,  262,  262,  728,  262,  262,  300,  725,
+      300,  487,  487,  503,  503,  519,  519,  520,  520,  527,
+      806,  527,  805,  527,  527,  542,  804,  542,  803,  542,
+
+      542,  556,  556,  561,  800,  561,  561,  561,  561,  563,
+      799,  563,  563,  563,  563,  572,  572,  573,  573,  578,
+      578,  578,  798,  578,  578,  578,  578,  596,  795,  596,
+      596,  596,  596,  603,  794,  603,  603,  605,  792,  605,
+      605,  612,  612,  613,  613,  613,  791,  613,  613,  615,
+      615,  615,  790,  615,  615,  641,  641,  641,  700,  641,
+      641,  645,  645,  645,  696,  645,  645,  653,  653,  653,
+      741,  653,  653,  656,  778,  656,  656,  658,  777,  658,
+      658,  663,  663,  670,  670,  695,  777,  695,  695,  699,
+      776,  699,  775,  699,  774,  699,  699,  703,  773,  703,
+
+      772,  703,  765,  703,  703,  709,  764,  763,  709,  762,
+      709,  674,  709,  709,  714,  759,  714,  714,  714,  714,
+      742,  758,  742,  757,  742,  715,  742,  742,  818,  818,
+      829,  755,  829,  829,  829,  829,  829,  829,  829,  829,
+      829,  829,  845,  845,  857,  754,  857,  857,  857,  857,
+      882,  882,  883,  753,  883,  883,  883,  883,  918,  708,
+      918,  918,  918,  918, 1116, 1116, 1132, 1132, 1139,  752,
+     1139, 1139, 1139, 1139, 1155,  751, 1155, 1155, 1155, 1155,
+     1167, 1167, 1168, 1168, 1186, 1186, 1187,  750, 1187, 1187,
+     1187, 1187, 1189,  749, 1189, 1189, 1189, 1189, 1209,  702,
+
+     1209, 1209, 1209, 1209, 1223, 1223, 1224, 1224, 1245,  698,
+     1245, 1245, 1245, 1245, 1247,  741, 1247, 1247, 1247, 1247,
+     1314, 1314, 1331, 1331, 1337,  738, 1337, 1337, 1337, 1337,
+     1354,  737, 1354, 1354, 1354, 1354, 1358, 1358, 1378,  736,
+     1378, 1378, 1378, 1378, 1400,  735, 1400, 1400, 1409, 1409,
+     1420,  734,  733,  732, 1420,  731, 1420,  643, 1420, 1420,
+     1429,  639, 1429, 1429, 1429, 1429, 1456, 1456, 1473,  724,
+     1473, 1473, 1473, 1473, 1501, 1501, 1515,  723, 1515, 1515,
+     1515, 1515, 1521, 1521, 1528,  722, 1528, 1528, 1533,  721,
+     1533, 1533, 1533, 1533, 1542,  718,  717,  716, 1542,  715,
+
+     1542,  713, 1542, 1542, 1568, 1568, 1578,  712, 1578, 1578,
+     1578, 1578, 1648, 1648, 1655,  544, 1655, 1655, 1655, 1655,
+      582,  710,  708,  706,  705,  704,  702,  698,  654,  693,
+      689,  688,  687,  686,  646,  642,  679,  678,  677,  676,
+      673,  672,  671,  669,  668,  628,  666,  664,  661,  660,
+      659,  616,  614,  654,  652,  651,  650,  649,  648,  647,
+      646,  642,  638,  637,  636,  635,  597,  633,  632,  631,
+      630,  629,  629,  628,  628,  627,  626,  624,  622,  621,
+      620,  619,  618,  617,  616,  614,  611,  610,  609,  608,
+      607,  606,  564,  562,  601,  600,  599,  598,  597,  595,
+
+      594,  593,  592,  591,  590,  589,  588,  587,  586,  583,
+      582,  580,  579,  576,  575,  574,  571,  570,  569,  568,
+      567,  566,  565,  564,  562,  560,  559,  558,  557,  555,
+      554,  553,  552,  546,  467,  541,  540,  537,  536,  535,
+      533,  532,  531,  530,  529,  528,  526,  525,  524,  523,
+      522,  521,  514,  513,  512,  511,  471,  510,  509,  508,
+      507,  502,  501,  420,  497,  495,  494,  493,  492,  491,
+      490,  489,  488,  486,  485,  484,  483,  482,  481,  480,
+      479,  478,  477,  476,  475,  474,  473,  472,  471,  470,
+      469,  312,  387,  385,  465,  464,  463,  459,  456,  455,
+
+      454,  452,  451,  450,  449,  448,  447,  446,  446,  445,
+      444,  443,  442,  441,  440,  439,  438,  437,  436,  435,
+      434,  433,  432,  431,  425,  342,  419,  418,  416,  415,
+      409,  408,  407,  406,  405,  404,  403,  402,  401,  400,
+      399,  398,  397,  396,  395,  394,  393,  392,  391,  390,
+      310,  308,  384,  383,  379,  377,  376,  375,  372,  371,
+      366,  365,  364,  363,  362,  361,  360,  359,  358,  357,
+      356,  355,  354,  353,  352,  346,  345,  260,  341,  340,
+      255,  337,  336,  335,   45,  332,  331,  330,  329,  328,
+      327,  326,  325,  324,  323,  322,  321,  320,  319,  318,
+
+      317,  316,  315,  314,  228,  226,  307,  305,  263,  301,
+      294,  290,  289,  288,  287,  286,  285,  284,  283,  282,
+      281,  280,  279,  278,  277,  276,  275,  274,  273,  272,
+      230,  266,  264,  263,  259,  258,  254,  250,  249,  248,
+      247,  246,  245,  244,  243,  242,  239,  238,  232,  230,
+      165,  225,  223,  190,  220,  219,  185,  215,  212,  211,
+      210,  209,  208,  207,  206,  205,  199,  198,  168,  193,
+      191,  190,  188,  187,  182,  179,  178,  177,  176,  175,
+      174,  173,  172,  171,  170,  169,  168,  164,  159,  158,
+      153,  122,  150,  149,  148,  147,  146,  145,  144,  143,
+
+      142,  141,  140,  126,  122,  123,  122,  121,  120,  119,
+      118,  117,  116,  115,  114,  113,  112,  111,  103,   45,
+       90,   89,   88,   87,   86,   85,   84,   83,   80,   79,
+       78,   76,   68,   45, 1768,    3, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768
+    } ;
+
+static yyconst flex_int16_t yy_chk[4205] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    6,   12,
+      814,    7,   12,   12,    6,   36,    7,    6,    6,    6,
+        6,   12,    8,    6,  334,    6,    7,   10,  334,  815,
+        6,    8,    8,    8,   10,    6,   10,   10,   10,   30,
+
+       11,    6,   13,   11,   11,   13,   13,   45,  816,   36,
+        6,   30,   11,  817,   13,    6,   11,   14,  104,   45,
+       14,   14,   15,   48,    6,   15,   15,  818,   16,   14,
+      104,   16,   16,   17,   15,   48,   17,   17,   18,   14,
+       16,   18,   18,   19,  125,   17,   19,   19,   13,  824,
+       18,  125,  202,  827,   20,   19,   11,   20,   20,  133,
+      104,   11,  202,   14,   15,   21,   20,  155,   21,   21,
+       16,  133,  830,   48,  155,   19,  138,   21,  138,  138,
+      138,   22,   18,   15,   22,   22,   20,   24,   17,  109,
+       24,   24,   25,   22,   26,   25,   25,   26,   26,   24,
+
+      181,  109,  831,   21,   25,   27,   26,  181,   27,   27,
+       28,   21,   22,   28,   28,   29,  833,   27,   29,   29,
+       32,   47,   28,   32,   32,   32,   49,   29,   47,  134,
+       47,   47,   47,   50,  834,   49,   49,   49,  836,  109,
+       50,  134,   50,   50,   50,   51,   26,  217,   51,   51,
+      539,   25,   24,   25,  217,   27,   52,   51,  539,   52,
+       52,  837,   53,  838,   28,   53,   53,  839,   52,   54,
+       29,  842,   54,   54,   53,   55,  253,  845,   55,   55,
+       52,   54,   56,  253,  847,   56,   56,   55,   57,  134,
+      850,   57,   57,   58,   56,  852,   58,   58,   59,  853,
+
+       57,   59,   59,   60,  854,   58,   60,   60,  855,   56,
+       59,  165,  165,  165,  856,   60,  857,   54,   61,   55,
+       53,   61,   61,   62,  860,   63,   62,   62,   63,   63,
+       61,   57,  168,  168,  168,   62,   64,   63,  868,   64,
+       64,   66,  383,  383,   66,   66,   63,   58,   64,   91,
+       59,   65,   59,   66,   65,   65,  509,  509,   91,   91,
+       91,   60,   67,   65,  869,   67,   67,   69,   60,   64,
+       69,   69,   70,  871,   67,   70,   70,  872,   65,   69,
+       61,  875,   67,   62,   70,  127,  876,   71,  877,   72,
+       71,   71,   72,   72,  127,  127,  127,   66,  372,   71,
+
+       73,   72,   74,   73,   73,   74,   74,   75,  372,  372,
+       75,   75,   73,   92,   74,  185,  185,  185,   94,   75,
+       92,  879,   92,   92,   92,   94,  880,   94,   94,   94,
+       95,   72,   70,   71,  190,  190,  190,   95,  882,   95,
+       95,   95,   96,  883,   97,   96,   96,   97,   97,   98,
+      889,  890,   98,   98,   96,   99,   97,  891,   99,   99,
+       73,   98,  100,  892,  893,  100,  100,   99,  101,  899,
+      900,  101,  101,  102,  100,  105,  102,  102,  105,  105,
+      101,  212,  212,  212,  902,  102,  106,  105,  107,  106,
+      106,  107,  107,  108,  903,  904,  108,  108,  106,  108,
+
+      107,  110,  218,  218,  218,  108,  905,  124,  329,  329,
+      110,  110,  110,  110,  124,  128,  124,  124,  124,  129,
+      329,  907,  128,  130,  128,  128,  128,  329,  129,  129,
+      129,  908,  130,  130,  130,  130,  107,  135,  910,  136,
+      135,  135,  136,  136,  151,  226,  226,  226,  911,  135,
+      152,  136,  912,  151,  151,  151,  154,  152,  508,  152,
+      152,  152,  156,  154,  913,  154,  154,  154,  157,  508,
+      508,  156,  156,  156,  156,  171,  171,  157,  157,  157,
+      918,  162,  922,  136,  162,  162,  163,  924,  925,  163,
+      163,  926,  171,  162,  927,  929,  135,  166,  163,  166,
+
+      166,  166,  171,  171,  180,  933,  194,  183,  194,  194,
+      194,  180,  184,  180,  180,  180,  183,  183,  183,  184,
+      934,  184,  184,  184,  192,  939,  651,  192,  192,  196,
+      940,  196,  196,  196,  199,  915,  192,  651,  651,  199,
+      163,  199,  213,  941,  199,  915,  915,  214,  199,  942,
+      216,  213,  213,  213,  214,  943,  214,  214,  214,  216,
+      216,  216,  221,  946,  221,  221,  221,  224,  947,  948,
+      224,  224,  227,  950,  227,  227,  227,  951,  952,  224,
+      228,  228,  228,  229,  192,  229,  229,  229,  230,  230,
+      230,  251,  251,  251,  252,  255,  954,  960,  252,  961,
+
+      962,  256,  964,  252,  252,  252,  966,  255,  970,  255,
+      256,  256,  256,  257,  257,  257,  257,  260,  260,  260,
+      261,  265,  261,  261,  261,  263,  263,  263,  972,  974,
+      265,  265,  265,  265,  975,  976,  267,  255,  267,  267,
+      267,  269,  271,  269,  269,  269,  978,  271,  271,  271,
+      291,  291,  291,  293,  298,  298,  298,  293,  299,  299,
+      299,  979,  293,  293,  293,  302,  980,  302,  302,  302,
+      304,  304,  304,  306,  306,  306,  308,  308,  308,  309,
+      981,  309,  309,  309,  310,  310,  310,  311,  313,  311,
+      311,  311,  982,  313,  313,  313,  333,  333,  333,  335,
+
+      335,  335,  339,  339,  339,  342,  342,  342,  343,  983,
+      343,  343,  343,  344,  344,  344,  347,  347,  347,  347,
+      349,  351,  349,  349,  349,  374,  351,  351,  351,  373,
+      373,  373,  984,  990,  374,  374,  374,  377,  377,  377,
+      380,  993,  380,  380,  380,  382,  382,  382,  385,  385,
+      385,  386,  386,  386,  386,  387,  387,  387,  388,  389,
+      388,  388,  388,  994,  389,  389,  389,  413,  413,  413,
+      417,  417,  417,  418,  418,  418,  420,  420,  420,  421,
+      478,  421,  421,  421,  422,  422,  422,  426,  426,  426,
+      428,  458,  458,  458,  460,  995,  428,  428,  428,  466,
+
+      466,  466,  460,  460,  460,  460,  467,  467,  467,  468,
+      996,  478,  495,  495,  495,  468,  468,  468,  499,  499,
+      499,  500,  504,  504,  504,  997, 1001,  478,  505,  500,
+      500,  500,  500,  505,  505,  505, 1006,  478,  534,  534,
+      534,  538,  538,  538,  543,  543,  543,  545,  562,  562,
+      562, 1007,  545,  545,  545,  564,  564,  564,  581,  581,
+      581,  585,  597,  597,  597, 1008,  585,  585,  585,  602,
+     1010,  602,  602,  602,  604, 1011,  604,  604,  604,  614,
+      614,  614,  616,  616,  616,  620,  620,  620,  623,  623,
+      623,  625,  639,  639,  639, 1012,  625,  625,  625,  634,
+
+     1013,  634,  634,  634,  640, 1014,  640,  640,  640,  642,
+      642,  642,  643,  643,  643,  644, 1015,  644,  644,  644,
+      646,  646,  646,  654,  654,  654,  655, 1017,  655,  655,
+      655,  657, 1019,  657,  657,  657,  662,  662,  662,  665,
+      665,  665,  674,  674,  674,  675, 1024,  675,  675,  675,
+      680, 1025,  680,  680,  680,  682,  682,  682,  683, 1026,
+      683,  683,  683,  685,  685,  685,  694, 1027,  694,  694,
+      694,  696,  696,  696,  697, 1028,  697,  697,  697,  698,
+      698,  698,  700,  700,  700,  701, 1030,  701,  701,  701,
+      702,  702,  702,  715,  715,  715,  719, 1036,  719,  719,
+
+      719,  725,  725,  725,  726, 1037,  726,  726,  726,  727,
+      727,  727,  728,  728,  728,  729, 1039,  729,  729,  729,
+      730,  730,  730,  739,  739,  739,  740, 1040,  740,  740,
+      740,  741,  741,  741,  743,  745,  743,  743,  743, 1041,
+      745,  745,  745,  746,  748,  746,  746,  746, 1042,  748,
+      748,  748,  753,  753,  753,  756, 1043,  756,  756,  756,
+      760,  760,  760,  761, 1044,  761,  761,  761,  766, 1050,
+      766,  766,  766,  768,  768,  768,  769, 1054,  769,  769,
+      769,  771,  771,  771,  779,  781,  779,  779,  779, 1055,
+      781,  781,  781,  782,  782,  782,  783,  785,  783,  783,
+
+      783, 1056,  785,  785,  785,  786,  786,  786,  787,  789,
+      787,  787,  787,  793,  789,  789,  789,  793,  793,  793,
+      796,  796,  796,  797, 1057,  797,  797,  797,  801, 1064,
+      801,  801,  801,  807,  807,  807,  808, 1066,  808,  808,
+      808,  809,  809,  809,  810,  810,  810,  811, 1067,  811,
+      811,  811,  812,  812,  812,  819,  819,  819,  820,  822,
+      820,  820,  820, 1068,  822,  822,  822,  823,  825,  823,
+      823,  823, 1069,  825,  825,  825,  826,  828,  826,  826,
+      826,  832,  828,  828,  828,  832,  832,  832,  835, 1070,
+      835,  835,  835,  840,  840,  840,  841, 1071,  841,  841,
+
+      841,  843,  843,  843,  846,  846,  846,  846,  849,  849,
+      849,  849,  858,  858,  858,  859,  861,  859,  859,  859,
+     1073,  861,  861,  861,  862,  862,  862,  863,  864,  863,
+      863,  863, 1075,  864,  864,  864,  865,  865,  865,  866,
+      867,  866,  866,  866,  870,  867,  867,  867,  870,  870,
+      870,  873,  873,  873,  874, 1079,  874,  874,  874,  878,
+      878,  878,  881, 1080,  881,  881,  881,  884,  884,  884,
+      885,  885,  885,  886,  886,  886,  886,  887,  887,  887,
+      888,  888,  888,  888,  894, 1081,  894,  894,  894,  895,
+      895,  895,  896,  897,  896,  896,  896,  898,  897,  897,
+
+      897,  901, 1082,  898,  898,  898,  906,  901,  901,  901,
+      906,  906,  906,  909, 1084,  909,  909,  909,  914,  914,
+      914,  916,  916,  916,  917, 1086,  917,  917,  917,  919,
+      919,  919,  920, 1087,  920,  920,  920,  921,  921,  921,
+      923,  923,  923,  928,  928,  928,  930,  930,  930,  931,
+      932,  931,  931,  931, 1090, 1094,  932,  932,  932,  935,
+      935,  935,  936,  937,  937,  937,  938, 1095,  936,  936,
+      936, 1096,  938,  938,  938,  944,  944,  944,  945, 1097,
+      945,  945,  945,  953, 1103,  953,  953,  953,  955, 1106,
+      955,  955,  955,  956,  956,  956,  957, 1107,  957,  957,
+
+      957,  958,  958,  958,  959,  959,  959,  963,  965, 1109,
+      965,  965,  965,  967,  967,  967,  963,  963,  963,  968,
+      977,  977,  977,  969, 1110,  968,  968,  968,  969,  969,
+      969,  971,  985,  985,  985, 1112,  971,  971,  971,  986,
+     1114,  986,  986,  986,  987,  987,  987,  988, 1115,  988,
+      988,  988,  989, 1116,  989,  989,  989,  991,  991,  991,
+      992,  992,  992,  998,  998,  998,  999, 1000,  999,  999,
+      999, 1003, 1000, 1000, 1000, 1005, 1003, 1003, 1003, 1118,
+     1005, 1005, 1005, 1009, 1009, 1009, 1016, 1119, 1016, 1016,
+     1016, 1018, 1120, 1018, 1018, 1018, 1020, 1020, 1020, 1021,
+
+     1121, 1021, 1021, 1021, 1022, 1022, 1022, 1023, 1023, 1023,
+     1029, 1032, 1029, 1029, 1029, 1033, 1032, 1032, 1032, 1034,
+     1033, 1033, 1033, 1123, 1034, 1034, 1034, 1035, 1035, 1035,
+     1045, 1045, 1045, 1046, 1125, 1046, 1046, 1046, 1047, 1047,
+     1047, 1048, 1129, 1048, 1048, 1048, 1049, 1130, 1049, 1049,
+     1049, 1053, 1053, 1053, 1058, 1058, 1058, 1059, 1060, 1059,
+     1059, 1059, 1061, 1060, 1060, 1060, 1062, 1061, 1061, 1061,
+     1063, 1062, 1062, 1062, 1131, 1063, 1063, 1063, 1065, 1065,
+     1065, 1072, 1072, 1072, 1072, 1074, 1132, 1074, 1074, 1074,
+     1076, 1076, 1076, 1077, 1083, 1077, 1077, 1077, 1078, 1133,
+
+     1078, 1078, 1078, 1083, 1083, 1083, 1085, 1134, 1091, 1089,
+     1135, 1085, 1085, 1085, 1089, 1089, 1089, 1091, 1091, 1091,
+     1093, 1093, 1093, 1098, 1098, 1098, 1099, 1099, 1099, 1099,
+     1100, 1100, 1100, 1101, 1137, 1101, 1101, 1101, 1102, 1102,
+     1102, 1102, 1104, 1104, 1104, 1105, 1111, 1105, 1105, 1105,
+     1122, 1122, 1122, 1113, 1138, 1111, 1111, 1111, 1113, 1113,
+     1113, 1117, 1139, 1117, 1117, 1117, 1124, 1124, 1124, 1126,
+     1126, 1126, 1127, 1127, 1127, 1127, 1128, 1136, 1128, 1128,
+     1128, 1143, 1136, 1136, 1136, 1140, 1140, 1140, 1141, 1141,
+     1141, 1142, 1144, 1142, 1142, 1142, 1147, 1147, 1147, 1148,
+
+     1148, 1148, 1149, 1149, 1149, 1150, 1151, 1151, 1151, 1152,
+     1153, 1152, 1152, 1152, 1154, 1155, 1156, 1156, 1156, 1157,
+     1158, 1159, 1160, 1161, 1162, 1164, 1162, 1162, 1162, 1163,
+     1167, 1163, 1163, 1163, 1165, 1165, 1165, 1168, 1169, 1169,
+     1169, 1171, 1171, 1171, 1172, 1173, 1172, 1172, 1172, 1174,
+     1175, 1176, 1177, 1176, 1176, 1176, 1178, 1179, 1180, 1181,
+     1181, 1181, 1182, 1186, 1182, 1182, 1182, 1183, 1183, 1183,
+     1184, 1187, 1184, 1184, 1184, 1185, 1189, 1185, 1185, 1185,
+     1188, 1188, 1188, 1190, 1190, 1190, 1191, 1191, 1191, 1192,
+     1192, 1192, 1193, 1193, 1193, 1194, 1195, 1194, 1194, 1194,
+
+     1196, 1197, 1197, 1197, 1198, 1199, 1198, 1198, 1198, 1200,
+     1203, 1204, 1203, 1203, 1203, 1205, 1206, 1205, 1205, 1205,
+     1207, 1207, 1207, 1208, 1209, 1208, 1208, 1208, 1210, 1210,
+     1210, 1211, 1216, 1211, 1211, 1211, 1212, 1215, 1212, 1212,
+     1212, 1214, 1214, 1214, 1218, 1220, 1215, 1215, 1215, 1217,
+     1217, 1217, 1219, 1221, 1219, 1219, 1219, 1222, 1223, 1224,
+     1225, 1225, 1225, 1226, 1230, 1226, 1226, 1226, 1227, 1227,
+     1227, 1228, 1237, 1228, 1228, 1228, 1229, 1240, 1229, 1229,
+     1229, 1231, 1243, 1231, 1231, 1231, 1232, 1232, 1232, 1233,
+     1244, 1233, 1233, 1233, 1234, 1234, 1234, 1235, 1238, 1235,
+
+     1235, 1235, 1239, 1245, 1239, 1239, 1239, 1238, 1238, 1238,
+     1241, 1241, 1241, 1242, 1247, 1242, 1242, 1242, 1246, 1246,
+     1246, 1248, 1248, 1248, 1249, 1250, 1249, 1249, 1249, 1251,
+     1251, 1251, 1251, 1252, 1253, 1253, 1253, 1254, 1258, 1254,
+     1254, 1254, 1255, 1255, 1255, 1256, 1260, 1256, 1256, 1256,
+     1257, 1261, 1257, 1257, 1257, 1259, 1262, 1259, 1259, 1259,
+     1263, 1263, 1263, 1264, 1265, 1264, 1264, 1264, 1266, 1267,
+     1266, 1266, 1266, 1268, 1269, 1270, 1277, 1270, 1270, 1270,
+     1271, 1279, 1271, 1271, 1271, 1272, 1272, 1272, 1273, 1284,
+     1273, 1273, 1273, 1274, 1274, 1274, 1275, 1275, 1275, 1275,
+
+     1276, 1286, 1276, 1276, 1276, 1278, 1287, 1278, 1278, 1278,
+     1280, 1280, 1280, 1281, 1291, 1281, 1281, 1281, 1282, 1282,
+     1282, 1283, 1297, 1283, 1283, 1283, 1285, 1299, 1285, 1285,
+     1285, 1288, 1288, 1288, 1289, 1305, 1289, 1289, 1289, 1292,
+     1292, 1292, 1293, 1307, 1293, 1293, 1293, 1294, 1294, 1294,
+     1295, 1296, 1295, 1295, 1295, 1298, 1298, 1298, 1311, 1313,
+     1296, 1296, 1296, 1300, 1300, 1300, 1301, 1314, 1301, 1301,
+     1301, 1302, 1302, 1302, 1303, 1317, 1303, 1303, 1303, 1304,
+     1319, 1304, 1304, 1304, 1306, 1320, 1306, 1306, 1306, 1309,
+     1309, 1309, 1310, 1324, 1310, 1310, 1310, 1312, 1312, 1312,
+
+     1312, 1315, 1315, 1315, 1315, 1316, 1321, 1316, 1316, 1316,
+     1318, 1326, 1318, 1318, 1318, 1321, 1321, 1321, 1322, 1322,
+     1322, 1323, 1323, 1323, 1325, 1331, 1325, 1325, 1325, 1327,
+     1327, 1327, 1328, 1333, 1328, 1328, 1328, 1329, 1329, 1329,
+     1330, 1337, 1330, 1330, 1330, 1332, 1344, 1332, 1332, 1332,
+     1335, 1335, 1335, 1336, 1336, 1336, 1336, 1338, 1338, 1338,
+     1339, 1339, 1339, 1339, 1340, 1340, 1340, 1341, 1345, 1341,
+     1341, 1341, 1342, 1342, 1342, 1343, 1351, 1343, 1343, 1343,
+     1346, 1346, 1346, 1347, 1347, 1347, 1348, 1348, 1348, 1349,
+     1353, 1349, 1349, 1349, 1350, 1350, 1350, 1350, 1352, 1352,
+
+     1352, 1352, 1354, 1355, 1355, 1355, 1356, 1356, 1356, 1357,
+     1358, 1357, 1357, 1357, 1359, 1360, 1361, 1363, 1361, 1361,
+     1361, 1365, 1366, 1359, 1359, 1359, 1362, 1370, 1362, 1362,
+     1362, 1364, 1377, 1364, 1364, 1364, 1367, 1367, 1367, 1369,
+     1369, 1369, 1371, 1371, 1371, 1372, 1372, 1372, 1372, 1373,
+     1373, 1373, 1374, 1374, 1374, 1374, 1375, 1378, 1375, 1375,
+     1375, 1376, 1376, 1376, 1376, 1379, 1379, 1379, 1380, 1381,
+     1382, 1382, 1382, 1383, 1392, 1383, 1383, 1383, 1381, 1381,
+     1381, 1384, 1384, 1384, 1385, 1394, 1385, 1385, 1385, 1386,
+     1386, 1386, 1387, 1400, 1387, 1387, 1387, 1390, 1390, 1390,
+
+     1391, 1391, 1391, 1393, 1393, 1393, 1395, 1395, 1395, 1396,
+     1401, 1396, 1396, 1396, 1397, 1397, 1397, 1398, 1398, 1398,
+     1398, 1399, 1402, 1399, 1399, 1399, 1403, 1404, 1403, 1403,
+     1403, 1402, 1402, 1402, 1405, 1405, 1405, 1405, 1406, 1407,
+     1407, 1407, 1407, 1408, 1409, 1411, 1411, 1411, 1412, 1412,
+     1412, 1413, 1414, 1413, 1413, 1413, 1415, 1415, 1415, 1416,
+     1417, 1417, 1417, 1418, 1419, 1418, 1418, 1418, 1420, 1421,
+     1422, 1423, 1423, 1423, 1424, 1429, 1424, 1424, 1424, 1422,
+     1422, 1422, 1425, 1425, 1425, 1426, 1426, 1426, 1426, 1427,
+     1427, 1427, 1428, 1428, 1428, 1428, 1430, 1430, 1430, 1431,
+
+     1431, 1431, 1432, 1432, 1432, 1433, 1433, 1433, 1434, 1437,
+     1434, 1434, 1434, 1435, 1435, 1435, 1436, 1438, 1436, 1436,
+     1436, 1440, 1441, 1442, 1441, 1441, 1441, 1443, 1444, 1446,
+     1445, 1447, 1451, 1447, 1447, 1447, 1443, 1443, 1443, 1445,
+     1445, 1445, 1448, 1448, 1448, 1449, 1449, 1449, 1450, 1455,
+     1450, 1450, 1450, 1452, 1452, 1452, 1453, 1453, 1453, 1454,
+     1456, 1454, 1454, 1454, 1457, 1457, 1457, 1458, 1459, 1458,
+     1458, 1458, 1460, 1461, 1471, 1462, 1463, 1463, 1463, 1472,
+     1473, 1460, 1460, 1460, 1462, 1462, 1462, 1464, 1476, 1464,
+     1464, 1464, 1467, 1467, 1467, 1468, 1477, 1468, 1468, 1468,
+
+     1469, 1469, 1469, 1470, 1482, 1470, 1470, 1470, 1474, 1474,
+     1474, 1475, 1475, 1475, 1475, 1478, 1479, 1479, 1479, 1480,
+     1483, 1483, 1483, 1484, 1478, 1478, 1478, 1492, 1480, 1480,
+     1480, 1481, 1500, 1481, 1481, 1481, 1486, 1486, 1486, 1487,
+     1501, 1487, 1487, 1487, 1489, 1505, 1489, 1489, 1489, 1490,
+     1490, 1490, 1491, 1491, 1491, 1491, 1493, 1494, 1507, 1494,
+     1494, 1494, 1495, 1510, 1512, 1493, 1493, 1493, 1496, 1496,
+     1496, 1495, 1495, 1495, 1497, 1499, 1497, 1497, 1497, 1498,
+     1498, 1498, 1515, 1518, 1499, 1499, 1499, 1502, 1502, 1502,
+     1503, 1504, 1503, 1503, 1503, 1508, 1508, 1508, 1519, 1521,
+
+     1504, 1504, 1504, 1509, 1514, 1509, 1509, 1509, 1511, 1523,
+     1511, 1511, 1511, 1514, 1514, 1514, 1516, 1516, 1516, 1517,
+     1520, 1517, 1517, 1517, 1522, 1526, 1522, 1522, 1522, 1520,
+     1520, 1520, 1524, 1524, 1524, 1525, 1528, 1525, 1525, 1525,
+     1527, 1531, 1527, 1527, 1527, 1529, 1529, 1529, 1530, 1532,
+     1530, 1530, 1530, 1533, 1534, 1534, 1534, 1538, 1532, 1532,
+     1532, 1535, 1535, 1535, 1536, 1541, 1536, 1536, 1536, 1537,
+     1537, 1537, 1539, 1539, 1539, 1540, 1542, 1540, 1540, 1540,
+     1543, 1544, 1543, 1543, 1543, 1545, 1546, 1547, 1549, 1547,
+     1547, 1547, 1550, 1550, 1550, 1546, 1546, 1546, 1548, 1552,
+
+     1548, 1548, 1548, 1551, 1553, 1551, 1551, 1551, 1554, 1554,
+     1554, 1555, 1557, 1555, 1555, 1555, 1558, 1558, 1558, 1559,
+     1565, 1559, 1559, 1559, 1560, 1560, 1560, 1561, 1567, 1561,
+     1561, 1561, 1563, 1563, 1563, 1564, 1568, 1564, 1564, 1564,
+     1566, 1566, 1566, 1566, 1569, 1570, 1569, 1569, 1569, 1571,
+     1571, 1571, 1571, 1572, 1573, 1574, 1573, 1573, 1573, 1575,
+     1576, 1576, 1576, 1577, 1577, 1577, 1577, 1578, 1579, 1579,
+     1579, 1580, 1580, 1580, 1581, 1586, 1581, 1581, 1581, 1582,
+     1582, 1582, 1583, 1583, 1583, 1583, 1584, 1584, 1584, 1585,
+     1587, 1585, 1585, 1585, 1588, 1591, 1593, 1595, 1596, 1587,
+
+     1587, 1587, 1589, 1597, 1589, 1589, 1589, 1590, 1592, 1590,
+     1590, 1590, 1594, 1592, 1592, 1592, 1598, 1599, 1599, 1599,
+     1603, 1594, 1594, 1594, 1607, 1598, 1598, 1598, 1600, 1610,
+     1600, 1600, 1600, 1601, 1601, 1601, 1602, 1604, 1602, 1602,
+     1602, 1605, 1604, 1604, 1604, 1606, 1606, 1606, 1608, 1612,
+     1605, 1605, 1605, 1611, 1611, 1611, 1611, 1608, 1608, 1608,
+     1609, 1613, 1609, 1609, 1609, 1614, 1615, 1617, 1618, 1616,
+     1614, 1614, 1614, 1616, 1616, 1616, 1623, 1618, 1618, 1618,
+     1619, 1619, 1619, 1620, 1625, 1620, 1620, 1620, 1621, 1621,
+     1621, 1622, 1622, 1622, 1622, 1624, 1627, 1628, 1630, 1626,
+
+     1624, 1624, 1624, 1626, 1626, 1626, 1629, 1632, 1629, 1629,
+     1629, 1631, 1631, 1631, 1633, 1634, 1635, 1636, 1637, 1642,
+     1644, 1636, 1636, 1636, 1638, 1638, 1638, 1639, 1646, 1639,
+     1639, 1639, 1640, 1640, 1640, 1643, 1647, 1647, 1647, 1643,
+     1643, 1643, 1645, 1645, 1645, 1645, 1648, 1649, 1650, 1651,
+     1652, 1652, 1652, 1653, 1653, 1653, 1653, 1654, 1654, 1654,
+     1655, 1656, 1656, 1656, 1657, 1658, 1659, 1660, 1662, 1663,
+     1662, 1662, 1662, 1664, 1665, 1659, 1659, 1659, 1666, 1667,
+     1667, 1667, 1668, 1671, 1668, 1668, 1668, 1666, 1666, 1666,
+     1669, 1669, 1669, 1670, 1670, 1670, 1670, 1672, 1673, 1674,
+
+     1673, 1673, 1673, 1676, 1675, 1677, 1672, 1672, 1672, 1675,
+     1675, 1675, 1676, 1676, 1676, 1676, 1678, 1679, 1679, 1679,
+     1680, 1683, 1680, 1680, 1680, 1678, 1678, 1678, 1682, 1684,
+     1685, 1687, 1689, 1682, 1682, 1682, 1686, 1688, 1686, 1686,
+     1686, 1690, 1688, 1688, 1688, 1691, 1691, 1691, 1692, 1693,
+     1692, 1692, 1692, 1694, 1693, 1693, 1693, 1695, 1696, 1696,
+     1696, 1696, 1697, 1698, 1699, 1700, 1701, 1701, 1701, 1702,
+     1702, 1702, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709,
+     1710, 1711, 1711, 1711, 1705, 1705, 1705, 1719, 1722, 1710,
+     1710, 1710, 1712, 1712, 1712, 1712, 1713, 1713, 1713, 1714,
+
+     1719, 1719, 1715, 1716, 1716, 1716, 1716, 1723, 1714, 1714,
+     1714, 1715, 1715, 1715, 1717, 1718, 1717, 1717, 1717, 1720,
+     1720, 1720, 1724, 1725, 1718, 1718, 1718, 1721, 1727, 1721,
+     1721, 1721, 1726, 1728, 1726, 1726, 1726, 1729, 1730, 1731,
+     1731, 1731, 1732, 1733, 1732, 1732, 1732, 1734, 1735, 1736,
+     1735, 1735, 1735, 1737, 1738, 1739, 1739, 1739, 1740, 1741,
+     1740, 1740, 1740, 1742, 1743, 1745, 1738, 1744, 1744, 1744,
+     1744, 1746, 1747, 1748, 1749, 1749, 1749, 1750, 1750, 1750,
+     1750, 1751, 1752, 1753, 1754, 1755, 1756, 1758, 1760, 1754,
+     1754, 1754, 1761, 1760, 1760, 1760, 1762, 1763, 1764, 1765,
+
+     1767, 1766, 1763, 1763, 1763, 1765, 1766, 1766, 1766, 1769,
+      813, 1769, 1769, 1769,  805, 1769, 1769, 1769, 1769, 1770,
+      804, 1770, 1770, 1770,  803, 1770, 1770, 1770, 1770, 1771,
+      802, 1771, 1772, 1772, 1773,  800,  799,  798,  795,  794,
+      792, 1773, 1773, 1773, 1774, 1774, 1774,  780, 1774, 1774,
+     1775,  777, 1775, 1775, 1775, 1775, 1776,  776, 1776, 1776,
+     1777,  775, 1777, 1777, 1778,  774, 1778,  773, 1778,  772,
+     1778, 1778, 1779, 1779, 1779,  770, 1779, 1779, 1780,  767,
+     1780, 1781, 1781, 1782, 1782, 1783, 1783, 1784, 1784, 1785,
+      765, 1785,  764, 1785, 1785, 1786,  763, 1786,  762, 1786,
+
+     1786, 1787, 1787, 1788,  759, 1788, 1788, 1788, 1788, 1789,
+      758, 1789, 1789, 1789, 1789, 1790, 1790, 1791, 1791, 1792,
+     1792, 1792,  757, 1792, 1792, 1792, 1792, 1793,  755, 1793,
+     1793, 1793, 1793, 1794,  754, 1794, 1794, 1795,  751, 1795,
+     1795, 1796, 1796, 1797, 1797, 1797,  750, 1797, 1797, 1798,
+     1798, 1798,  749, 1798, 1798, 1799, 1799, 1799,  747, 1799,
+     1799, 1800, 1800, 1800,  744, 1800, 1800, 1801, 1801, 1801,
+      742, 1801, 1801, 1802,  738, 1802, 1802, 1803,  737, 1803,
+     1803, 1804, 1804, 1805, 1805, 1806,  736, 1806, 1806, 1807,
+      735, 1807,  734, 1807,  733, 1807, 1807, 1808,  732, 1808,
+
+      731, 1808,  724, 1808, 1808, 1809,  723,  722, 1809,  721,
+     1809,  720, 1809, 1809, 1810,  718, 1810, 1810, 1810, 1810,
+     1811,  717, 1811,  716, 1811,  714, 1811, 1811, 1812, 1812,
+     1813,  713, 1813, 1813, 1813, 1813, 1813, 1813, 1813, 1813,
+     1813, 1813, 1814, 1814, 1815,  712, 1815, 1815, 1815, 1815,
+     1816, 1816, 1817,  710, 1817, 1817, 1817, 1817, 1818,  709,
+     1818, 1818, 1818, 1818, 1819, 1819, 1820, 1820, 1821,  707,
+     1821, 1821, 1821, 1821, 1822,  706, 1822, 1822, 1822, 1822,
+     1823, 1823, 1824, 1824, 1825, 1825, 1826,  705, 1826, 1826,
+     1826, 1826, 1827,  704, 1827, 1827, 1827, 1827, 1828,  703,
+
+     1828, 1828, 1828, 1828, 1829, 1829, 1830, 1830, 1831,  699,
+     1831, 1831, 1831, 1831, 1832,  695, 1832, 1832, 1832, 1832,
+     1833, 1833, 1834, 1834, 1835,  693, 1835, 1835, 1835, 1835,
+     1836,  692, 1836, 1836, 1836, 1836, 1837, 1837, 1838,  691,
+     1838, 1838, 1838, 1838, 1839,  690, 1839, 1839, 1840, 1840,
+     1841,  689,  688,  687, 1841,  686, 1841,  684, 1841, 1841,
+     1842,  681, 1842, 1842, 1842, 1842, 1843, 1843, 1844,  679,
+     1844, 1844, 1844, 1844, 1845, 1845, 1846,  678, 1846, 1846,
+     1846, 1846, 1847, 1847, 1848,  677, 1848, 1848, 1849,  676,
+     1849, 1849, 1849, 1849, 1850,  673,  672,  671, 1850,  670,
+
+     1850,  669, 1850, 1850, 1851, 1851, 1852,  668, 1852, 1852,
+     1852, 1852, 1853, 1853, 1854,  667, 1854, 1854, 1854, 1854,
+      666,  664,  663,  661,  660,  659,  658,  656,  653,  652,
+      650,  649,  648,  647,  645,  641,  638,  637,  636,  635,
+      633,  632,  631,  629,  628,  627,  624,  622,  619,  618,
+      617,  615,  613,  612,  611,  610,  609,  608,  607,  606,
+      605,  603,  601,  600,  599,  598,  596,  595,  594,  593,
+      592,  591,  590,  589,  588,  587,  586,  583,  580,  579,
+      577,  576,  575,  574,  573,  572,  570,  569,  568,  567,
+      566,  565,  563,  561,  560,  559,  558,  557,  556,  555,
+
+      554,  553,  552,  551,  550,  549,  548,  547,  546,  541,
+      540,  537,  536,  533,  532,  531,  528,  526,  525,  524,
+      523,  522,  521,  520,  519,  518,  517,  516,  515,  513,
+      512,  511,  510,  507,  506,  502,  501,  498,  497,  496,
+      494,  493,  492,  490,  489,  488,  486,  485,  484,  483,
+      482,  481,  477,  476,  475,  474,  473,  472,  471,  470,
+      469,  464,  463,  461,  459,  457,  456,  455,  454,  453,
+      452,  451,  450,  448,  447,  446,  445,  444,  443,  442,
+      441,  440,  439,  438,  437,  436,  435,  434,  433,  432,
+      431,  430,  429,  427,  425,  424,  423,  419,  416,  415,
+
+      414,  412,  411,  410,  409,  408,  407,  406,  405,  404,
+      403,  402,  401,  400,  399,  398,  397,  396,  395,  394,
+      393,  392,  391,  390,  384,  381,  379,  378,  376,  375,
+      371,  370,  369,  368,  367,  366,  365,  364,  363,  362,
+      361,  360,  359,  358,  357,  356,  355,  354,  353,  352,
+      350,  348,  346,  345,  341,  338,  337,  336,  332,  330,
+      328,  327,  326,  325,  324,  323,  322,  321,  320,  319,
+      318,  317,  316,  315,  314,  307,  305,  303,  301,  300,
+      297,  296,  295,  294,  292,  290,  289,  288,  287,  286,
+      285,  284,  283,  282,  281,  280,  279,  278,  277,  276,
+
+      275,  274,  273,  272,  270,  268,  266,  264,  262,  259,
+      254,  250,  249,  248,  247,  246,  245,  244,  243,  242,
+      241,  240,  239,  238,  237,  236,  235,  234,  233,  232,
+      231,  225,  223,  222,  220,  219,  215,  211,  210,  209,
+      208,  207,  206,  205,  204,  203,  201,  200,  198,  197,
+      195,  193,  191,  189,  188,  187,  186,  182,  179,  178,
+      177,  176,  175,  174,  173,  172,  170,  169,  167,  164,
+      161,  160,  159,  158,  153,  150,  149,  148,  147,  146,
+      145,  144,  143,  142,  141,  140,  139,  137,  132,  131,
+      126,  123,  122,  121,  120,  119,  118,  117,  116,  115,
+
+      114,  113,  112,   93,   90,   89,   88,   87,   86,   85,
+       84,   83,   82,   81,   80,   79,   77,   76,   68,   46,
+       44,   43,   42,   41,   40,   39,   38,   37,   35,   34,
+       33,   31,   23,    9,    3, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+     1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768, 1768,
+
+     1768, 1768, 1768, 1768
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int cisco_pix_flex_debug;
+int cisco_pix_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *cisco_pixtext;
+#line 1 "cisco_pix.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: cisco_pix.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "cisco_pix.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <netdb.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void cisco_pix_parse_date(char *input, unsigned char mode);
+void cisco_pix_parse_src(char *input, unsigned char mode);
+void cisco_pix_parse_dst(char *input, unsigned char mode);
+void cisco_pix_parse_group(char *input);
+#line 2028 "cisco_pix.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int cisco_pixlex_destroy (void );
+
+int cisco_pixget_debug (void );
+
+void cisco_pixset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE cisco_pixget_extra (void );
+
+void cisco_pixset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *cisco_pixget_in (void );
+
+void cisco_pixset_in  (FILE * in_str  );
+
+FILE *cisco_pixget_out (void );
+
+void cisco_pixset_out  (FILE * out_str  );
+
+int cisco_pixget_leng (void );
+
+char *cisco_pixget_text (void );
+
+int cisco_pixget_lineno (void );
+
+void cisco_pixset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int cisco_pixwrap (void );
+#else
+extern int cisco_pixwrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( cisco_pixtext, cisco_pixleng, 1, cisco_pixout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( cisco_pixin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( cisco_pixin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, cisco_pixin))==0 && ferror(cisco_pixin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(cisco_pixin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int cisco_pixlex (void);
+
+#define YY_DECL int cisco_pixlex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after cisco_pixtext and cisco_pixleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 45 "cisco_pix.l"
+
+
+#line 2216 "cisco_pix.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! cisco_pixin )
+			cisco_pixin = stdin;
+
+		if ( ! cisco_pixout )
+			cisco_pixout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			cisco_pixensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				cisco_pix_create_buffer(cisco_pixin,YY_BUF_SIZE );
+		}
+
+		cisco_pix_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of cisco_pixtext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 1769 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 1768 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 47 "cisco_pix.l"
+cisco_pix_parse_date(cisco_pixtext, CP_OPT_HOST);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 48 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 49 "cisco_pix.l"
+cisco_pix_parse_date(cisco_pixtext, CP_OPT_NONE);
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 50 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 51 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+36, CP_OPT_TCP);
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 52 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+31, CP_OPT_TCP);
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 53 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+23, CP_OPT_UDP);
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 54 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+14, CP_OPT_UDP_S);
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 55 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+14, CP_OPT_UDP_N);
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 56 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+14, CP_OPT_TCP_S);
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 57 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+14, CP_OPT_TCP_N);
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 58 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+15, CP_OPT_ICMP_S);
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 59 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+23, CP_OPT_ICMP_S);
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 60 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+22, CP_OPT_TCP_S);
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 61 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+33, CP_OPT_TCP_S);
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 62 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+33, CP_OPT_UDP_S);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 63 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+34, CP_OPT_ICMP_S);
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 64 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+34, CP_OPT_UDP_NOPORT);
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 65 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext, CP_OPT_ICMP);
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 66 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+3, CP_OPT_DST);
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 67 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+3, CP_OPT_NONE);
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 68 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+4, CP_OPT_DST_S);
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 69 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+4, CP_OPT_DST_N);
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 70 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+4, CP_OPT_DST_I);
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 71 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext, CP_OPT_NONE);
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 72 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 73 "cisco_pix.l"
+opt.line->flags = opt.line->flags | TCP_URG;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 74 "cisco_pix.l"
+opt.line->flags = opt.line->flags | TCP_ACK;
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 75 "cisco_pix.l"
+opt.line->flags = opt.line->flags | TCP_PSH;
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 76 "cisco_pix.l"
+opt.line->flags = opt.line->flags | TCP_RST;
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 77 "cisco_pix.l"
+opt.line->flags = opt.line->flags | TCP_SYN;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 78 "cisco_pix.l"
+opt.line->flags = opt.line->flags | TCP_FIN;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 79 "cisco_pix.l"
+xstrncpy(opt.line->interface, cisco_pixtext+13, SHORTLEN);
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 80 "cisco_pix.l"
+cisco_pix_parse_group(cisco_pixtext+17);
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 81 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 82 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 83 "cisco_pix.l"
+xstrncpy(opt.line->chainlabel, cisco_pixtext+13, SHORTLEN);
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 84 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+15, CP_OPT_TCP_S2);
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 85 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+15, CP_OPT_UDP_S2);
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 86 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+16, CP_OPT_ICMP_S2);
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 87 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+15, CP_OPT_TCP_N2);
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 88 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+15, CP_OPT_UDP_N2);
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 89 "cisco_pix.l"
+cisco_pix_parse_src(cisco_pixtext+16, CP_OPT_ICMP_N2);
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 90 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+4, CP_OPT_DST_S2);
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 91 "cisco_pix.l"
+cisco_pix_parse_dst(cisco_pixtext+4, CP_OPT_DST_N2);
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 92 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 93 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 94 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 95 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 96 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 97 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 98 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 99 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 100 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 101 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 102 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 103 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 104 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 105 "cisco_pix.l"
+opt.parser=opt.parser|CISCO_PIX_NO_HIT;
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 106 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 107 "cisco_pix.l"
+/* ignore whitespace */
+	YY_BREAK
+case 62:
+/* rule 62 can match eol */
+YY_RULE_SETUP
+#line 108 "cisco_pix.l"
+/* ignore */
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 109 "cisco_pix.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", cisco_pixtext);
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 110 "cisco_pix.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", cisco_pixtext);
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 112 "cisco_pix.l"
+ECHO;
+	YY_BREAK
+#line 2621 "cisco_pix.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed cisco_pixin at a new source and called
+			 * cisco_pixlex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = cisco_pixin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( cisco_pixwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * cisco_pixtext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of cisco_pixlex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					cisco_pixrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			cisco_pixrestart(cisco_pixin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cisco_pixrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 1769 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 1769 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 1768);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					cisco_pixrestart(cisco_pixin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( cisco_pixwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve cisco_pixtext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void cisco_pixrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        cisco_pixensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            cisco_pix_create_buffer(cisco_pixin,YY_BUF_SIZE );
+	}
+
+	cisco_pix_init_buffer(YY_CURRENT_BUFFER,input_file );
+	cisco_pix_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void cisco_pix_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		cisco_pixpop_buffer_state();
+	 *		cisco_pixpush_buffer_state(new_buffer);
+     */
+	cisco_pixensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	cisco_pix_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (cisco_pixwrap()) processing, but the only time this flag
+	 * is looked at is after cisco_pixwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void cisco_pix_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	cisco_pixin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE cisco_pix_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) cisco_pixalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_pix_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) cisco_pixalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_pix_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	cisco_pix_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with cisco_pix_create_buffer()
+ * 
+ */
+    void cisco_pix_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		cisco_pixfree((void *) b->yy_ch_buf  );
+
+	cisco_pixfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a cisco_pixrestart() or at EOF.
+ */
+    static void cisco_pix_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	cisco_pix_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then cisco_pix_init_buffer was _probably_
+     * called from cisco_pixrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void cisco_pix_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		cisco_pix_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void cisco_pixpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	cisco_pixensure_buffer_stack();
+
+	/* This block is copied from cisco_pix_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from cisco_pix_switch_to_buffer. */
+	cisco_pix_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void cisco_pixpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	cisco_pix_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		cisco_pix_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void cisco_pixensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cisco_pixalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in cisco_pixensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cisco_pixrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in cisco_pixensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE cisco_pix_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) cisco_pixalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_pix_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	cisco_pix_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to cisco_pixlex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       cisco_pix_scan_bytes() instead.
+ */
+YY_BUFFER_STATE cisco_pix_scan_string (yyconst char * yystr )
+{
+    
+	return cisco_pix_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to cisco_pixlex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE cisco_pix_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) cisco_pixalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in cisco_pix_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = cisco_pix_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in cisco_pix_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up cisco_pixtext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		cisco_pixtext[cisco_pixleng] = (yy_hold_char); \
+		(yy_c_buf_p) = cisco_pixtext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		cisco_pixleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int cisco_pixget_lineno  (void)
+{
+        
+    return cisco_pixlineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *cisco_pixget_in  (void)
+{
+        return cisco_pixin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *cisco_pixget_out  (void)
+{
+        return cisco_pixout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int cisco_pixget_leng  (void)
+{
+        return cisco_pixleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *cisco_pixget_text  (void)
+{
+        return cisco_pixtext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void cisco_pixset_lineno (int  line_number )
+{
+    
+    cisco_pixlineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see cisco_pix_switch_to_buffer
+ */
+void cisco_pixset_in (FILE *  in_str )
+{
+        cisco_pixin = in_str ;
+}
+
+void cisco_pixset_out (FILE *  out_str )
+{
+        cisco_pixout = out_str ;
+}
+
+int cisco_pixget_debug  (void)
+{
+        return cisco_pix_flex_debug;
+}
+
+void cisco_pixset_debug (int  bdebug )
+{
+        cisco_pix_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from cisco_pixlex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    cisco_pixin = stdin;
+    cisco_pixout = stdout;
+#else
+    cisco_pixin = (FILE *) 0;
+    cisco_pixout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * cisco_pixlex_init()
+     */
+    return 0;
+}
+
+/* cisco_pixlex_destroy is for both reentrant and non-reentrant scanners. */
+int cisco_pixlex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		cisco_pix_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		cisco_pixpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	cisco_pixfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * cisco_pixlex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *cisco_pixalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *cisco_pixrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void cisco_pixfree (void * ptr )
+{
+	free( (char *) ptr );	/* see cisco_pixrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 112 "cisco_pix.l"
+
+
+
+void cisco_pix_parse_date(char *input, unsigned char mode)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+#ifdef IRIX
+  char tmp[SHOSTLEN];
+#endif
+#ifdef LOGDOTS
+  char *remove_dot;
+#endif
+
+  if (mode == CP_OPT_HOST) {
+    retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second,
+#ifndef IRIX
+		    opt.line->hostname);
+#else
+		    tmp);
+    if (retval != 6)
+      return;
+    if (tmp[2] == ':')
+      xstrncpy(opt.line->hostname, tmp + 3, SHOSTLEN);
+#endif
+#ifdef LOGDOTS
+    remove_dot = strstr(opt.line->hostname, ".");
+    if (remove_dot != NULL)
+      *remove_dot = '\0';
+#endif
+  } else if (mode == CP_OPT_NONE) {
+    int year;
+    retval = sscanf(input, "%3s %2d %4d %2d:%2d:%2d", smonth, &day, &year, &hour, &minute, &second);
+    if (retval != 6)
+      return;
+  }
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | CISCO_PIX_DATE;
+}
+
+void cisco_pix_parse_src(char *input, unsigned char mode)
+{
+  char ip[IPLEN], resolved = 0;
+  int shost1, shost2, shost3, shost4;
+  int retval;
+
+  if ((mode == CP_OPT_TCP) || (mode == CP_OPT_UDP)) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d/%5d", &shost1, &shost2, &shost3, &shost4, &opt.line->sport);
+    if (mode == CP_OPT_TCP)
+      opt.line->protocol = 6;
+    else
+      opt.line->protocol = 17;
+    if (retval != 5)
+      return;
+  } else if ((mode == CP_OPT_TCP_S) || (mode == CP_OPT_UDP_S)) {
+    char buf[BUFSIZE], *pnt;
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    retval = sscanf(input, "%" BUFSIZE_S "s %3d.%3d.%3d.%3d/%5d", buf, &shost1, &shost2, &shost3, &shost4, &opt.line->sport);
+    if (mode == CP_OPT_TCP_S)
+      opt.line->protocol = 6;
+    else
+      opt.line->protocol = 17;
+    if (retval != 6)
+      return;
+  } else if ((mode == CP_OPT_TCP_S2) || (mode == CP_OPT_UDP_S2) || (mode == CP_OPT_ICMP_S2)) {
+    char buf[BUFSIZE], *pnt;
+    xstrncpy(opt.line->branchname, "permitted", SHORTLEN);
+    pnt = strstr(input, "/");
+    *pnt = ' ';
+    retval = sscanf(input, "%" BUFSIZE_S "s %3d.%3d.%3d.%3d(%5d)", buf, &shost1, &shost2, &shost3, &shost4, &opt.line->sport);
+    if (mode == CP_OPT_TCP_S2)
+      opt.line->protocol = 6;
+    else if (mode == CP_OPT_UDP_S2)
+      opt.line->protocol = 17;
+    else
+      opt.line->protocol = 1;
+    if (retval != 6)
+      return;
+  } else if ((mode == CP_OPT_TCP_N) || (mode == CP_OPT_UDP_N)) {
+    char buf[BUFSIZE], *pnt;
+    struct hostent *he;
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    pnt = strstr(input, "/");
+    *pnt = ' ';
+    retval = sscanf(input, "%*s %" BUFSIZE_S "s %5d", buf, &opt.line->sport);
+    if (mode == CP_OPT_TCP_N)
+      opt.line->protocol = 6;
+    else
+      opt.line->protocol = 17;
+    if (retval != 2)
+      return;
+    he = gethostbyname(buf);
+    if (he != NULL) {
+      opt.line->shost.s_addr = ((struct in_addr *) he->h_addr_list[0])->s_addr;
+      resolved = 1;
+    } else {
+      if (opt.verbose)
+	fprintf(stderr, "cisco_pix host '%s' could not be resolved, ignoring.\n", buf);
+      return;
+    }
+  } else if ((mode == CP_OPT_TCP_N2) || (mode == CP_OPT_UDP_N2) || (mode == CP_OPT_ICMP_N2)) {
+    char buf[BUFSIZE], *pnt;
+    struct hostent *he;
+    xstrncpy(opt.line->branchname, "permitted", SHORTLEN);
+    pnt = strstr(input, "/");
+    *pnt = ' ';
+    pnt = strstr(input, "(");
+    *pnt = ' ';
+    pnt = strstr(input, ")");
+    *pnt = 0;
+    retval = sscanf(input, "%*s %" BUFSIZE_S "s %5d", buf, &opt.line->sport);
+    if (mode == CP_OPT_TCP_N2)
+      opt.line->protocol = 6;
+    else if (mode == CP_OPT_UDP_N2)
+      opt.line->protocol = 17;
+    else
+      opt.line->protocol = 1;
+    if (retval != 2)
+      return;
+    he = gethostbyname(buf);
+    if (he != NULL) {
+      opt.line->shost.s_addr = ((struct in_addr *) he->h_addr_list[0])->s_addr;
+      resolved = 1;
+    } else {
+      if (opt.verbose)
+	fprintf(stderr, "cisco_pix host '%s' could not be resolved, ignoring.\n", buf);
+      return;
+    }
+  } else if (mode == CP_OPT_ICMP_S) {
+    char buf[BUFSIZE], *pnt;
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    retval = sscanf(input, "%" BUFSIZE_S "s %3d.%3d.%3d.%3d", buf, &shost1, &shost2, &shost3, &shost4);
+    opt.line->protocol = 1;
+    if (retval != 5)
+      return;
+  } else if (mode == CP_OPT_ICMP) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d attempted to ping", &shost1, &shost2, &shost3, &shost4);
+    opt.line->protocol = 1;
+    if (retval != 4)
+      return;
+  } else if (mode == CP_OPT_UDP_NOPORT) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d", &shost1, &shost2, &shost3, &shost4);
+    opt.line->protocol = 17;
+    if (retval != 4)
+      return;
+  }
+
+  if (resolved == 0) {
+    snprintf(ip, IPLEN, "%d.%d.%d.%d", shost1, shost2, shost3, shost4);
+    if (convert_ip(ip, &opt.line->shost) == IN_ADDR_ERROR)
+      return;
+  }
+
+  opt.parser = opt.parser | CISCO_PIX_SRC;
+}
+
+void cisco_pix_parse_dst(char *input, unsigned char mode)
+{
+  char ip[IPLEN], resolved = 0;
+  int dhost1, dhost2, dhost3, dhost4;
+  int retval;
+
+  if (mode == CP_OPT_DST) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d/%5d", &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->dport);
+    if (retval != 5)
+      return;
+  } else if (mode == CP_OPT_DST_S) {
+    char buf[BUFSIZE], *pnt;
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    retval = sscanf(input, "%" BUFSIZE_S "s %3d.%3d.%3d.%3d/%5d", buf, &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->dport);
+    if (retval != 6)
+      return;
+  } else if (mode == CP_OPT_DST_S2) {
+    char buf[BUFSIZE], *pnt;
+    pnt = strstr(input, "/");
+    *pnt = ' ';
+    retval = sscanf(input, "%" BUFSIZE_S "s %3d.%3d.%3d.%3d(%5d)", buf, &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->dport);
+    if (retval != 6)
+      return;
+  } else if (mode == CP_OPT_DST_N) {
+    char buf[BUFSIZE], *pnt;
+    struct hostent *he;
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    pnt = strstr(input, "/");
+    *pnt = ' ';
+    retval = sscanf(input, "%*s %" BUFSIZE_S "s %5d", buf, &opt.line->dport);
+    if (retval != 2)
+      return;
+    he = gethostbyname(buf);
+    if (he != NULL) {
+      opt.line->dhost.s_addr = ((struct in_addr *) he->h_addr_list[0])->s_addr;
+      resolved = 1;
+    } else {
+      if (opt.verbose)
+	fprintf(stderr, "cisco_pix host '%s' could not be resolved, ignoring.\n", buf);
+      return;
+    }
+  } else if (mode == CP_OPT_DST_N2) {
+    char buf[BUFSIZE], *pnt;
+    struct hostent *he;
+    pnt = strstr(input, "/");
+    *pnt = ' ';
+    pnt = strstr(input, "(");
+    *pnt = ' ';
+    pnt = strstr(input, ")");
+    *pnt = 0;
+    retval = sscanf(input, "%*s %" BUFSIZE_S "s %5d", buf, &opt.line->dport);
+    if (retval != 2)
+      return;
+    he = gethostbyname(buf);
+    if (he != NULL) {
+      opt.line->dhost.s_addr = ((struct in_addr *) he->h_addr_list[0])->s_addr;
+      resolved = 1;
+    } else {
+      if (opt.verbose)
+	fprintf(stderr, "cisco_pix host '%s' could not be resolved, ignoring.\n", buf);
+      return;
+    }
+  } else if (mode == CP_OPT_DST_I) {
+    char buf[BUFSIZE], *pnt;
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    retval = sscanf(input, "%" BUFSIZE_S "s %3d.%3d.%3d.%3d (type %5d, code %5d)", buf, &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->sport, &opt.line->dport);
+    if (retval != 7)
+      return;
+  } else if (mode == CP_OPT_NONE) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d", &dhost1, &dhost2, &dhost3, &dhost4);
+    if (retval != 4)
+      return;
+  }
+
+  if (resolved == 0) {
+    snprintf(ip, IPLEN, "%d.%d.%d.%d", dhost1, dhost2, dhost3, dhost4);
+    if (convert_ip(ip, &opt.line->dhost) == IN_ADDR_ERROR)
+      return;
+  }
+
+  opt.parser = opt.parser | CISCO_PIX_DST;
+}
+
+void cisco_pix_parse_group(char *input)
+{
+  char *pnt;
+
+  pnt = strstr(input, "\"");
+  *pnt = '\0';
+  xstrncpy(opt.line->chainlabel, input, SHORTLEN);
+}
+
+unsigned char flex_cisco_pix(char *input, int linenum)
+{
+  opt.parser = 0;
+
+  init_line();
+
+  xstrncpy(opt.line->interface, "-", SHORTLEN);
+  xstrncpy(opt.line->chainlabel, "-", SHORTLEN);
+  xstrncpy(opt.line->branchname, "Deny", SHORTLEN);
+  opt.line->count = 1;
+
+  cisco_pix_scan_string(input);
+  cisco_pixlex();
+  cisco_pix_delete_buffer(YY_CURRENT_BUFFER);
+
+  if (opt.parser & CISCO_PIX_NO_HIT)
+    return PARSE_NO_HIT;
+
+  if (opt.parser == (CISCO_PIX_DATE | CISCO_PIX_SRC | CISCO_PIX_DST)) {
+    return PARSE_OK;
+  } else {
+    if (opt.verbose)
+      fprintf(stderr, "cisco_pix parse error in line %d, ignoring.\n", linenum);
+    if (opt.verbose == 2)
+      fprintf(stderr, "input was: \"%s\"\n", input);
+    return PARSE_WRONG_FORMAT;
+  }
+}
+
diff -Naur fwlogwatch-1.2.orig/ipchains.c fwlogwatch-1.2/ipchains.c
--- fwlogwatch-1.2.orig/ipchains.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/ipchains.c	2011-09-08 11:35:48.831421681 +0200
@@ -0,0 +1,2044 @@
+#line 2 "ipchains.c"
+
+#line 4 "ipchains.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer ipchains_create_buffer
+#define yy_delete_buffer ipchains_delete_buffer
+#define yy_flex_debug ipchains_flex_debug
+#define yy_init_buffer ipchains_init_buffer
+#define yy_flush_buffer ipchains_flush_buffer
+#define yy_load_buffer_state ipchains_load_buffer_state
+#define yy_switch_to_buffer ipchains_switch_to_buffer
+#define yyin ipchainsin
+#define yyleng ipchainsleng
+#define yylex ipchainslex
+#define yylineno ipchainslineno
+#define yyout ipchainsout
+#define yyrestart ipchainsrestart
+#define yytext ipchainstext
+#define yywrap ipchainswrap
+#define yyalloc ipchainsalloc
+#define yyrealloc ipchainsrealloc
+#define yyfree ipchainsfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ipchainsrestart(ipchainsin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ipchainsleng;
+
+extern FILE *ipchainsin, *ipchainsout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ipchainstext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ipchainstext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ipchainsrestart()), so that the user can continue scanning by
+	 * just pointing ipchainsin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when ipchainstext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int ipchainsleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow ipchainswrap()'s to do buffer switches
+ * instead of setting up a fresh ipchainsin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void ipchainsrestart (FILE *input_file  );
+void ipchains_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ipchains_create_buffer (FILE *file,int size  );
+void ipchains_delete_buffer (YY_BUFFER_STATE b  );
+void ipchains_flush_buffer (YY_BUFFER_STATE b  );
+void ipchainspush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ipchainspop_buffer_state (void );
+
+static void ipchainsensure_buffer_stack (void );
+static void ipchains_load_buffer_state (void );
+static void ipchains_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ipchains_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ipchains_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ipchains_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ipchains_scan_bytes (yyconst char *bytes,int len  );
+
+void *ipchainsalloc (yy_size_t  );
+void *ipchainsrealloc (void *,yy_size_t  );
+void ipchainsfree (void *  );
+
+#define yy_new_buffer ipchains_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ipchainsensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ipchains_create_buffer(ipchainsin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ipchainsensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ipchains_create_buffer(ipchainsin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define ipchainswrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *ipchainsin = (FILE *) 0, *ipchainsout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int ipchainslineno;
+
+int ipchainslineno = 1;
+
+extern char *ipchainstext;
+#define yytext_ptr ipchainstext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up ipchainstext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	ipchainsleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 18
+#define YY_END_OF_BUFFER 19
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[170] =
+    {   0,
+        0,    0,   19,   17,   15,   14,   17,   16,   17,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
+       14,    0,    0,    0,   16,    0,    0,   16,   16,   16,
+        0,   16,    0,   16,   16,    0,   16,   16,    0,   16,
+        0,   16,   16,    0,    0,    0,    0,    0,    0,    0,
+       16,    0,    8,    6,    0,    0,   12,   10,    0,   13,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    9,   11,    7,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    3,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    1,    0,    0,    0,    0,    1,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    5,    0,
+        0,    5,    2,    0,    5,    4,    5,    5,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    1,    4,    1,    1,    1,    1,    5,
+        6,    1,    1,    1,    7,    8,    1,    9,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   11,    1,    1,
+       12,    1,    1,    1,   13,   14,   15,   16,   17,   18,
+        7,    7,   19,   20,    7,   21,   22,   23,   24,   25,
+        7,   26,   27,   28,    7,    7,    7,    7,   29,    7,
+        1,    1,    1,    1,   30,    1,   31,   32,   33,   14,
+
+       34,   14,   35,    7,    7,    7,   36,   37,    7,   38,
+       39,   40,    7,   41,    7,   42,   43,   44,    7,   45,
+       46,    7,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[47] =
+    {   0,
+        1,    1,    2,    1,    3,    3,    4,    5,    6,    6,
+        3,    1,    7,    7,    7,    7,    7,    7,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    5,
+        7,    7,    7,    7,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4
+    } ;
+
+static yyconst flex_int16_t yy_base[181] =
+    {   0,
+        0,    0,  353,  354,  354,   44,  348,  348,   40,   48,
+       49,   50,   51,   54,   52,   55,   53,   56,   64,   57,
+      347,  315,   56,  322,  344,   61,   64,   58,   72,   75,
+      337,   74,   72,   76,   84,   85,   87,   93,  336,   97,
+      335,  100,   98,   95,  302,  103,  339,   99,  109,  333,
+      337,  294,  101,  115,  293,  292,  333,  117,  297,  354,
+        0,  331,  126,  121,  126,  137,    0,    0,    0,  299,
+      329,  129,  135,  323,  140,  148,    0,    0,    0,  293,
+      304,  325,  138,  143,  146,  150,  324,  315,  299,  158,
+      156,  316,  159,  320,  298,  159,  161,  167,  310,  295,
+
+      291,  170,  307,  175,  170,  286,  292,  312,  172,  180,
+      177,  281,  301,  182,  185,  193,  301,  275,  190,  198,
+      195,  201,  203,  205,  276,  207,    0,  210,  301,  305,
+      212,  265,  303,  214,  217,  302,  301,  278,  290,  220,
+      282,    0,  252,  257,  222,  225,    0,  235,  249,  227,
+      259,  229,  235,  230,  233,  246,  173,  177,  235,  117,
+      103,  237,  354,  239,  241,  243,  245,  354,  354,  254,
+      258,  264,  268,  270,  272,  274,  280,  284,  290,  295
+    } ;
+
+static yyconst flex_int16_t yy_def[181] =
+    {   0,
+      169,    1,  169,  169,  169,  169,  169,  170,  169,  170,
+      170,  170,  170,  170,  170,  170,  170,  170,  170,  170,
+      169,  169,  169,  171,  170,  169,  169,  170,  170,  170,
+      169,  170,  169,  170,  170,  169,  170,  170,  169,  170,
+      169,  170,  170,  169,  169,  169,  172,  172,  169,  169,
+      170,  169,  169,  169,  169,  169,  170,  169,  169,  169,
+      173,  172,  172,  169,  169,  171,  174,  175,  176,  169,
+      177,  172,  169,  169,  169,  169,  174,  175,  176,  169,
+      169,  177,  172,  169,  169,  169,  169,  169,  169,  172,
+      169,  169,  169,  169,  169,  172,  169,  169,  169,  169,
+
+      169,  172,  169,  169,  169,  169,  169,  172,  169,  169,
+      169,  169,  169,  173,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  178,  169,  169,  169,
+      169,  169,  179,  169,  169,  169,  169,  169,  179,  169,
+      169,  180,  169,  169,  169,  169,  180,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,    0,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169
+    } ;
+
+static yyconst flex_int16_t yy_nxt[401] =
+    {   0,
+        4,    5,    6,    4,    7,    4,    8,    4,    9,    9,
+        4,    4,   10,    8,    8,   11,    8,   12,   13,   14,
+       15,   16,   17,   18,    8,    8,   19,   20,    8,    4,
+        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,   21,   26,   27,   27,
+       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
+       24,   31,   33,   36,   46,   46,   24,   39,   44,   49,
+       49,   26,   50,   50,   24,   41,   24,   24,   24,   22,
+       53,   53,   30,   32,   34,   37,   24,   28,   40,   24,
+       29,   38,   42,   54,   54,   24,   35,   43,   51,   24,
+
+       24,   61,   24,   58,   58,   51,   51,   51,   60,   53,
+       53,   46,   46,   51,  164,   63,   64,   65,   65,  163,
+       51,   51,   57,   54,   54,   58,   58,   51,   61,   73,
+       73,   61,   51,   64,   74,   74,   51,   51,   51,   75,
+       61,   72,   84,   85,   85,   76,   76,   83,   76,   76,
+       86,   91,   91,   84,   92,   92,   87,   87,   93,   93,
+       61,   61,   48,   90,   97,   97,   98,   99,   99,  103,
+      103,   98,   61,  102,   96,  104,  104,  109,  111,  111,
+      115,  115,  109,  110,  110,  117,  117,  155,  116,  116,
+      120,  120,  121,  122,  122,  109,  161,  108,  126,  126,
+
+      127,  123,  123,  128,  128,  109,  120,  120,  121,  129,
+      129,  130,  130,  131,  131,  126,  126,  134,  135,  135,
+      136,  136,  140,  140,  134,  141,  141,  145,  146,  146,
+      150,  150,  145,  151,  151,  154,  154,  155,  158,  158,
+      155,  159,  159,  162,  162,  165,  165,  166,  166,  167,
+      167,  166,  166,  168,  168,   25,  160,   25,   25,   25,
+       25,   47,  157,  156,   47,   62,  145,   62,   62,   62,
+       62,   71,  153,  152,   71,   77,   77,   78,   78,   79,
+       79,   82,  149,   82,   82,   82,   82,  133,  148,  134,
+      133,  139,  138,  139,  139,  139,  139,  147,  147,  147,
+
+      147,  147,  144,  143,  142,  138,  137,  109,  121,  132,
+      125,  124,  119,  118,  114,  113,  112,   98,  107,  106,
+      105,  101,  100,   84,   95,   94,   86,   81,   89,   88,
+       64,   81,   80,   61,   70,   24,   69,   68,   67,   66,
+       26,   61,   59,   56,   55,   52,   24,   48,   45,   21,
+       24,   23,  169,    3,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169
+
+    } ;
+
+static yyconst flex_int16_t yy_chk[401] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    6,    9,    9,    9,
+       10,   11,   12,   13,   15,   17,   14,   16,   18,   20,
+       28,   12,   13,   15,   23,   23,   19,   18,   20,   26,
+       26,   27,   27,   27,   29,   19,   32,   30,   34,    6,
+       33,   33,   11,   12,   14,   16,   35,   10,   18,   37,
+       10,   17,   19,   36,   36,   38,   14,   19,   28,   40,
+
+       43,   48,   42,   44,   44,   32,   29,   30,   46,   53,
+       53,   46,   46,   34,  161,   48,   49,   49,   49,  160,
+       35,   35,   42,   54,   54,   58,   58,   37,   63,   64,
+       64,   72,   37,   65,   65,   65,   38,   43,   40,   66,
+       83,   63,   73,   73,   73,   66,   66,   72,   75,   75,
+       76,   84,   84,   85,   85,   85,   76,   76,   86,   86,
+       90,   96,   66,   83,   91,   91,   91,   93,   93,   97,
+       97,   97,  102,   96,   90,   98,   98,  104,  105,  105,
+      109,  109,  110,  104,  104,  111,  111,  158,  110,  110,
+      114,  114,  115,  115,  115,  116,  157,  102,  119,  119,
+
+      120,  116,  116,  121,  121,  123,  120,  120,  122,  122,
+      122,  123,  123,  124,  124,  126,  126,  128,  128,  128,
+      131,  131,  134,  134,  135,  135,  135,  140,  140,  140,
+      145,  145,  146,  146,  146,  150,  150,  150,  154,  154,
+      154,  155,  155,  159,  159,  162,  162,  164,  164,  165,
+      165,  166,  166,  167,  167,  170,  156,  170,  170,  170,
+      170,  171,  153,  152,  171,  172,  151,  172,  172,  172,
+      172,  173,  149,  148,  173,  174,  174,  175,  175,  176,
+      176,  177,  144,  177,  177,  177,  177,  178,  143,  141,
+      178,  179,  139,  179,  179,  179,  179,  180,  180,  180,
+
+      180,  180,  138,  137,  136,  133,  132,  130,  129,  125,
+      118,  117,  113,  112,  108,  107,  106,  103,  101,  100,
+       99,   95,   94,   92,   89,   88,   87,   82,   81,   80,
+       74,   71,   70,   62,   59,   57,   56,   55,   52,   51,
+       50,   47,   45,   41,   39,   31,   25,   24,   22,   21,
+        8,    7,    3,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
+      169,  169,  169,  169,  169,  169,  169,  169,  169,  169
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int ipchains_flex_debug;
+int ipchains_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *ipchainstext;
+#line 1 "ipchains.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: ipchains.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "ipchains.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void ipchains_parse_date(char *input);
+void ipchains_parse_data(char *input);
+void ipchains_parse_rdata(char *input);
+void ipchains_parse_ips(char *input);
+#line 641 "ipchains.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int ipchainslex_destroy (void );
+
+int ipchainsget_debug (void );
+
+void ipchainsset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE ipchainsget_extra (void );
+
+void ipchainsset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *ipchainsget_in (void );
+
+void ipchainsset_in  (FILE * in_str  );
+
+FILE *ipchainsget_out (void );
+
+void ipchainsset_out  (FILE * out_str  );
+
+int ipchainsget_leng (void );
+
+char *ipchainsget_text (void );
+
+int ipchainsget_lineno (void );
+
+void ipchainsset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int ipchainswrap (void );
+#else
+extern int ipchainswrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( ipchainstext, ipchainsleng, 1, ipchainsout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( ipchainsin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( ipchainsin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, ipchainsin))==0 && ferror(ipchainsin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(ipchainsin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int ipchainslex (void);
+
+#define YY_DECL int ipchainslex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after ipchainstext and ipchainsleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 36 "ipchains.l"
+
+
+#line 829 "ipchains.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! ipchainsin )
+			ipchainsin = stdin;
+
+		if ( ! ipchainsout )
+			ipchainsout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			ipchainsensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ipchains_create_buffer(ipchainsin,YY_BUF_SIZE );
+		}
+
+		ipchains_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of ipchainstext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 170 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 169 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 38 "ipchains.l"
+ipchains_parse_date(ipchainstext);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 39 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 40 "ipchains.l"
+ipchains_parse_data(ipchainstext);
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 41 "ipchains.l"
+ipchains_parse_rdata(ipchainstext);
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 42 "ipchains.l"
+ipchains_parse_ips(ipchainstext);
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 43 "ipchains.l"
+opt.line->datalen = atoi(ipchainstext+2);
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 44 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 45 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 46 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 47 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 48 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 49 "ipchains.l"
+opt.line->flags = TCP_SYN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 50 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 51 "ipchains.l"
+/* ignore whitespace */
+	YY_BREAK
+case 15:
+/* rule 15 can match eol */
+YY_RULE_SETUP
+#line 52 "ipchains.l"
+/* ignore */
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 53 "ipchains.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", ipchainstext);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 54 "ipchains.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", ipchainstext);
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 56 "ipchains.l"
+ECHO;
+	YY_BREAK
+#line 999 "ipchains.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ipchainsin at a new source and called
+			 * ipchainslex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ipchainsin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( ipchainswrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * ipchainstext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of ipchainslex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ipchainsrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ipchainsrestart(ipchainsin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ipchainsrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 170 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 170 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 169);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ipchainsrestart(ipchainsin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( ipchainswrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ipchainstext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ipchainsrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ipchainsensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ipchains_create_buffer(ipchainsin,YY_BUF_SIZE );
+	}
+
+	ipchains_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ipchains_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ipchains_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ipchainspop_buffer_state();
+	 *		ipchainspush_buffer_state(new_buffer);
+     */
+	ipchainsensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ipchains_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (ipchainswrap()) processing, but the only time this flag
+	 * is looked at is after ipchainswrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ipchains_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ipchainsin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ipchains_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) ipchainsalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ipchains_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) ipchainsalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ipchains_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ipchains_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ipchains_create_buffer()
+ * 
+ */
+    void ipchains_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		ipchainsfree((void *) b->yy_ch_buf  );
+
+	ipchainsfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ipchainsrestart() or at EOF.
+ */
+    static void ipchains_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ipchains_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ipchains_init_buffer was _probably_
+     * called from ipchainsrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ipchains_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ipchains_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ipchainspush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ipchainsensure_buffer_stack();
+
+	/* This block is copied from ipchains_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ipchains_switch_to_buffer. */
+	ipchains_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ipchainspop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ipchains_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ipchains_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ipchainsensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ipchainsalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ipchainsensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ipchainsrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ipchainsensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ipchains_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ipchainsalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ipchains_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ipchains_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to ipchainslex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ipchains_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ipchains_scan_string (yyconst char * yystr )
+{
+    
+	return ipchains_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to ipchainslex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ipchains_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) ipchainsalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ipchains_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ipchains_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ipchains_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ipchainstext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ipchainstext[ipchainsleng] = (yy_hold_char); \
+		(yy_c_buf_p) = ipchainstext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ipchainsleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int ipchainsget_lineno  (void)
+{
+        
+    return ipchainslineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *ipchainsget_in  (void)
+{
+        return ipchainsin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *ipchainsget_out  (void)
+{
+        return ipchainsout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int ipchainsget_leng  (void)
+{
+        return ipchainsleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *ipchainsget_text  (void)
+{
+        return ipchainstext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ipchainsset_lineno (int  line_number )
+{
+    
+    ipchainslineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ipchains_switch_to_buffer
+ */
+void ipchainsset_in (FILE *  in_str )
+{
+        ipchainsin = in_str ;
+}
+
+void ipchainsset_out (FILE *  out_str )
+{
+        ipchainsout = out_str ;
+}
+
+int ipchainsget_debug  (void)
+{
+        return ipchains_flex_debug;
+}
+
+void ipchainsset_debug (int  bdebug )
+{
+        ipchains_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ipchainslex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ipchainsin = stdin;
+    ipchainsout = stdout;
+#else
+    ipchainsin = (FILE *) 0;
+    ipchainsout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ipchainslex_init()
+     */
+    return 0;
+}
+
+/* ipchainslex_destroy is for both reentrant and non-reentrant scanners. */
+int ipchainslex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ipchains_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ipchainspop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ipchainsfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ipchainslex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *ipchainsalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *ipchainsrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void ipchainsfree (void * ptr )
+{
+	free( (char *) ptr );	/* see ipchainsrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 56 "ipchains.l"
+
+
+
+void ipchains_parse_date(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 6)
+    return;
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | IPCHAINS_DATE;
+}
+
+void ipchains_parse_data(char *input)
+{
+  int retval;
+
+  retval = sscanf(input, "%" SHORTLEN_S "s %" SHORTLEN_S "s %" SHORTLEN_S "s PROTO=%3d", opt.line->chainlabel, opt.line->branchname, opt.line->interface, &opt.line->protocol);
+  if (retval != 4)
+    return;
+
+  opt.parser = opt.parser | IPCHAINS_DATA;
+}
+
+void ipchains_parse_rdata(char *input)
+{
+  int retval, port;
+
+  retval = sscanf(input, "%" SHORTLEN_S "s REDIRECT %5d %" SHORTLEN_S "s PROTO=%3d", opt.line->chainlabel, &port, opt.line->interface, &opt.line->protocol);
+  if (retval != 4)
+    return;
+
+  snprintf(opt.line->branchname, SHORTLEN, "RD %d", port);
+
+  opt.parser = opt.parser | IPCHAINS_DATA;
+}
+
+void ipchains_parse_ips(char *input)
+{
+  int shost1, shost2, shost3, shost4;
+  int dhost1, dhost2, dhost3, dhost4;
+  int retval;
+  char ip[IPLEN];
+
+  retval = sscanf(input, "%3d.%3d.%3d.%3d:%5d %3d.%3d.%3d.%3d:%5d", &shost1, &shost2, &shost3, &shost4, &opt.line->sport, &dhost1, &dhost2, &dhost3, &dhost4, &opt.line->dport);
+  if (retval != 10)
+    return;
+
+  snprintf(ip, IPLEN, "%d.%d.%d.%d", shost1, shost2, shost3, shost4);
+  if (convert_ip(ip, &opt.line->shost) == IN_ADDR_ERROR)
+    return;
+
+  snprintf(ip, IPLEN, "%d.%d.%d.%d", dhost1, dhost2, dhost3, dhost4);
+  if (convert_ip(ip, &opt.line->dhost) == IN_ADDR_ERROR)
+    return;
+
+  opt.parser = opt.parser | IPCHAINS_IPS;
+}
+
+unsigned char flex_ipchains(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  ipchains_scan_string(input);
+  ipchainslex();
+  ipchains_delete_buffer(YY_CURRENT_BUFFER);
+
+  opt.line->count = 1;
+
+  if (opt.parser == (IPCHAINS_DATE | IPCHAINS_DATA | IPCHAINS_IPS)) {
+    return PARSE_OK;
+  } else {
+    if (opt.verbose)
+      fprintf(stderr, "ipchains parse error in line %d, ignoring.\n", linenum);
+    if (opt.verbose == 2)
+      fprintf(stderr, "input was: \"%s\"\n", input);
+    return PARSE_WRONG_FORMAT;
+  }
+}
+
diff -Naur fwlogwatch-1.2.orig/ipfilter.c fwlogwatch-1.2/ipfilter.c
--- fwlogwatch-1.2.orig/ipfilter.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/ipfilter.c	2011-09-08 11:36:00.561458543 +0200
@@ -0,0 +1,2696 @@
+#line 2 "ipfilter.c"
+
+#line 4 "ipfilter.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer ipf_create_buffer
+#define yy_delete_buffer ipf_delete_buffer
+#define yy_flex_debug ipf_flex_debug
+#define yy_init_buffer ipf_init_buffer
+#define yy_flush_buffer ipf_flush_buffer
+#define yy_load_buffer_state ipf_load_buffer_state
+#define yy_switch_to_buffer ipf_switch_to_buffer
+#define yyin ipfin
+#define yyleng ipfleng
+#define yylex ipflex
+#define yylineno ipflineno
+#define yyout ipfout
+#define yyrestart ipfrestart
+#define yytext ipftext
+#define yywrap ipfwrap
+#define yyalloc ipfalloc
+#define yyrealloc ipfrealloc
+#define yyfree ipffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ipfrestart(ipfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ipfleng;
+
+extern FILE *ipfin, *ipfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ipftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ipftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ipfrestart()), so that the user can continue scanning by
+	 * just pointing ipfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when ipftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int ipfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow ipfwrap()'s to do buffer switches
+ * instead of setting up a fresh ipfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void ipfrestart (FILE *input_file  );
+void ipf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ipf_create_buffer (FILE *file,int size  );
+void ipf_delete_buffer (YY_BUFFER_STATE b  );
+void ipf_flush_buffer (YY_BUFFER_STATE b  );
+void ipfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ipfpop_buffer_state (void );
+
+static void ipfensure_buffer_stack (void );
+static void ipf_load_buffer_state (void );
+static void ipf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ipf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ipf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ipf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ipf_scan_bytes (yyconst char *bytes,int len  );
+
+void *ipfalloc (yy_size_t  );
+void *ipfrealloc (void *,yy_size_t  );
+void ipffree (void *  );
+
+#define yy_new_buffer ipf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ipfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ipf_create_buffer(ipfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ipfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ipf_create_buffer(ipfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define ipfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *ipfin = (FILE *) 0, *ipfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int ipflineno;
+
+int ipflineno = 1;
+
+extern char *ipftext;
+#define yytext_ptr ipftext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up ipftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	ipfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 49
+#define YY_END_OF_BUFFER 50
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[608] =
+    {   0,
+       47,   47,   50,   48,   45,   46,   45,   47,   47,   47,
+       47,   47,   47,   47,   47,   47,   47,   47,   47,   47,
+       47,   48,   47,   47,   47,   47,   47,   45,    0,    0,
+        0,   47,    0,   37,    0,   47,   47,   47,   47,   47,
+       47,   47,   47,   40,   47,   47,   47,   47,   47,   47,
+       47,   47,   47,    0,    0,   47,   47,   47,   47,   47,
+       47,    0,    0,    0,   47,    0,   47,    0,   47,    0,
+        0,   47,   39,   38,   41,    0,    0,    0,    0,   47,
+       47,   47,   47,   47,   47,    0,    0,    0,   47,   47,
+       44,   44,   44,   44,   44,   47,    0,    0,    0,    0,
+
+       19,    0,    0,    0,    0,   47,   47,   47,    0,   47,
+        0,    0,    0,    0,    0,   47,   47,   44,   44,   44,
+       44,   47,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   47,    0,   47,    0,    0,
+        0,    0,    0,   47,   47,   44,   44,   44,   44,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   42,    0,    0,
+        0,    0,    5,    0,    7,   47,   44,   44,   44,    0,
+        0,    0,    0,    0,    0,    3,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   20,
+
+        0,    0,    0,    0,   43,   15,    7,   44,   44,   44,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   21,
+       22,    0,    0,    0,    0,    0,    0,   20,    0,    0,
+        0,    0,   15,    9,    7,   43,   44,    5,    0,    0,
+        0,    0,   11,    0,    0,    0,    0,   22,    0,    0,
+        0,    0,    0,    2,    0,    0,    0,    0,    9,    0,
+        6,    0,    0,   17,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    8,    0,    0,    0,    9,    0,
+        0,   17,   13,    0,    0,    0,    0,   23,    0,    0,
+        0,    0,   16,    8,    0,    0,    9,    0,    0,   13,
+
+        0,    0,    0,    0,    0,    0,    0,    0,   16,   10,
+        8,    0,   12,    9,    0,    0,   13,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   10,    0,   18,
+        0,    0,   13,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   10,   18,   14,    4,    1,
+       13,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   10,   14,    1,    0,    0,    0,    0,    0,
+        0,    0,   24,    0,    0,    0,    0,    0,   10,   14,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       26,   27,   14,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,   14,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   25,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   29,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,   28,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   31,   30,    0,
+        0,    0,    0,    0,    0,   33,    0,    0,    0,   34,
+
+       32,    0,    0,   36,    0,   35,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    4,    5,    5,    5,    5,    5,    5,    5,    6,
+        7,    5,    5,    8,    9,   10,   11,   12,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   14,    5,    5,
+        5,   15,    5,   16,   17,   18,   19,   20,   19,   21,
+       19,   19,   22,   23,   24,   18,   25,   26,   27,   28,
+       19,   29,   30,   31,   32,   19,   19,   19,   19,   19,
+       33,    5,   34,    5,   35,    5,   36,   37,   38,   39,
+
+       40,   41,   42,   43,   44,   45,   45,   46,   47,   48,
+       49,   50,   51,   52,   53,   54,   55,   56,   45,   57,
+       58,   45,    5,    5,    5,    5,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[59] =
+    {   0,
+        1,    1,    1,    2,    3,    4,    4,    5,    6,    7,
+        3,    6,    6,    4,    3,    8,    7,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    9,   10,    7,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6
+    } ;
+
+static yyconst flex_int16_t yy_base[634] =
+    {   0,
+        0,    0, 1546, 1547,   57, 1547,   58,   59,   61,   91,
+       64,   65,   66,   76,   79,   67,   75,   77,   84,   92,
+       80,  123,  129,  139,  133,  114,  136,   62, 1530,   60,
+     1528,  134,   73,  172,  143,  149,  202,  199,  142,  146,
+      166,  154,  186,  161,  174,  213,  214,  193,  177,  217,
+      216,  191,  221,  217, 1523,  224,  227,  232,  233,  248,
+      249, 1538,  255,  260,  273,  303,  151,  172,  280,  341,
+       71,  258,  270,  271,  284, 1525,  282,  287, 1536,  285,
+      294,  297,  301,  298,  316,  296,  298,  300,  351,  355,
+     1535,    0,  385,  309,  363,  348,  311,  156,  164,  379,
+
+     1522,  359, 1527,  313,  374,  352,  401,  402,  396,  406,
+     1503,  403,  320,  407,  425,  436,  423,  361,  466,  504,
+      418,  431, 1521,  381, 1518,  405,  441,  439,  445,  459,
+      141,  452,  448,  461,  470,  443,  476,  480,  454,  481,
+      485,  481, 1511,  488,  523,  526,  553,  591,  507,  534,
+      536,  539, 1528,  548, 1521, 1496,  551,  563,  558,  565,
+      542, 1491, 1479, 1483, 1478,  570,  574,  555,  587,  222,
+      589,  595, 1547, 1499,  602,  607, 1502,  637,  609,  606,
+      611,  613,  621,  626, 1489, 1547,  632,  627,  634,  641,
+      643,  645, 1511, 1478, 1465, 1472, 1466,  649,  651,  659,
+
+      655,  669,  674, 1507, 1547,  681,  687, 1490,  717,  678,
+     1505,  685, 1500,  691, 1503,  700,  726,  697, 1502,  657,
+      705, 1462, 1458, 1452, 1468,  731, 1493, 1547,  735,  318,
+      710,  722,  565,  748,  742,    0,  778,    0,  750,  746,
+      754,  758, 1498,  789,  762,  767,  774, 1547,  470, 1467,
+     1466, 1467,  794, 1547,  776,  798,  811, 1492,  821,  785,
+     1547,  800, 1467,  814,  823,  828,  833, 1490, 1487, 1458,
+     1457, 1456, 1457,  817,  840,  552,  837,  845,  855,  850,
+     1480,    0,  852,  858,  859,  864,  868, 1547, 1443, 1441,
+     1451, 1447,  870,  877,  874, 1479,  889,  882,  884,  886,
+
+      900,  903,  893, 1478, 1441, 1431, 1446, 1473, 1450,  905,
+      482,  908, 1474,  686,  911,  913,  916, 1472,  707,  927,
+      929,  922,  362, 1422, 1439, 1467,  864,  931, 1443,  934,
+      936, 1472,  938, 1471, 1465,  953, 1439, 1463,  940, 1460,
+     1422, 1425, 1429, 1418, 1417,  942,    0,  946, 1547,    0,
+        0, 1432, 1460,  957, 1459,  959, 1450, 1423, 1412, 1412,
+     1405, 1405,  955,  961,    0, 1423,  964,  966,  979, 1422,
+     1445,  981, 1547, 1410, 1398, 1407, 1396, 1392, 1412,  968,
+      985,  990,  799, 1409,  992, 1434,  997, 1426, 1380, 1383,
+     1547, 1547,  994, 1001, 1005, 1007, 1012, 1016, 1018, 1023,
+
+     1416, 1387, 1383,    0, 1029, 1402, 1034,  691, 1020, 1040,
+     1373, 1044, 1025, 1398, 1547, 1353, 1348, 1036, 1048, 1050,
+     1056, 1060, 1380, 1052, 1066, 1074, 1333, 1333, 1078, 1372,
+     1082,  827, 1062, 1088, 1092,  899, 1068, 1096, 1547, 1332,
+     1084, 1100, 1104, 1108, 1114, 1361, 1110, 1118, 1122, 1356,
+     1317, 1126, 1349, 1132, 1001, 1134, 1140, 1144, 1049, 1136,
+     1149, 1303, 1151, 1335, 1154, 1160, 1157, 1332, 1162, 1166,
+     1170, 1326, 1247, 1232, 1258, 1177,  504, 1184, 1240, 1190,
+     1109, 1188, 1194, 1194, 1200, 1222, 1194, 1201, 1175, 1166,
+     1204, 1207, 1199, 1182, 1134, 1157, 1155, 1217, 1142, 1127,
+
+      983, 1223,  672, 1212, 1125, 1547, 1110, 1107, 1235, 1099,
+     1064, 1043, 1239, 1021, 1241,    0,    0, 1103,    0, 1039,
+      992, 1245,  980,  992, 1251,  985,  980,  978,    0,  937,
+     1257,  901,  856, 1261,  833,  826,  801,  838,    0, 1125,
+      816,  764, 1263,  745,  737,  733,  723,  747,    0,  745,
+     1267,  689,  683,  679,  652,  606,  612,    0,  608,  605,
+      570,  568,  484,  488,  480,  492, 1219, 1229, 1247,  471,
+      394,  388,  368, 1273, 1279, 1283, 1269,  392,  300,  306,
+     1276, 1281,  332, 1293, 1286,  331,  266, 1288, 1290, 1295,
+     1297, 1300, 1302,  274, 1304, 1306, 1308, 1318, 1311, 1547,
+
+     1313, 1315, 1325, 1320, 1322, 1327, 1547, 1339, 1347, 1356,
+     1359, 1363, 1368, 1373, 1382, 1387, 1390, 1398, 1403, 1407,
+     1410, 1415, 1420, 1428, 1434, 1442,  252,  228,  171,  138,
+      117,  101,   71
+    } ;
+
+static yyconst flex_int16_t yy_def[634] =
+    {   0,
+      607,    1,  607,  607,  607,  607,  607,  608,  608,  608,
+      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
+      608,  607,   10,   10,  608,  608,  608,  607,  607,  607,
+      607,  608,  607,  608,  607,  608,   10,   37,  608,  608,
+      608,  608,  608,  608,  608,  608,  608,  608,  608,  608,
+      608,  608,  608,  607,  607,  608,  608,  608,  608,  608,
+      608,  607,  607,  607,  608,  609,   10,  607,   10,  609,
+      610,  608,  608,  608,  608,  611,  607,  607,  607,  608,
+      608,  608,  608,  608,  608,  612,  607,  607,  608,  608,
+      609,  609,  609,  609,  609,   37,  607,  610,  610,  607,
+
+      611,  607,  607,  607,  613,  608,  608,  608,  607,  608,
+      612,  612,  607,  607,  607,  608,  608,  609,  609,  609,
+      609,   10,  607,  607,  607,  607,  607,  607,  607,  607,
+      613,  613,  607,  607,  607,  608,  607,  608,  612,  612,
+      607,  607,  607,  608,  608,  609,  609,  609,  609,  607,
+      607,  607,  607,  607,  607,  614,  613,  613,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  608,  612,  612,
+      607,  607,  607,  607,  608,  608,  609,  609,  609,  607,
+      607,  607,  607,  607,  614,  607,  613,  613,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+
+      612,  612,  607,  607,  607,  615,  608,  609,  609,  609,
+      607,  607,  607,  607,  607,  613,  613,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  612,  612,
+      607,  607,  615,  615,  608,  609,  609,  609,  607,  607,
+      607,  607,  607,  613,  613,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  612,  612,  607,  607,  615,  607,
+      607,  607,  607,  616,  613,  613,  607,  607,  607,  607,
+      607,  607,  607,  607,  612,  612,  607,  607,  615,  607,
+      607,  616,  616,  613,  613,  607,  607,  607,  607,  607,
+      607,  607,  617,  612,  607,  607,  615,  607,  607,  616,
+
+      618,  613,  607,  607,  607,  607,  607,  607,  617,  617,
+      612,  607,  607,  615,  607,  607,  616,  607,  618,  618,
+      613,  607,  607,  607,  607,  607,  607,  617,  607,  619,
+      607,  607,  616,  607,  607,  618,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  617,  619,  619,  607,  620,
+      616,  621,  607,  618,  607,  607,  607,  607,  607,  607,
+      607,  607,  617,  619,  620,  621,  607,  621,  618,  622,
+      607,  607,  607,  607,  607,  607,  607,  607,  617,  619,
+      607,  621,  618,  622,  607,  607,  607,  607,  607,  607,
+      607,  607,  619,  607,  607,  621,  621,  607,  623,  607,
+
+      607,  607,  607,  619,  607,  607,  621,  621,  607,  607,
+      623,  623,  607,  607,  607,  607,  607,  607,  607,  621,
+      621,  607,  607,  623,  623,  607,  607,  607,  607,  607,
+      621,  621,  607,  607,  623,  623,  607,  607,  607,  607,
+      607,  607,  621,  621,  607,  607,  623,  623,  607,  607,
+      607,  607,  607,  621,  621,  607,  607,  623,  623,  607,
+      607,  607,  607,  607,  621,  621,  607,  607,  623,  623,
+      607,  607,  607,  607,  624,  621,  621,  607,  607,  623,
+      623,  607,  607,  607,  607,  624,  607,  621,  607,  607,
+      625,  623,  607,  607,  607,  607,  607,  621,  607,  607,
+
+      625,  625,  623,  607,  607,  607,  607,  607,  621,  607,
+      607,  607,  625,  607,  626,  627,  628,  621,  629,  607,
+      607,  625,  607,  626,  626,  627,  628,  629,  630,  607,
+      625,  607,  607,  626,  607,  607,  607,  630,  631,  625,
+      607,  607,  626,  607,  607,  607,  607,  631,  632,  607,
+      626,  607,  607,  607,  607,  607,  632,  633,  626,  607,
+      607,  607,  607,  607,  607,  633,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+
+      607,  607,  607,  607,  607,  607,    0,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607
+    } ;
+
+static yyconst flex_int16_t yy_nxt[1606] =
+    {   0,
+        4,    5,    6,    7,    4,    4,    4,    8,    9,    8,
+        4,   10,   10,    4,    4,    4,   11,    8,    8,   12,
+       13,   14,   15,   16,   17,   18,   19,   20,    8,   21,
+        8,    8,   22,    4,    8,   23,   23,   23,   23,   23,
+       24,    8,    8,   25,    8,   26,   27,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    8,   28,   28,
+       28,   28,   31,   28,   31,   28,   29,   31,   31,   31,
+       31,   63,   63,   30,   98,   47,  566,   34,   31,   31,
+       31,   34,   31,   31,   54,   54,   30,   31,   34,   34,
+       34,   33,   34,   33,   35,   31,   33,   33,   33,   33,
+
+       36,   44,   37,   37,   42,   43,  557,   33,   33,   33,
+       48,   33,   33,   40,   45,   50,   33,   31,   41,   53,
+       52,   51,  548,   33,   33,   49,   38,   38,   38,   38,
+       38,   38,   31,   46,   54,   54,   31,   31,   32,   31,
+       38,   38,   31,  538,   55,   71,   33,   39,   32,   31,
+       38,   38,   31,   60,   64,   64,  607,   31,   30,   98,
+       65,   65,   96,   96,   31,   33,   33,  125,   33,   31,
+       58,  124,   61,  133,   33,   31,  528,   31,   33,  607,
+       31,   33,   59,   97,   97,   32,   33,   56,   34,   31,
+       57,   72,   34,   33,   76,   32,   31,   72,   33,   34,
+
+       34,   34,   70,   34,   33,   66,   33,   72,   32,   33,
+       69,   69,  607,   67,   67,   68,   31,   31,   33,   31,
+       31,   72,   72,   33,   31,   33,   77,   31,   78,   78,
+       31,  139,   72,  527,   73,   31,   31,   69,   69,   69,
+       69,   69,   69,   74,   72,   33,   33,   75,   33,   33,
+       72,   31,   31,   33,  113,   32,   33,  526,   72,   33,
+       72,  100,   81,   88,   33,   33,   63,   63,   87,   72,
+       72,   64,   64,   31,   31,   80,   31,  599,   82,   83,
+       33,   33,   89,   31,   90,   90,   85,   31,  105,   32,
+       33,   38,   38,  102,  102,   84,   77,   31,  103,  103,
+
+       31,  109,   33,   33,   31,   33,   91,  112,  112,  114,
+      114,  115,  115,  594,   93,   93,   33,   33,   94,   31,
+      121,  121,  123,  123,  130,  130,   33,  201,  113,   33,
+       33,  141,  141,   33,  593,  106,   32,  590,   95,   95,
+       95,   95,   95,   95,   91,  587,  107,  586,   33,  108,
+      113,  110,   95,   95,   31,  134,   94,   32,   31,  122,
+      122,  607,  116,  116,   89,  338,  117,  117,  128,  339,
+      129,  129,  146,  146,  120,  120,   95,   95,   95,   95,
+       95,   95,  126,   33,   33,  132,  132,   33,  118,   30,
+      127,  127,  151,  151,   30,  585,  119,  119,  120,  120,
+
+      120,  120,  120,  120,  135,   31,  133,  137,  137,   31,
+      142,   30,  139,  580,  140,  140,  127,  127,  114,  114,
+      120,  120,  120,  120,  120,  120,   31,  579,  143,  121,
+      121,  149,   89,   33,   33,  113,  115,  115,   33,   31,
+       32,  578,   96,   96,  152,  144,   31,  145,  145,  136,
+      154,  154,  153,  153,  128,   33,  155,  155,  138,  159,
+      159,  157,  156,  158,  158,  169,  169,  607,   33,  147,
+      130,  130,  160,  160,  577,  166,   30,   93,   93,  167,
+      269,  161,  161,   31,  133,   30,  113,  137,  137,  293,
+      139,   31,  170,  170,  171,  573,  172,  172,  173,  175,
+
+      175,   95,   95,   95,   95,   95,   95,  148,  173,  162,
+      173,  465,   33,  113,  113,   95,   95,  173,  179,  179,
+       33,  270,  163,  164,  165,  572,   31,  571,  173,  177,
+      173,  570,  144,  168,  176,  176,  367,  146,  146,   95,
+       95,   95,   95,   95,   95,  180,  180,  151,  151,  181,
+      182,  182,  192,  193,  193,   33,   91,  183,   31,  184,
+      184,  255,  187,  187,  178,  178,  607,  189,   31,  190,
+      190,  569,  157,  568,  188,  188,  160,  160,  607,  199,
+      191,  198,  198,  133,  113,  200,  200,   33,   95,   95,
+       95,   95,   95,   95,   91,  133,  201,   33,  202,  202,
+
+      203,  203,   95,   95,  171,   31,  204,  204,  567,  206,
+       31,  533,  210,  207,  207,  565,  144,  211,  211,  113,
+      179,  179,  212,  212,  213,  213,   95,   95,   95,   95,
+       95,   95,  214,  214,   33,  183,  157,  215,  215,   33,
+      177,  216,  607,  217,  217,  218,  218,  607,  209,  209,
+      189,  564,  219,  219,  220,  220,  221,  221,   77,  133,
+      226,  226,  200,  200,  133,  228,  229,  229,  220,  220,
+      200,  200,  120,  120,  120,  120,  120,  120,  201,  491,
+      230,  230,  227,  231,   31,  232,  232,  113,  240,   31,
+       31,  563,  234,  234,  206,  238,  212,  212,  235,  235,
+
+      396,  113,  242,  242,  413,  238,  246,  238,  247,  247,
+      318,  244,  244,   33,  238,  607,  248,  248,   33,   33,
+      237,  257,  257,  367,  243,  238,  562,  238,  178,  178,
+      561,  231,  133,  258,  258,  216,  560,  245,  245,  133,
+       77,  607,  253,  253,  255,   31,  256,  256,  558,  206,
+      556,   31,   95,   95,   95,   95,   95,   95,  133,  259,
+      259,  260,  260,  261,  227,  262,  262,  113,  555,  263,
+      263,  216,  554,  261,   33,  261,  553,  607,  267,  267,
+       33,   91,  261,  246,  552,  268,  268,  275,  275,   95,
+       95,  243,  550,  261,  133,  261,  280,  280,  265,  208,
+
+      266,  266,  335,   77,  607,  274,  274,  255,  113,  276,
+      276,  281,  281,   95,   95,   95,   95,   95,   95,  549,
+      277,  133,  278,  278,   31,  283,  283,  227,  274,  274,
+      113,  133,  279,  279,  284,  284,  420,  265,  607,  285,
+      285,  547,  286,  607,  287,  287,  546,  293,  295,  295,
+      227,  294,  294,   33,  277,  133,  296,  296,   31,  367,
+      133,  298,  298,  300,  300,  301,  297,  297,  265,  302,
+      302,  545,  113,  607,  607,  303,  303,  286,  544,  304,
+      304,  310,  310,  542,  293,  312,  312,   33,  311,  311,
+      133,  133,   31,  315,  315,  316,  316,  317,  317,  343,
+
+      314,  314,  113,  318,  322,  322,  344,  313,  424,  113,
+      301,  320,  320,  345,  321,  321,  328,  328,  607,  329,
+      329,   33,  331,  331,  332,  332,  323,  333,  333,  541,
+      335,  413,  133,  337,  337,  133,  301,  113,  336,  336,
+      539,  313,  346,  346,  607,  348,  348,  349,  349,  351,
+      351,  356,  356,  363,  363,  323,  335,  364,  364,  133,
+      335,  133,  371,  113,  354,  354,  379,  379,  369,  369,
+      372,  372,  380,  380,  113,  381,  381,  382,  382,  393,
+      393,  537,  335,  536,  371,  133,  500,  113,  535,  133,
+      383,  383,  387,  387,  394,  523,  395,  395,  367,  396,
+
+      371,  397,  397,  398,  398,  404,  404,  532,  400,  400,
+      443,  133,  405,  405,  394,  413,  406,  406,  407,  407,
+      530,  396,  367,  408,  408,  409,  371,  410,  410,  412,
+      412,  422,  422,  367,  414,  414,  426,  426,  418,  367,
+      419,  419,  529,  420,  367,  421,  421,  429,  429,  409,
+      413,  423,  423,  424,  505,  425,  425,  418,  447,  430,
+      430,  431,  431,  435,  435,  420,  367,  432,  432,  433,
+      521,  434,  434,  445,  445,  424,  413,  436,  436,  449,
+      449,  413,  367,  437,  413,  438,  438,  441,  367,  442,
+      442,  443,  520,  444,  444,  452,  452,  433,  413,  446,
+
+      446,  447,  519,  448,  448,  437,  487,  450,  450,  441,
+      517,  453,  453,  516,  367,  454,  454,  443,  469,  455,
+      455,  458,  458,  456,  413,  457,  457,  447,  512,  459,
+      459,  460,  515,  461,  461,  367,  367,  463,  463,  465,
+      367,  413,  413,  466,  466,  467,  467,  471,  471,  456,
+      413,  468,  468,  469,  511,  470,  470,  413,  460,  464,
+      472,  472,  474,  474,  367,  476,  476,  465,  478,  478,
+      510,  477,  477,  480,  480,  469,  413,  481,  481,  482,
+      487,  483,  483,  508,  464,  507,  367,  506,  488,  488,
+      479,  482,  367,  499,  413,  489,  489,  491,  413,  493,
+
+      493,  492,  492,  482,  487,  494,  494,  500,  479,  367,
+      504,  504,  498,  498,  491,  502,  502,  479,  503,  503,
+      487,  497,  413,  514,  514,  485,  512,  496,  509,  509,
+      574,  574,  505,  367,  513,  513,  413,  495,  487,  413,
+      575,  575,  512,  490,  523,  505,  518,  518,  512,  367,
+      522,  522,  525,  525,  533,  413,  531,  531,  576,  576,
+      512,  485,  534,  534,  533,  464,  533,  367,  540,  540,
+      533,  413,  543,  543,  551,  551,  581,  413,  559,  559,
+      584,  584,  582,  484,  574,  574,  583,  588,  588,  413,
+      575,  575,  589,  589,  576,  576,  591,  592,  592,  588,
+
+      588,  589,  589,  597,  584,  584,  595,  595,  596,  596,
+      600,  592,  592,  598,  598,  595,  595,  596,  596,  601,
+      601,  602,  603,  603,  601,  601,  604,  604,  605,  598,
+      598,  604,  604,  606,  606,  460,  603,  603,  606,  606,
+       32,  456,  475,   32,   32,   32,  473,   32,   92,   92,
+       92,   92,   92,   92,   92,   92,   92,   99,  441,  462,
+       99,   99,   99,   99,  101,  437,  101,  111,  111,  111,
+      433,  111,  131,  131,  131,  131,  131,  185,  185,  185,
+      451,  418,  185,  233,  440,  439,  233,  233,  233,  409,
+      233,  282,  282,  282,  309,  309,  309,  428,  309,  319,
+
+      427,  371,  319,  319,  319,  413,  319,  347,  347,  347,
+      365,  394,  365,  365,  366,  366,  366,  417,  366,  384,
+      384,  384,  416,  384,  411,  411,  411,  415,  411,  486,
+      403,  402,  486,  486,  486,  501,  401,  399,  501,  501,
+      501,  385,  501,  524,  113,  392,  524,  524,  524,  391,
+      390,  389,  388,  386,  385,  367,  378,  377,  376,  375,
+      374,  373,  370,  368,  367,  362,  361,  360,  359,  358,
+      357,  355,  323,  353,  352,  350,  313,  342,  341,  340,
+      334,  330,  113,  327,  326,  325,  324,  286,  277,  308,
+      307,  306,  305,  299,  292,  291,  290,  289,  288,  246,
+
+      243,  231,  273,  272,  271,  264,  254,  252,  251,  250,
+      249,  189,  183,  241,  239,  236,  171,  225,  224,  223,
+      222,  192,  186,  208,  205,  197,  196,  195,  194,  186,
+      128,  152,  174,  124,  150,  113,   77,  607,   91,  104,
+       30,   86,   79,   30,   62,  607,    3,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+
+      607,  607,  607,  607,  607
+    } ;
+
+static yyconst flex_int16_t yy_chk[1606] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    5,    7,
+        5,    7,    8,   28,    9,   28,    7,   11,   12,   13,
+       16,   30,   30,    7,   71,   16,  633,    9,   17,   14,
+       18,    9,   15,   21,   33,   33,   71,   19,    9,    9,
+        9,    8,    9,    9,   10,   20,   11,   12,   13,   16,
+
+       10,   14,   10,   10,   12,   13,  632,   17,   14,   18,
+       17,   15,   21,   11,   15,   19,   19,   26,   11,   21,
+       20,   19,  631,   10,   20,   18,   10,   10,   10,   10,
+       10,   10,   23,   15,   22,   22,   25,   32,   23,   27,
+       23,   23,   24,  630,   22,   39,   26,   10,   24,   40,
+       24,   24,   36,   26,   35,   35,  131,   42,   35,   98,
+       36,   36,   67,   67,   44,   25,   32,   99,   27,   41,
+       25,   98,   27,  131,   39,   34,  629,   45,   40,   99,
+       49,   36,   25,   68,   68,   23,   42,   24,   34,   43,
+       24,   42,   34,   44,   52,   24,   48,   40,   41,   34,
+
+       34,   34,   38,   34,   34,   37,   45,   41,   38,   49,
+       38,   38,   38,   37,   37,   37,   46,   47,   43,   51,
+       50,   45,   43,   52,   53,   48,   54,   56,   54,   54,
+       57,  170,   49,  628,   47,   58,   59,   37,   37,   37,
+       37,   37,   37,   47,   48,   46,   47,   50,   51,   50,
+       48,   60,   61,   53,  170,   38,   56,  627,   46,   57,
+       46,   72,   57,   64,   58,   59,   63,   63,   63,   51,
+       53,   64,   64,   73,   74,   56,   65,  594,   58,   59,
+       60,   61,   65,   69,   65,   65,   61,   75,   80,   69,
+       72,   69,   69,   77,   77,   60,   78,   81,   78,   78,
+
+       82,   84,   73,   74,   83,   65,   66,   86,   86,   87,
+       87,   88,   88,  587,   66,   66,   75,   80,   66,   85,
+       94,   94,   97,   97,  104,  104,   81,  230,   86,   82,
+       84,  113,  113,   83,  586,   81,   69,  583,   66,   66,
+       66,   66,   66,   66,   70,  580,   82,  579,   85,   83,
+      230,   85,   70,   70,   89,  106,   70,   96,   90,   96,
+       96,   96,   89,   89,   90,  323,   90,   90,  102,  323,
+      102,  102,  118,  118,   95,   95,   70,   70,   70,   70,
+       70,   70,  100,   89,  106,  105,  105,   90,   93,  105,
+      100,  100,  124,  124,  100,  578,   93,   93,   95,   95,
+
+       95,   95,   95,   95,  107,  108,  105,  109,  109,  110,
+      114,  109,  112,  573,  112,  112,  126,  126,  114,  114,
+       93,   93,   93,   93,   93,   93,  117,  572,  115,  121,
+      121,  121,  117,  107,  108,  112,  115,  115,  110,  116,
+      122,  571,  122,  122,  127,  116,  136,  116,  116,  108,
+      128,  128,  127,  127,  129,  117,  129,  129,  110,  133,
+      133,  132,  130,  132,  132,  139,  139,  132,  116,  119,
+      130,  130,  134,  134,  570,  136,  134,  119,  119,  137,
+      249,  135,  135,  138,  132,  135,  139,  137,  137,  311,
+      140,  144,  140,  140,  141,  566,  141,  141,  142,  144,
+
+      144,  119,  119,  119,  119,  119,  119,  120,  142,  135,
+      142,  477,  138,  140,  311,  120,  120,  142,  149,  149,
+      144,  249,  135,  135,  135,  565,  145,  564,  142,  146,
+      142,  563,  145,  138,  145,  145,  477,  146,  146,  120,
+      120,  120,  120,  120,  120,  150,  150,  151,  151,  151,
+      152,  152,  161,  161,  161,  145,  147,  154,  168,  154,
+      154,  276,  157,  157,  147,  147,  157,  159,  233,  159,
+      159,  562,  158,  561,  158,  158,  160,  160,  158,  167,
+      160,  166,  166,  157,  276,  167,  167,  168,  147,  147,
+      147,  147,  147,  147,  148,  158,  169,  233,  169,  169,
+
+      171,  171,  148,  148,  172,  175,  172,  172,  560,  175,
+      176,  559,  179,  175,  175,  557,  176,  180,  180,  169,
+      179,  179,  181,  181,  182,  182,  148,  148,  148,  148,
+      148,  148,  183,  183,  175,  184,  188,  184,  184,  176,
+      178,  187,  188,  187,  187,  189,  189,  187,  178,  178,
+      190,  556,  190,  190,  191,  191,  192,  192,  198,  188,
+      198,  198,  199,  199,  187,  200,  201,  201,  220,  220,
+      200,  200,  178,  178,  178,  178,  178,  178,  202,  503,
+      202,  202,  198,  203,  206,  203,  203,  201,  212,  314,
+      207,  555,  206,  206,  207,  210,  212,  212,  207,  207,
+
+      408,  202,  214,  214,  503,  210,  218,  210,  218,  218,
+      319,  216,  216,  206,  210,  216,  221,  221,  314,  207,
+      209,  231,  231,  408,  214,  210,  554,  210,  209,  209,
+      553,  232,  216,  232,  232,  217,  552,  217,  217,  319,
+      226,  217,  226,  226,  229,  235,  229,  229,  550,  235,
+      548,  234,  209,  209,  209,  209,  209,  209,  217,  234,
+      234,  239,  239,  240,  226,  241,  241,  229,  547,  242,
+      242,  245,  546,  240,  235,  240,  545,  245,  246,  246,
+      234,  237,  240,  247,  544,  247,  247,  255,  255,  237,
+      237,  242,  542,  240,  245,  240,  260,  260,  244,  237,
+
+      244,  244,  383,  253,  244,  253,  253,  256,  255,  256,
+      256,  262,  262,  237,  237,  237,  237,  237,  237,  541,
+      257,  244,  257,  257,  259,  264,  264,  253,  274,  274,
+      256,  383,  259,  259,  265,  265,  432,  266,  265,  266,
+      266,  538,  267,  266,  267,  267,  537,  275,  277,  277,
+      274,  275,  275,  259,  278,  265,  278,  278,  279,  432,
+      266,  280,  280,  283,  283,  284,  279,  279,  285,  284,
+      284,  536,  275,  284,  285,  286,  286,  287,  535,  287,
+      287,  293,  293,  533,  294,  295,  295,  279,  294,  294,
+      284,  285,  297,  298,  298,  299,  299,  300,  300,  327,
+
+      297,  297,  293,  301,  303,  303,  327,  295,  436,  294,
+      302,  301,  301,  327,  302,  302,  310,  310,  302,  312,
+      312,  297,  315,  315,  316,  316,  303,  317,  317,  532,
+      320,  436,  301,  322,  322,  302,  321,  310,  320,  320,
+      530,  312,  328,  328,  321,  330,  330,  331,  331,  333,
+      333,  339,  339,  346,  346,  322,  336,  348,  348,  320,
+      354,  321,  356,  328,  336,  336,  363,  363,  354,  354,
+      356,  356,  364,  364,  346,  367,  367,  368,  368,  380,
+      380,  528,  369,  527,  372,  336,  501,  363,  526,  354,
+      369,  369,  372,  372,  381,  524,  381,  381,  368,  382,
+
+      387,  382,  382,  385,  385,  393,  393,  523,  387,  387,
+      455,  369,  394,  394,  395,  501,  395,  395,  396,  396,
+      521,  397,  382,  397,  397,  398,  400,  398,  398,  399,
+      399,  409,  409,  455,  400,  400,  413,  413,  405,  396,
+      405,  405,  520,  407,  397,  407,  407,  418,  418,  410,
+      399,  410,  410,  412,  514,  412,  412,  419,  459,  419,
+      419,  420,  420,  424,  424,  421,  407,  421,  421,  422,
+      512,  422,  422,  433,  433,  425,  412,  425,  425,  437,
+      437,  459,  420,  426,  424,  426,  426,  429,  421,  429,
+      429,  431,  511,  431,  431,  441,  441,  434,  425,  434,
+
+      434,  435,  510,  435,  435,  438,  518,  438,  438,  442,
+      508,  442,  442,  507,  431,  443,  443,  444,  481,  444,
+      444,  447,  447,  445,  435,  445,  445,  448,  540,  448,
+      448,  449,  505,  449,  449,  518,  443,  452,  452,  454,
+      444,  481,  447,  454,  454,  456,  456,  460,  460,  457,
+      448,  457,  457,  458,  500,  458,  458,  540,  461,  452,
+      461,  461,  463,  463,  454,  465,  465,  466,  467,  467,
+      499,  466,  466,  469,  469,  470,  458,  470,  470,  471,
+      476,  471,  471,  497,  463,  496,  465,  495,  476,  476,
+      467,  494,  466,  490,  469,  478,  478,  480,  470,  482,
+
+      482,  480,  480,  483,  488,  483,  483,  491,  489,  476,
+      493,  493,  488,  488,  492,  491,  491,  478,  492,  492,
+      498,  487,  480,  504,  504,  486,  502,  485,  498,  498,
+      567,  567,  493,  488,  502,  502,  491,  484,  509,  492,
+      568,  568,  513,  479,  515,  504,  509,  509,  522,  498,
+      513,  513,  515,  515,  525,  502,  522,  522,  569,  569,
+      531,  475,  525,  525,  534,  474,  543,  509,  531,  531,
+      551,  513,  534,  534,  543,  543,  574,  522,  551,  551,
+      577,  577,  575,  473,  574,  574,  576,  581,  581,  531,
+      575,  575,  582,  582,  576,  576,  584,  585,  585,  588,
+
+      588,  589,  589,  592,  584,  584,  590,  590,  591,  591,
+      595,  592,  592,  593,  593,  595,  595,  596,  596,  597,
+      597,  598,  599,  599,  601,  601,  602,  602,  603,  598,
+      598,  604,  604,  605,  605,  472,  603,  603,  606,  606,
+      608,  468,  464,  608,  608,  608,  462,  608,  609,  609,
+      609,  609,  609,  609,  609,  609,  609,  610,  453,  451,
+      610,  610,  610,  610,  611,  450,  611,  612,  612,  612,
+      446,  612,  613,  613,  613,  613,  613,  614,  614,  614,
+      440,  430,  614,  615,  428,  427,  615,  615,  615,  423,
+      615,  616,  616,  616,  617,  617,  617,  417,  617,  618,
+
+      416,  414,  618,  618,  618,  411,  618,  619,  619,  619,
+      620,  406,  620,  620,  621,  621,  621,  403,  621,  622,
+      622,  622,  402,  622,  623,  623,  623,  401,  623,  624,
+      390,  389,  624,  624,  624,  625,  388,  386,  625,  625,
+      625,  384,  625,  626,  379,  378,  626,  626,  626,  377,
+      376,  375,  374,  371,  370,  366,  362,  361,  360,  359,
+      358,  357,  355,  353,  352,  345,  344,  343,  342,  341,
+      340,  338,  337,  335,  334,  332,  329,  326,  325,  324,
+      318,  313,  309,  308,  307,  306,  305,  304,  296,  292,
+      291,  290,  289,  281,  273,  272,  271,  270,  269,  268,
+
+      263,  258,  252,  251,  250,  243,  227,  225,  224,  223,
+      222,  219,  215,  213,  211,  208,  204,  197,  196,  195,
+      194,  193,  185,  177,  174,  165,  164,  163,  162,  156,
+      155,  153,  143,  125,  123,  111,  103,  101,   91,   79,
+       76,   62,   55,   31,   29,    3,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+      607,  607,  607,  607,  607,  607,  607,  607,  607,  607,
+
+      607,  607,  607,  607,  607
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int ipf_flex_debug;
+int ipf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *ipftext;
+#line 1 "ipfilter.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: ipfilter.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "ipfilter.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <netdb.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void ipf_parse_date(char *input);
+void ipf_parse_data(char *input, unsigned char mode);
+void ipf_parse_ips(char *input, unsigned char mode);
+void ipf_parse_proto(char *input);
+void ipf_parse_flags(char *input);
+#line 1061 "ipfilter.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int ipflex_destroy (void );
+
+int ipfget_debug (void );
+
+void ipfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE ipfget_extra (void );
+
+void ipfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *ipfget_in (void );
+
+void ipfset_in  (FILE * in_str  );
+
+FILE *ipfget_out (void );
+
+void ipfset_out  (FILE * out_str  );
+
+int ipfget_leng (void );
+
+char *ipfget_text (void );
+
+int ipfget_lineno (void );
+
+void ipfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int ipfwrap (void );
+#else
+extern int ipfwrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( ipftext, ipfleng, 1, ipfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( ipfin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( ipfin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, ipfin))==0 && ferror(ipfin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(ipfin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int ipflex (void);
+
+#define YY_DECL int ipflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after ipftext and ipfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 40 "ipfilter.l"
+
+
+#line 1249 "ipfilter.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! ipfin )
+			ipfin = stdin;
+
+		if ( ! ipfout )
+			ipfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			ipfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ipf_create_buffer(ipfin,YY_BUF_SIZE );
+		}
+
+		ipf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of ipftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 608 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 607 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 42 "ipfilter.l"
+ipf_parse_date(ipftext);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 43 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 44 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 45 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 46 "ipfilter.l"
+ipf_parse_data(ipftext, IPF_OPT_NONE);
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 47 "ipfilter.l"
+ipf_parse_data(ipftext, IPF_OPT_COUNT);
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 48 "ipfilter.l"
+ipf_parse_ips(ipftext, IPF_OPT_SRC);
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 49 "ipfilter.l"
+ipf_parse_ips(ipftext+4, IPF_OPT_DST);
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 50 "ipfilter.l"
+ipf_parse_ips(ipftext, IPF_OPT_SRC|IPF_OPT_PORT);
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 51 "ipfilter.l"
+ipf_parse_ips(ipftext+4, IPF_OPT_DST|IPF_OPT_PORT);
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 52 "ipfilter.l"
+ipf_parse_ips(ipftext, IPF_OPT_SRC|IPF_OPT_RES);
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 53 "ipfilter.l"
+ipf_parse_ips(ipftext+4, IPF_OPT_DST|IPF_OPT_RES);
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 54 "ipfilter.l"
+ipf_parse_ips(ipftext, IPF_OPT_SRC|IPF_OPT_RES|IPF_OPT_PORT);
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 55 "ipfilter.l"
+ipf_parse_ips(ipftext+4, IPF_OPT_DST|IPF_OPT_RES|IPF_OPT_PORT);
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 56 "ipfilter.l"
+ipf_parse_ips(ipftext, IPF_OPT_SRC|IPF_OPT_RPORT);
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 57 "ipfilter.l"
+ipf_parse_ips(ipftext+4, IPF_OPT_DST|IPF_OPT_RPORT);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 58 "ipfilter.l"
+ipf_parse_ips(ipftext, IPF_OPT_SRC|IPF_OPT_RES|IPF_OPT_RPORT);
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 59 "ipfilter.l"
+ipf_parse_ips(ipftext+4, IPF_OPT_DST|IPF_OPT_RES|IPF_OPT_RPORT);
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 60 "ipfilter.l"
+ipf_parse_proto(ipftext+3);
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 61 "ipfilter.l"
+opt.line->datalen = atoi(ipftext+4);
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 62 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 63 "ipfilter.l"
+sscanf(ipftext, "icmp %d/%d", &opt.line->sport, &opt.line->dport); opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 64 "ipfilter.l"
+opt.line->sport = 8; opt.line->dport = 0; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 65 "ipfilter.l"
+opt.line->sport = 0; opt.line->dport = 0; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 66 "ipfilter.l"
+opt.line->sport = 4; opt.line->dport = 0; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 67 "ipfilter.l"
+opt.line->sport = 3; opt.line->dport = 1; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 68 "ipfilter.l"
+opt.line->sport = 3; opt.line->dport = 3; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 69 "ipfilter.l"
+opt.line->sport = 3; opt.line->dport = 10; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 70 "ipfilter.l"
+opt.line->sport = 11; opt.line->dport = 1; opt.parser=opt.parser|IPF_SRC_PORT|IPF_DST_PORT;
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 71 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 72 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 73 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 74 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 75 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 76 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 77 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 78 "ipfilter.l"
+ipf_parse_flags(ipftext+1);
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 79 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 80 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 81 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 82 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 83 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 84 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 85 "ipfilter.l"
+opt.parser=opt.parser|IPF_NO_HIT;
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 86 "ipfilter.l"
+/* ignore whitespace */
+	YY_BREAK
+case 46:
+/* rule 46 can match eol */
+YY_RULE_SETUP
+#line 87 "ipfilter.l"
+/* ignore */
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 88 "ipfilter.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", ipftext);
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 89 "ipfilter.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", ipftext);
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 91 "ipfilter.l"
+ECHO;
+	YY_BREAK
+#line 1574 "ipfilter.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ipfin at a new source and called
+			 * ipflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ipfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( ipfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * ipftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of ipflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ipfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ipfrestart(ipfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ipfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 608 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 608 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 607);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ipfrestart(ipfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( ipfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ipftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ipfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ipfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ipf_create_buffer(ipfin,YY_BUF_SIZE );
+	}
+
+	ipf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ipf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ipf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ipfpop_buffer_state();
+	 *		ipfpush_buffer_state(new_buffer);
+     */
+	ipfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ipf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (ipfwrap()) processing, but the only time this flag
+	 * is looked at is after ipfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ipf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ipfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ipf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) ipfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ipf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) ipfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ipf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ipf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ipf_create_buffer()
+ * 
+ */
+    void ipf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		ipffree((void *) b->yy_ch_buf  );
+
+	ipffree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ipfrestart() or at EOF.
+ */
+    static void ipf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ipf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ipf_init_buffer was _probably_
+     * called from ipfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ipf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ipf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ipfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ipfensure_buffer_stack();
+
+	/* This block is copied from ipf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ipf_switch_to_buffer. */
+	ipf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ipfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ipf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ipf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ipfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ipfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ipfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ipfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ipfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ipf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ipfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ipf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ipf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to ipflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ipf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ipf_scan_string (yyconst char * yystr )
+{
+    
+	return ipf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to ipflex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ipf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) ipfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ipf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ipf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ipf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ipftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ipftext[ipfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = ipftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ipfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int ipfget_lineno  (void)
+{
+        
+    return ipflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *ipfget_in  (void)
+{
+        return ipfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *ipfget_out  (void)
+{
+        return ipfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int ipfget_leng  (void)
+{
+        return ipfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *ipfget_text  (void)
+{
+        return ipftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ipfset_lineno (int  line_number )
+{
+    
+    ipflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ipf_switch_to_buffer
+ */
+void ipfset_in (FILE *  in_str )
+{
+        ipfin = in_str ;
+}
+
+void ipfset_out (FILE *  out_str )
+{
+        ipfout = out_str ;
+}
+
+int ipfget_debug  (void)
+{
+        return ipf_flex_debug;
+}
+
+void ipfset_debug (int  bdebug )
+{
+        ipf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ipflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ipfin = stdin;
+    ipfout = stdout;
+#else
+    ipfin = (FILE *) 0;
+    ipfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ipflex_init()
+     */
+    return 0;
+}
+
+/* ipflex_destroy is for both reentrant and non-reentrant scanners. */
+int ipflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ipf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ipfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ipffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ipflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *ipfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *ipfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void ipffree (void * ptr )
+{
+	free( (char *) ptr );	/* see ipfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 91 "ipfilter.l"
+
+
+
+void ipf_parse_date(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 6)
+    return;
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | IPF_DATE;
+}
+
+void ipf_parse_data(char *input, unsigned char mode)
+{
+  int retval;
+
+  if (mode == IPF_OPT_COUNT) {
+    retval = sscanf(input, "%dx %" SHORTLEN_S "s @%" SHORTLEN_S "s %" SHORTLEN_S "s", &opt.line->count, opt.line->interface, opt.line->chainlabel, opt.line->branchname);
+    if (retval != 4)
+      return;
+  } else {
+    retval = sscanf(input, "%" SHORTLEN_S "s @%" SHORTLEN_S "s %" SHORTLEN_S "s", opt.line->interface, opt.line->chainlabel, opt.line->branchname);
+    if (retval != 3)
+      return;
+
+    opt.line->count = 1;
+  }
+
+  opt.parser = opt.parser | IPF_DATA;
+}
+
+void ipf_parse_ips(char *input, unsigned char mode)
+{
+  int host1, host2, host3, host4, port;
+  int retval;
+  char ip[IPLEN];
+
+  if (mode == (IPF_OPT_SRC | IPF_OPT_RES | IPF_OPT_RPORT) || mode == (IPF_OPT_DST | IPF_OPT_RES | IPF_OPT_RPORT)) {
+    char name[255], *ptr, portname[32];
+    ptr = strchr(input, '[');
+    *ptr = ' ';
+    retval = sscanf(input, "%255s %3d.%3d.%3d.%3d],%32s", name, &host1, &host2, &host3, &host4, portname);
+    if (retval != 6)
+      return;
+  } else if (mode == (IPF_OPT_SRC | IPF_OPT_RES | IPF_OPT_PORT) || mode == (IPF_OPT_DST | IPF_OPT_RES | IPF_OPT_PORT)) {
+    char name[255], *ptr;
+    ptr = strchr(input, '[');
+    *ptr = ' ';
+    retval = sscanf(input, "%255s %3d.%3d.%3d.%3d],%5d", name, &host1, &host2, &host3, &host4, &port);
+    if (retval != 6)
+      return;
+  } else if (mode == (IPF_OPT_SRC | IPF_OPT_RES) || mode == (IPF_OPT_DST | IPF_OPT_RES)) {
+    char name[255], *ptr;
+    ptr = strchr(input, '[');
+    *ptr = ' ';
+    retval = sscanf(input, "%255s %3d.%3d.%3d.%3d]", name, &host1, &host2, &host3, &host4);
+    if (retval != 5)
+      return;
+  } else if (mode == (IPF_OPT_SRC | IPF_OPT_RPORT) || mode == (IPF_OPT_DST | IPF_OPT_RPORT)) {
+    char portname[32];
+    retval = sscanf(input, "%3d.%3d.%3d.%3d,%32s", &host1, &host2, &host3, &host4, portname);
+    if (retval != 5)
+      return;
+  } else if (mode == (IPF_OPT_SRC | IPF_OPT_PORT) || mode == (IPF_OPT_DST | IPF_OPT_PORT)) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d,%5d", &host1, &host2, &host3, &host4, &port);
+    if (retval != 5)
+      return;
+  } else if (mode == IPF_OPT_SRC || mode == IPF_OPT_DST) {
+    retval = sscanf(input, "%3d.%3d.%3d.%3d", &host1, &host2, &host3, &host4);
+    if (retval != 4)
+      return;
+  } else {
+    return;
+  }
+
+  snprintf(ip, IPLEN, "%d.%d.%d.%d", host1, host2, host3, host4);
+  if (mode & IPF_OPT_SRC) {
+    if (convert_ip(ip, &opt.line->shost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | IPF_SRC_IP;
+    if (mode & IPF_OPT_PORT) {
+      opt.line->sport = port;
+      opt.parser = opt.parser | IPF_SRC_PORT;
+    }
+  } else {
+    if (convert_ip(ip, &opt.line->dhost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | IPF_DST_IP;
+    if (mode & IPF_OPT_PORT) {
+      opt.line->dport = port;
+      opt.parser = opt.parser | IPF_DST_PORT;
+    }
+  }
+}
+
+void ipf_parse_proto(char *input)
+{
+  if (isdigit((int) input[0])) {
+    opt.line->protocol = atoi(input);
+  } else {
+    struct protoent *proto;
+
+    proto = getprotobyname(input);
+    if (proto != NULL)
+      opt.line->protocol = proto->p_proto;
+  }
+
+  if (opt.line->protocol != 0) {
+    opt.parser = opt.parser | IPF_PROTO;
+  } else {
+    fprintf(stderr, "Unknown protocol (not in /etc/protocols), ignoring: %s\n", input);
+    opt.parser = opt.parser | IPF_NO_HIT;
+  }
+}
+
+void ipf_parse_flags(char *input)
+{
+  while (*input != '\0') {
+    if (*input == 'S')
+      opt.line->flags = opt.line->flags | TCP_SYN;
+    if (*input == 'A')
+      opt.line->flags = opt.line->flags | TCP_ACK;
+    if (*input == 'F')
+      opt.line->flags = opt.line->flags | TCP_FIN;
+    if (*input == 'R')
+      opt.line->flags = opt.line->flags | TCP_RST;
+    if (*input == 'P')
+      opt.line->flags = opt.line->flags | TCP_PSH;
+    if (*input == 'U')
+      opt.line->flags = opt.line->flags | TCP_URG;
+    input++;
+  }
+}
+
+unsigned char flex_ipfilter(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  ipf_scan_string(input);
+  ipflex();
+  ipf_delete_buffer(YY_CURRENT_BUFFER);
+
+  if (opt.parser & IPF_NO_HIT)
+    return PARSE_NO_HIT;
+
+  if (opt.parser == (IPF_DATE | IPF_DATA | IPF_PROTO | IPF_SRC_IP | IPF_DST_IP | IPF_SRC_PORT | IPF_DST_PORT)) {
+    return PARSE_OK;
+  } else {
+    if (opt.verbose)
+      fprintf(stderr, "ipfilter parse error in line %d, ignoring.\n", linenum);
+    if (opt.verbose == 2)
+      fprintf(stderr, "input was: \"%s\"\n", input);
+    return PARSE_WRONG_FORMAT;
+  }
+}
+
diff -Naur fwlogwatch-1.2.orig/ipfw.c fwlogwatch-1.2/ipfw.c
--- fwlogwatch-1.2.orig/ipfw.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/ipfw.c	2011-09-08 11:36:06.551477369 +0200
@@ -0,0 +1,2007 @@
+#line 2 "ipfw.c"
+
+#line 4 "ipfw.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer ipfw_create_buffer
+#define yy_delete_buffer ipfw_delete_buffer
+#define yy_flex_debug ipfw_flex_debug
+#define yy_init_buffer ipfw_init_buffer
+#define yy_flush_buffer ipfw_flush_buffer
+#define yy_load_buffer_state ipfw_load_buffer_state
+#define yy_switch_to_buffer ipfw_switch_to_buffer
+#define yyin ipfwin
+#define yyleng ipfwleng
+#define yylex ipfwlex
+#define yylineno ipfwlineno
+#define yyout ipfwout
+#define yyrestart ipfwrestart
+#define yytext ipfwtext
+#define yywrap ipfwwrap
+#define yyalloc ipfwalloc
+#define yyrealloc ipfwrealloc
+#define yyfree ipfwfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ipfwrestart(ipfwin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ipfwleng;
+
+extern FILE *ipfwin, *ipfwout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ipfwtext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ipfwtext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ipfwrestart()), so that the user can continue scanning by
+	 * just pointing ipfwin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when ipfwtext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int ipfwleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow ipfwwrap()'s to do buffer switches
+ * instead of setting up a fresh ipfwin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void ipfwrestart (FILE *input_file  );
+void ipfw_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ipfw_create_buffer (FILE *file,int size  );
+void ipfw_delete_buffer (YY_BUFFER_STATE b  );
+void ipfw_flush_buffer (YY_BUFFER_STATE b  );
+void ipfwpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ipfwpop_buffer_state (void );
+
+static void ipfwensure_buffer_stack (void );
+static void ipfw_load_buffer_state (void );
+static void ipfw_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ipfw_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ipfw_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ipfw_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ipfw_scan_bytes (yyconst char *bytes,int len  );
+
+void *ipfwalloc (yy_size_t  );
+void *ipfwrealloc (void *,yy_size_t  );
+void ipfwfree (void *  );
+
+#define yy_new_buffer ipfw_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ipfwensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ipfw_create_buffer(ipfwin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ipfwensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ipfw_create_buffer(ipfwin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define ipfwwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *ipfwin = (FILE *) 0, *ipfwout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int ipfwlineno;
+
+int ipfwlineno = 1;
+
+extern char *ipfwtext;
+#define yytext_ptr ipfwtext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up ipfwtext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	ipfwleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 16
+#define YY_END_OF_BUFFER 17
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[159] =
+    {   0,
+        0,    0,   17,   15,   13,   12,   15,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,    0,    0,    0,    0,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,    0,    0,    0,    0,   14,   14,   14,   14,
+       14,    7,    0,    0,    0,    0,    0,   14,    0,   14,
+        4,   14,    0,    0,    0,    0,    0,   14,    0,    0,
+        5,    0,    0,    0,    0,    0,    0,    6,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    3,
+        0,    0,    0,    0,    0,    8,   11,    0,    0,    0,
+
+        0,    0,   11,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    9,    0,    0,    0,
+        1,    2,    9,    0,    0,    1,    9,    0,    0,    0,
+        0,    0,   10,   10,   10,   10,   10,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    1,    1,    1,    1,    1,    1,    4,
+        4,    1,    1,    1,    5,    6,    1,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    8,    1,    1,
+        1,    1,    1,    1,    9,   10,   11,   12,   10,   13,
+       10,   10,   14,   15,   10,   10,   16,   17,   18,   19,
+       10,   10,   20,   21,   22,   10,   10,   10,   10,   10,
+        1,    1,    1,    1,    4,    1,   23,   24,   25,   10,
+
+       26,   27,   28,   10,   29,   10,   30,   31,   10,   32,
+       33,   34,   10,   35,   10,   36,   37,   38,   39,   10,
+       40,   10,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[41] =
+    {   0,
+        1,    1,    1,    2,    3,    3,    3,    2,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4
+    } ;
+
+static yyconst flex_int16_t yy_base[163] =
+    {   0,
+        0,    0,  227,  228,  228,   12,   37,   20,    0,  193,
+      199,  198,  212,   23,  199,  188,  195,  193,  207,  205,
+      184,  181,  188,  206,   41,    0,  187,  176,  182,  172,
+       24,  184,  191,  174,   19,   18,  167,  168,  169,  183,
+      182,  197,  172,  163,   55,  191,  170,  192,  162,  153,
+      173,    0,  153,  151,  157,  181,   57,  153,   52,  150,
+        0,  177,  155,  175,  156,   59,  175,  144,  172,   64,
+        0,  171,  154,  173,  144,  167,   62,    0,  166,  169,
+       66,  168,  163,  161,   67,  162,  160,  159,    0,  158,
+      161,  156,   73,  155,  153,  153,    0,  130,   71,   76,
+
+       79,  151,    0,  123,  149,   81,  148,   82,  147,  126,
+       84,  146,   86,   91,  143,  111,  142,   89,  141,   93,
+       94,  140,  138,   96,  139,   98,  138,  140,  135,  138,
+      133,  100,  132,  102,  135,  130,  129,  129,  104,  128,
+        0,  126,  125,  124,  106,    0,  228,  107,  124,  109,
+      122,  120,  120,  119,  118,   76,  228,  228,  115,   48,
+      117,  120
+    } ;
+
+static yyconst flex_int16_t yy_def[163] =
+    {   0,
+      158,    1,  158,  158,  158,  158,  158,  159,  159,  159,
+      159,  159,  159,  159,  159,  159,  159,  159,  159,  159,
+      159,  158,  158,  158,  158,  159,  159,  159,  159,  159,
+      159,  159,  159,  159,  159,  159,  159,  159,  159,  159,
+      159,  159,  158,  158,  158,  158,  159,  159,  159,  159,
+      159,  159,  158,  158,  158,  158,  158,  159,  158,  159,
+      159,  159,  158,  158,  158,  158,  158,  159,  158,  158,
+      159,  158,  158,  158,  158,  158,  158,  159,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  160,  158,
+      158,  158,  158,  158,  158,  158,  161,  158,  158,  158,
+
+      158,  158,  161,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      162,  158,  158,  158,  158,  162,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,    0,  158,  158,
+      158,  158
+    } ;
+
+static yyconst flex_int16_t yy_nxt[269] =
+    {   0,
+        4,    5,    6,    4,    4,    4,    7,    4,    8,    9,
+       10,   11,   12,   13,   14,   15,   16,   17,    9,   18,
+       19,   20,    9,    9,    9,    9,    9,    9,   21,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+       22,   23,   24,   25,   27,   34,   24,   46,   48,   48,
+       48,   97,   48,   28,   69,   50,   29,   48,   70,   35,
+       56,   57,   56,   67,   76,   77,   79,   76,   86,   92,
+       80,   88,   81,   93,   94,   92,  105,  106,   92,  100,
+       94,  107,  157,   94,  107,  108,  105,  112,  114,  117,
+      118,  119,  120,  107,  117,  125,  107,  121,  119,  127,
+
+      128,  131,  132,  133,  134,  131,  138,  133,  140,  144,
+      145,  144,  149,  150,  151,  152,  151,   26,   26,  103,
+      103,  146,  146,  146,  156,  155,  154,  151,  153,  144,
+      148,  147,  142,  133,  131,  143,  142,  141,  139,  137,
+      136,  135,  107,  119,  117,  130,  129,  126,  124,  123,
+      122,  105,  116,  115,  113,  111,  110,  109,  104,   96,
+      102,  101,   99,   98,   90,   96,   95,   76,   91,   90,
+       89,   79,   87,   85,   84,   83,   82,   81,   70,   78,
+       56,   75,   74,   73,   72,   71,   68,   66,   65,   64,
+       63,   62,   61,   60,   59,   58,   24,   55,   54,   53,
+
+       52,   52,   48,   48,   48,   48,   51,   48,   49,   48,
+       48,   47,   45,   44,   43,   42,   41,   40,   39,   38,
+       37,   36,   33,   32,   31,   30,  158,    3,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158
+    } ;
+
+static yyconst flex_int16_t yy_chk[269] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        6,    6,    7,    7,    8,   14,   25,   25,   31,   35,
+       35,  160,   36,    8,   59,   31,    8,   36,   59,   14,
+       45,   45,   57,   57,   66,   66,   70,   77,   77,   85,
+       70,   81,   81,   85,   85,   93,   99,   99,  100,   93,
+       93,  101,  156,  100,  108,  101,  106,  106,  108,  111,
+      111,  113,  113,  114,  118,  118,  121,  114,  120,  120,
+
+      121,  124,  124,  126,  126,  132,  132,  134,  134,  139,
+      139,  145,  145,  148,  148,  150,  150,  159,  159,  161,
+      161,  162,  162,  162,  155,  154,  153,  152,  151,  149,
+      144,  143,  142,  140,  138,  137,  136,  135,  133,  131,
+      130,  129,  128,  127,  125,  123,  122,  119,  117,  116,
+      115,  112,  110,  109,  107,  105,  104,  102,   98,   96,
+       95,   94,   92,   91,   90,   88,   87,   86,   84,   83,
+       82,   80,   79,   76,   75,   74,   73,   72,   69,   68,
+       67,   65,   64,   63,   62,   60,   58,   56,   55,   54,
+       53,   51,   50,   49,   48,   47,   46,   44,   43,   42,
+
+       41,   40,   39,   38,   37,   34,   33,   32,   30,   29,
+       28,   27,   24,   23,   22,   21,   20,   19,   18,   17,
+       16,   15,   13,   12,   11,   10,    3,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
+      158,  158,  158,  158,  158,  158,  158,  158
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int ipfw_flex_debug;
+int ipfw_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *ipfwtext;
+#line 1 "ipfw.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: ipfw.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "ipfw.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void ipfw_parse_start(char *input);
+void ipfw_parse_proto(char *input, unsigned char mode);
+void ipfw_parse_ips(char *input, unsigned char mode);
+#line 606 "ipfw.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int ipfwlex_destroy (void );
+
+int ipfwget_debug (void );
+
+void ipfwset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE ipfwget_extra (void );
+
+void ipfwset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *ipfwget_in (void );
+
+void ipfwset_in  (FILE * in_str  );
+
+FILE *ipfwget_out (void );
+
+void ipfwset_out  (FILE * out_str  );
+
+int ipfwget_leng (void );
+
+char *ipfwget_text (void );
+
+int ipfwget_lineno (void );
+
+void ipfwset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int ipfwwrap (void );
+#else
+extern int ipfwwrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( ipfwtext, ipfwleng, 1, ipfwout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( ipfwin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( ipfwin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, ipfwin))==0 && ferror(ipfwin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(ipfwin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int ipfwlex (void);
+
+#define YY_DECL int ipfwlex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after ipfwtext and ipfwleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 33 "ipfw.l"
+
+
+#line 794 "ipfw.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! ipfwin )
+			ipfwin = stdin;
+
+		if ( ! ipfwout )
+			ipfwout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			ipfwensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ipfw_create_buffer(ipfwin,YY_BUF_SIZE );
+		}
+
+		ipfw_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of ipfwtext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 159 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 158 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 35 "ipfw.l"
+ipfw_parse_start(ipfwtext);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 36 "ipfw.l"
+{ xstrncpy(opt.line->chainlabel, ipfwtext+15, SHORTLEN); opt.parser=opt.parser|IPFW_CHAIN; };
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 37 "ipfw.l"
+{ xstrncpy(opt.line->chainlabel, ipfwtext+7, SHORTLEN); opt.parser=opt.parser|IPFW_CHAIN; };
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 38 "ipfw.l"
+{ xstrncpy(opt.line->branchname, ipfwtext, SHORTLEN); opt.parser=opt.parser|IPFW_BRANCH; };
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 39 "ipfw.l"
+{ xstrncpy(opt.line->branchname, ipfwtext, SHORTLEN); opt.parser=opt.parser|IPFW_BRANCH; };
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 40 "ipfw.l"
+{ xstrncpy(opt.line->branchname, ipfwtext, SHORTLEN); opt.parser=opt.parser|IPFW_BRANCH; };
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 41 "ipfw.l"
+ipfw_parse_proto(ipfwtext, IPFW_OPT_NONE);
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 42 "ipfw.l"
+ipfw_parse_proto(ipfwtext+5, IPFW_OPT_ICMP);
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 43 "ipfw.l"
+ipfw_parse_ips(ipfwtext, IPFW_OPT_NONE);
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 44 "ipfw.l"
+ipfw_parse_ips(ipfwtext, IPFW_OPT_PORTS);
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 45 "ipfw.l"
+{ xstrncpy(opt.line->interface, ipfwtext+7, SHORTLEN); opt.parser=opt.parser|IPFW_IF; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 46 "ipfw.l"
+/* ignore whitespace */
+	YY_BREAK
+case 13:
+/* rule 13 can match eol */
+YY_RULE_SETUP
+#line 47 "ipfw.l"
+return 0;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 48 "ipfw.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", ipfwtext);
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 49 "ipfw.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", ipfwtext);
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 51 "ipfw.l"
+ECHO;
+	YY_BREAK
+#line 954 "ipfw.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ipfwin at a new source and called
+			 * ipfwlex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ipfwin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( ipfwwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * ipfwtext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of ipfwlex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ipfwrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ipfwrestart(ipfwin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ipfwrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 159 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 159 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 158);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ipfwrestart(ipfwin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( ipfwwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ipfwtext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ipfwrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ipfwensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ipfw_create_buffer(ipfwin,YY_BUF_SIZE );
+	}
+
+	ipfw_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ipfw_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ipfw_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ipfwpop_buffer_state();
+	 *		ipfwpush_buffer_state(new_buffer);
+     */
+	ipfwensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ipfw_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (ipfwwrap()) processing, but the only time this flag
+	 * is looked at is after ipfwwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ipfw_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ipfwin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ipfw_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) ipfwalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ipfw_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) ipfwalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ipfw_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ipfw_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ipfw_create_buffer()
+ * 
+ */
+    void ipfw_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		ipfwfree((void *) b->yy_ch_buf  );
+
+	ipfwfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ipfwrestart() or at EOF.
+ */
+    static void ipfw_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ipfw_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ipfw_init_buffer was _probably_
+     * called from ipfwrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ipfw_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ipfw_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ipfwpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ipfwensure_buffer_stack();
+
+	/* This block is copied from ipfw_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ipfw_switch_to_buffer. */
+	ipfw_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ipfwpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ipfw_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ipfw_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ipfwensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ipfwalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ipfwensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ipfwrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in ipfwensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ipfw_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ipfwalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ipfw_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ipfw_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to ipfwlex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ipfw_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ipfw_scan_string (yyconst char * yystr )
+{
+    
+	return ipfw_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to ipfwlex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ipfw_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) ipfwalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ipfw_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ipfw_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ipfw_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ipfwtext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ipfwtext[ipfwleng] = (yy_hold_char); \
+		(yy_c_buf_p) = ipfwtext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ipfwleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int ipfwget_lineno  (void)
+{
+        
+    return ipfwlineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *ipfwget_in  (void)
+{
+        return ipfwin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *ipfwget_out  (void)
+{
+        return ipfwout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int ipfwget_leng  (void)
+{
+        return ipfwleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *ipfwget_text  (void)
+{
+        return ipfwtext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ipfwset_lineno (int  line_number )
+{
+    
+    ipfwlineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ipfw_switch_to_buffer
+ */
+void ipfwset_in (FILE *  in_str )
+{
+        ipfwin = in_str ;
+}
+
+void ipfwset_out (FILE *  out_str )
+{
+        ipfwout = out_str ;
+}
+
+int ipfwget_debug  (void)
+{
+        return ipfw_flex_debug;
+}
+
+void ipfwset_debug (int  bdebug )
+{
+        ipfw_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ipfwlex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ipfwin = stdin;
+    ipfwout = stdout;
+#else
+    ipfwin = (FILE *) 0;
+    ipfwout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ipfwlex_init()
+     */
+    return 0;
+}
+
+/* ipfwlex_destroy is for both reentrant and non-reentrant scanners. */
+int ipfwlex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ipfw_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ipfwpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ipfwfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ipfwlex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *ipfwalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *ipfwrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void ipfwfree (void * ptr )
+{
+	free( (char *) ptr );	/* see ipfwrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 51 "ipfw.l"
+
+
+
+void ipfw_parse_start(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 6) {
+    return;
+  }
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | IPFW_DATE;
+}
+
+void ipfw_parse_proto(char *input, unsigned char mode)
+{
+  int retval;
+  char *pnt;
+
+  if (mode == IPFW_OPT_NONE) {
+    if (strncmp(input, "TCP", 3) == 0)
+      opt.line->protocol = 6;
+    if (strncmp(input, "UDP", 3) == 0)
+      opt.line->protocol = 17;
+  } else if (mode == IPFW_OPT_ICMP) {
+    opt.line->protocol = 1;
+    pnt = strstr(input, ".");
+    *pnt = ' ';
+    retval = sscanf(input, "%2d %2d", &opt.line->sport, &opt.line->dport);
+    if (retval != 2) {
+      return;
+    }
+    opt.parser = opt.parser | IPFW_PORTS;
+  }
+  if (opt.line->protocol != 0) {
+    opt.parser = opt.parser | IPFW_PROTO;
+  }
+}
+
+void ipfw_parse_ips(char *input, unsigned char mode)
+{
+  int retval;
+  char src[16], dst[16], *pnt;
+
+  if (mode == IPFW_OPT_PORTS) {
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    pnt = strstr(input, ":");
+    *pnt = ' ';
+    retval = sscanf(input, "%16s %5d %16s %5d", src, &opt.line->sport, dst, &opt.line->dport);
+    if (retval != 4) {
+      return;
+    }
+    opt.parser = opt.parser | IPFW_PORTS;
+  } else if (mode == IPFW_OPT_NONE) {
+    retval = sscanf(input, "%16s %16s", src, dst);
+    if (retval != 2) {
+      return;
+    }
+  }
+
+  if (convert_ip(src, &opt.line->shost) == IN_ADDR_ERROR)
+    return;
+  if (convert_ip(dst, &opt.line->dhost) == IN_ADDR_ERROR)
+    return;
+  opt.parser = opt.parser | IPFW_IPS;
+}
+
+unsigned char flex_ipfw(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  ipfw_scan_string(input);
+  ipfwlex();
+  ipfw_delete_buffer(YY_CURRENT_BUFFER);
+
+  opt.line->count = 1;
+
+  if (opt.parser == (IPFW_DATE | IPFW_CHAIN | IPFW_BRANCH | IPFW_PROTO | IPFW_IPS | IPFW_PORTS | IPFW_IF)) {
+    return PARSE_OK;
+  }
+  if (opt.verbose)
+    fprintf(stderr, "ipfw parse error in line %d, ignoring.\n", linenum);
+  if (opt.verbose == 2)
+    fprintf(stderr, "input was: \"%s\"\n", input);
+  return PARSE_WRONG_FORMAT;
+}
+
diff -Naur fwlogwatch-1.2.orig/netfilter.c fwlogwatch-1.2/netfilter.c
--- fwlogwatch-1.2.orig/netfilter.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/netfilter.c	2011-09-08 11:36:12.991497639 +0200
@@ -0,0 +1,2971 @@
+#line 2 "netfilter.c"
+
+#line 4 "netfilter.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer nf_create_buffer
+#define yy_delete_buffer nf_delete_buffer
+#define yy_flex_debug nf_flex_debug
+#define yy_init_buffer nf_init_buffer
+#define yy_flush_buffer nf_flush_buffer
+#define yy_load_buffer_state nf_load_buffer_state
+#define yy_switch_to_buffer nf_switch_to_buffer
+#define yyin nfin
+#define yyleng nfleng
+#define yylex nflex
+#define yylineno nflineno
+#define yyout nfout
+#define yyrestart nfrestart
+#define yytext nftext
+#define yywrap nfwrap
+#define yyalloc nfalloc
+#define yyrealloc nfrealloc
+#define yyfree nffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE nfrestart(nfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int nfleng;
+
+extern FILE *nfin, *nfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up nftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up nftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via nfrestart()), so that the user can continue scanning by
+	 * just pointing nfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when nftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int nfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow nfwrap()'s to do buffer switches
+ * instead of setting up a fresh nfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void nfrestart (FILE *input_file  );
+void nf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE nf_create_buffer (FILE *file,int size  );
+void nf_delete_buffer (YY_BUFFER_STATE b  );
+void nf_flush_buffer (YY_BUFFER_STATE b  );
+void nfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void nfpop_buffer_state (void );
+
+static void nfensure_buffer_stack (void );
+static void nf_load_buffer_state (void );
+static void nf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER nf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE nf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE nf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE nf_scan_bytes (yyconst char *bytes,int len  );
+
+void *nfalloc (yy_size_t  );
+void *nfrealloc (void *,yy_size_t  );
+void nffree (void *  );
+
+#define yy_new_buffer nf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        nfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            nf_create_buffer(nfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        nfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            nf_create_buffer(nfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define nfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *nfin = (FILE *) 0, *nfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int nflineno;
+
+int nflineno = 1;
+
+extern char *nftext;
+#define yytext_ptr nftext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up nftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	nfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 63
+#define YY_END_OF_BUFFER 64
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[622] =
+    {   0,
+        0,    0,   64,   62,   60,   59,   62,   61,   61,   61,
+       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
+       61,   61,   61,   61,   61,   61,   61,   62,   59,    0,
+        0,    0,    0,    0,    0,   61,   61,   61,   61,   27,
+       61,   61,   28,   61,   61,   61,   61,   61,   61,   61,
+       61,   61,   61,   61,   61,   61,   61,   61,   61,   29,
+       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
+       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
+       61,   61,    0,    0,    0,    0,    0,    0,   43,   61,
+       61,   49,   61,   61,   48,   47,   61,   61,   61,   61,
+
+        0,   14,   61,   61,   61,   61,   61,   61,   61,   61,
+       61,   61,   44,   61,   45,   61,   61,   61,   61,   46,
+        0,   61,   61,   61,   42,   61,   57,    0,    0,    0,
+        0,    0,    0,    0,   61,    0,    0,   61,   61,   61,
+       61,   26,   14,   61,    0,   18,   61,    0,    0,   15,
+       61,   61,   61,    0,    0,    0,    0,    0,   54,    0,
+        0,   61,   61,   61,   13,    0,    0,    0,    0,    0,
+       37,    0,    0,    0,   39,    0,   61,    0,   61,   61,
+       14,   61,   22,    0,    0,   58,    0,   15,   61,   61,
+        0,   61,    0,   35,    0,   38,    0,    0,   25,    0,
+
+        0,   61,   13,   13,   13,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   34,
+       39,    0,    0,   61,   30,   61,   61,   61,    0,    0,
+       51,    0,   15,   61,   61,    0,    0,    0,    0,   38,
+        0,    0,   23,    0,   33,   50,   61,   13,   13,   13,
+       13,   13,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   39,    0,    0,
+       61,   61,   61,   61,    0,    0,   16,   61,    0,   31,
+        0,    0,    0,    0,    0,   41,   52,   38,    0,    0,
+       23,    0,    0,    0,    0,    0,    0,    0,   39,    0,
+
+        0,    0,    0,   61,   61,    0,   36,   16,   17,   24,
+       31,    0,    0,    0,    0,   38,    0,    0,   40,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   39,    0,
+        0,   56,    0,    0,   61,    0,   16,   17,    0,   38,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       55,   61,    0,   17,   31,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   11,    0,    0,
+        0,    0,    0,   21,    0,    0,    0,    0,    0,    0,
+       20,    0,    0,    0,    0,    0,    0,    7,    0,    0,
+
+       12,   11,   11,   11,   13,    0,    0,    0,   21,    0,
+        0,    0,    0,   20,    0,    9,    0,    8,    7,    7,
+        7,   13,    0,   12,   12,   12,   11,   11,   11,   11,
+       11,   13,   13,   13,    0,    0,    0,   21,    0,    0,
+        0,    0,   20,   10,    9,    9,    9,   13,    8,    8,
+        8,    7,    7,    7,    7,    7,   13,   13,   13,    0,
+       12,   12,   12,   12,   12,   13,   13,   13,   13,   13,
+        0,    0,    2,    0,    0,    0,    0,   10,   10,   10,
+        9,    9,    9,    9,    9,   13,   13,   13,    8,    8,
+        8,    8,    8,   13,   13,   13,   13,   13,    0,    0,
+
+        0,    0,   53,    0,    0,    0,   10,   10,   10,   10,
+       10,   13,   13,   13,   13,   13,    0,    0,    0,    1,
+       53,    0,    0,    0,    0,    0,   53,    0,    0,    0,
+        0,    0,    0,    0,    0,    4,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   32,    0,    0,    0,    0,
+        3,    5,    0,    0,    8,    0,    6,    8,    8,    8,
+        0,    6,    6,    6,    8,    8,    8,    8,    8,    0,
+        6,    6,    6,    6,    6,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   19,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   18,
+        0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    4,    4,    4,    4,    4,    4,    4,    5,
+        6,    4,    4,    4,    7,    8,    4,    9,   10,   10,
+       10,   10,   10,   11,   10,   10,   10,   12,    4,    4,
+       13,    4,    4,    4,   14,   15,   16,   17,   18,   19,
+       20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
+       30,   31,   32,   33,   34,   35,   36,   35,   37,   35,
+       38,    4,   39,    4,   40,    4,   41,   42,   43,   44,
+
+       45,   46,   47,   35,   35,   35,   48,   49,   35,   50,
+       51,   52,   35,   53,   54,   55,   56,   57,   35,   58,
+       59,   35,    4,    4,    4,    4,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4
+    } ;
+
+static yyconst flex_int32_t yy_meta[60] =
+    {   0,
+        1,    2,    3,    3,    4,    5,    6,    6,    7,    7,
+        7,    4,    3,    8,    8,    8,    8,    8,    8,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    3,    3,    4,
+       10,   10,   10,   10,   10,   10,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9
+    } ;
+
+static yyconst flex_int16_t yy_base[714] =
+    {   0,
+        0,    0, 1298, 2412, 2412,   57,   52,   48,    0,   47,
+       47, 1281,   46, 1282, 1267,   53,   26, 1276,   55, 1242,
+       44,   76,   54,   72,   65, 1261, 1269,    0,   96,   84,
+     1253,   88,   89,   90,  104,    0, 1265, 1235, 1240,    0,
+     1269, 1253,    0, 1250, 1249, 1238, 1262, 1252, 1250, 1263,
+     1232, 1240, 1243, 1258,  103, 1220,   35, 1234,  107,    0,
+     1226,   69, 1202, 1225, 1224, 1201, 1218,  106, 1233, 1221,
+     1219, 1221,  107, 1234, 1222, 1196, 1233, 1213, 1219, 1214,
+     1222, 1214, 1201,  109,  108,  110,  119,  133, 1226, 1220,
+     1204,    0, 1208, 1207,    0,    0, 1183, 1198, 1199, 1191,
+
+      139,    0, 1187, 1200, 1199, 1187, 1197, 1205, 1194, 1174,
+     1189, 1171,    0, 1190,    0, 1189, 1188, 1185, 1184,    0,
+      148, 1183, 1182, 1176, 1156, 1167, 1144,  138,  130,  132,
+      139,  152,  162,  178, 1169,  168,  181, 1156, 1168, 1143,
+     1156,  184,    0, 1151,  187,    0, 1163,  190, 1170,    0,
+      140, 1161, 1145, 1163,  193, 1161,  196,  199,  202, 1160,
+      205, 1155, 1154, 1138,  214,  206,  210,  213,  244,  220,
+      228,  231,  270,  235,  255,  274, 1150,  277, 1150, 1137,
+        0, 1131,  280,    0, 1150,  283, 1152,    0, 1130, 1122,
+     1138, 1133, 1087,  286, 1086,  289,  293,  175,  296,  299,
+
+      302, 1107,  311,  349,  153,  297,  298,  237,  266, 1097,
+     1096,  219, 1099, 1088, 1094, 1091,  316,  319, 1132,  327,
+      330,  334,  348, 1109,  354, 1095, 1109, 1105, 1117, 1070,
+     2412, 1121,    0, 1113, 1092, 1064,  359,    0,    0,  369,
+      373,  386, 2412,    0,  389,  392, 1108, 1093,    0,  340,
+      221,  363,  369,  309,  401, 1066, 1071, 1066, 1066, 1057,
+      116,  209, 1049, 1050, 1052, 1091,  398,  401,  405, 1094,
+     1088, 1087, 1066, 1080,    0,    0,    0, 1084,    0,  410,
+     1075, 1062, 1077, 1076, 1074,    0,    0,  415,  419, 1082,
+        0,  422,  400,  414,  412, 1086,  431, 1076,  436,  443,
+
+      447,  450,  453, 1074, 1051,    0,    0,    0,    0,    0,
+     2412, 1054, 1056, 1052, 1042,  456,  459,  463,  466,  475,
+      457,  338,  459,  413,  461,  481,  490,  493, 2412,  497,
+     1062,  500,  505,  508, 1051, 1056,    0,    0, 1038, 2412,
+      512, 1056,  502,  503,  504,  505,  506,  526,  522,  532,
+      524, 1025,  546,  555, 1054,  561,  564,  568,  571,  575,
+      578, 1057,    0,    0,  994,  581,  585,  510,  575,  530,
+      576,  577,  587,  579,  992,  609,  608,  644,  621,  616,
+     1024,  626, 1013,  629, 1006,  651,  987,  950,    0,  969,
+      654,  961,  648,  654,  650,  917,  656,  691,  695,  696,
+
+      731,  769,  807,  416,  845,  679,  700,  705,  710,  713,
+      737,  716,  940,  740,  739,  883,  741,  921,  959,  997,
+      453, 1035,  755, 1073, 1111,  455,  908,    0,  578,  602,
+      601, 1149, 1187,  641,  907,  906,  746, 2412,  775,  908,
+      784,    0, 2412, 1225, 1263, 1301,  647, 1339, 1377, 1415,
+      735,  883,    0,  769,  775,  776, 1453, 1491,  772,  805,
+      882,    0,  773,  804,  796,  854,    0,  794,  809,  803,
+      749,  828,  876,  850,  854,  836,    0, 1529, 1567,  801,
+      816,    0,  808,  853,  846, 1605, 1643,  842,  814,    0,
+      843,  884,  849,  805,    0,  845,  885,  877,  929,  891,
+
+      897,    0,  904,  816,  738,  778,  762,    0,  909,  890,
+      915,  753,    0,  917,  940,  923,  946,  767,  700,    0,
+      937,  637,    0,  967,  964,  975, 2412,  641,    0,  968,
+      982, 1002,  626,  659,  984,  641,  639,  602,    0,  531,
+      993,  585,  986,    0,    0, 2412,    0,  995,  957,  596,
+        0,    0,  620, 1043, 1681,    0, 1719, 1757, 1795,  955,
+        0, 1833, 1871,  999,  584,    0, 1001, 1036, 1028,  591,
+      535,    0, 1026, 1039, 1032,    0,    0,  548,    0,    0,
+      538,    0,    0,  521,    0,    0,  518,    0,    0,  517,
+        0,    0,  476,    0,    0,  393,    0,    0,  362,    0,
+
+        0,  354,    0,    0,  320,    0,    0,  266,    0,    0,
+      265,    0,    0,  257,    0,    0,  162,    0,    0, 2412,
+     2412, 1909, 1914, 1924, 1927, 1932, 1936, 1939, 1947, 1951,
+     1957, 1960, 1968, 1972, 1976, 1980, 1984, 1988, 1991, 1995,
+     2003, 2007, 2012, 2015, 2023, 2028, 2036, 2040, 2048, 2052,
+     2060, 2068, 2076, 2084, 2092, 2100, 2108, 2116, 2124, 2132,
+     2136, 2144, 2152, 2160, 2168, 2176, 2180, 2188, 2196, 2203,
+     2207, 2211, 2219, 2223, 2230, 2237, 2241, 2249, 2253, 2261,
+     2269, 2273, 2281, 2285, 2289, 2293, 2297, 2301, 2305, 2309,
+     2313, 2317, 2321, 2325, 2329, 2333, 2337, 2341, 2345, 2349,
+
+     2353, 2357, 2361, 2365, 2369, 2373, 2377, 2381, 2385, 2389,
+     2393, 2397, 2401
+    } ;
+
+static yyconst flex_int16_t yy_def[714] =
+    {   0,
+      621,    1,  621,  621,  621,  622,  621,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  624,  622,  622,
+      622,  622,  622,  622,  621,  623,  623,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+      623,  623,  624,  622,  622,  622,  622,  621,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+
+      621,  625,  623,  623,  623,  623,  623,  623,  623,  623,
+      623,  623,  623,  623,  623,  623,  623,  623,  623,  623,
+      621,  623,  623,  623,  623,  623,  624,  622,  622,  622,
+      622,  621,  621,  621,  623,  621,  621,  623,  623,  623,
+      623,  621,  626,  623,  621,  627,  623,  621,  621,  628,
+      623,  623,  623,  621,  621,  621,  621,  621,  621,  621,
+      621,  623,  623,  623,  629,  622,  622,  622,  621,  621,
+      621,  621,  621,  621,  621,  621,  623,  621,  623,  623,
+      626,  623,  621,  630,  621,  621,  631,  632,  623,  623,
+      621,  623,  621,  621,  621,  621,  621,  621,  621,  621,
+
+      621,  623,  633,  633,  204,  622,  622,  622,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  623,  621,  623,  623,  623,  621,  621,
+      621,  631,  632,  623,  623,  621,  621,  634,  635,  621,
+      621,  621,  621,  636,  621,  621,  623,  204,  204,  204,
+      204,  204,  622,  622,  622,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      623,  623,  623,  623,  637,  638,  639,  623,  640,  621,
+      621,  621,  621,  621,  621,  634,  635,  621,  621,  621,
+      636,  621,  622,  622,  641,  621,  621,  621,  621,  621,
+
+      621,  621,  621,  623,  623,  642,  638,  643,  644,  640,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  622,
+      645,  641,  641,  641,  641,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  623,  621,  643,  646,  621,  621,
+      621,  621,  647,  645,  645,  645,  645,  645,  641,  641,
+      641,  641,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  623,  648,  646,  621,  621,  621,  647,  647,  647,
+      647,  645,  645,  645,  645,  645,  641,  649,  641,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  650,  621,
+      621,  621,  647,  647,  647,  647,  645,  651,  645,  645,
+
+      652,  653,  653,  403,  654,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  647,  655,  647,  656,  657,  657,
+      420,  658,  645,  659,  659,  425,  403,  403,  403,  403,
+      403,  660,  660,  433,  621,  621,  621,  621,  621,  621,
+      621,  661,  621,  662,  663,  663,  446,  664,  665,  665,
+      450,  420,  420,  420,  420,  420,  666,  666,  458,  645,
+      425,  425,  425,  425,  425,  433,  433,  433,  433,  433,
+      621,  621,  621,  621,  621,  621,  667,  668,  668,  479,
+      446,  446,  446,  446,  446,  669,  669,  487,  450,  450,
+      450,  450,  450,  458,  458,  458,  458,  458,  645,  621,
+
+      621,  670,  621,  621,  621,  621,  479,  479,  479,  479,
+      479,  487,  487,  487,  487,  487,  645,  621,  621,  670,
+      621,  621,  671,  645,  621,  621,  621,  621,  672,  645,
+      621,  621,  621,  621,  673,  621,  621,  621,  674,  673,
+      673,  673,  673,  675,  676,  621,  677,  673,  673,  673,
+      675,  676,  621,  673,  678,  679,  680,  681,  681,  559,
+      682,  683,  683,  563,  559,  559,  559,  559,  559,  621,
+      563,  563,  563,  563,  563,  684,  685,  621,  686,  687,
+      621,  688,  689,  621,  690,  691,  621,  692,  693,  621,
+      694,  695,  621,  696,  697,  621,  698,  699,  621,  700,
+
+      701,  621,  702,  703,  621,  704,  705,  621,  706,  707,
+      621,  708,  709,  621,  710,  711,  621,  712,  713,  621,
+        0,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621
+    } ;
+
+static yyconst flex_int16_t yy_nxt[2472] =
+    {   0,
+        4,    5,    6,    4,    4,    4,    4,    4,    7,    7,
+        7,    4,    4,    8,    9,   10,   11,   12,   13,   14,
+       15,   16,   17,    9,   18,   19,   20,   21,   22,    9,
+       23,   24,   25,   26,    9,   27,    9,   28,    4,    4,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,   29,
+       35,   35,   35,   37,   40,   43,   56,   48,   59,   54,
+       49,   70,   64,   60,   41,   44,   50,   65,   45,   55,
+       77,   57,   42,   90,   90,   71,   66,   61,   31,   72,
+       51,   46,   78,   32,   33,   62,   67,   79,   29,   38,
+
+       73,   80,   74,   39,   34,   84,   68,   69,   75,   84,
+       84,   84,   88,   88,   88,  102,   76,   84,  103,   31,
+       32,   90,  105,  111,   32,   32,   32,   90,  117,   84,
+       84,   84,   32,  112,   86,  128,   85,  106,   87,  118,
+       84,  132,  132,  132,   32,   32,   32,  142,  142,  142,
+      165,   84,  129,   84,  169,   32,  159,  159,  159,   84,
+       84,  189,  130,  170,  296,  296,   32,  190,   32,  131,
+      171,  171,  171,  618,   32,   32,  175,  175,  175,  248,
+      172,  167,  166,  243,  252,  168,  173,  173,  173,  176,
+      176,  176,  142,  142,  142,  183,  183,  183,  186,  186,
+
+      186,  194,  194,  194,  196,  196,  196,  197,  197,  197,
+      159,  159,  159,  199,  199,  199,   30,   30,   30,   30,
+       30,   30,   30,   30,   30,   30,   30,   84,  217,  217,
+      217,   84,  244,  165,   84,  204,  171,  171,  171,  173,
+      173,  173,   32,  220,  220,  220,   32,  248,  255,   32,
+      205,   30,   30,   30,  207,  206,  208,  209,   84,  260,
+      210,  296,  211,  221,  221,  221,  212,  296,  615,  213,
+      214,  215,  218,   32,  261,  216,  612,  609,  219,  219,
+      219,  222,  223,  223,  223,  225,  225,  225,  183,  183,
+      183,  186,  186,  186,  194,  194,  194,  240,  240,  240,
+
+      241,  242,  242,  242,  199,  199,  199,  245,  245,  245,
+      246,  246,  246,   30,   30,   30,   30,  256,   84,   84,
+      294,  257,   30,   30,  266,  266,  266,  267,  267,  267,
+       84,  606,  249,   32,   32,  220,  220,  220,  268,  268,
+      268,  253,  269,  269,  269,   32,  254,  250,   30,   30,
+       30,   30,   30,   30,   30,  222,  270,  270,  270,  349,
+       30,   30,  225,  225,  225,  603,  248,  280,  280,  280,
+      249,  252,  281,  600,  325,  251,  282,  288,  288,  288,
+      283,  289,  289,  289,  248,  250,   30,   30,   30,  248,
+       84,  284,  285,  241,  290,  290,  290,  245,  245,  245,
+
+      246,  246,  246,  295,  597,   32,  298,  298,  298,  299,
+      299,  299,  300,  301,  301,  301,  321,  293,  280,  280,
+      280,   84,   84,  316,  316,  316,  317,  318,  318,  318,
+      319,  319,  319,  323,  351,   84,   32,   32,  320,  327,
+      327,  327,  427,  324,  329,  329,  329,  431,  325,  325,
+       32,  330,  330,  330,  300,  331,  331,  331,  332,  332,
+      332,  333,  333,  333,  340,  340,  340,  341,  341,  341,
+      317,  342,  342,  342,  319,  319,  319,  343,  345,  452,
+      349,  461,  349,  353,  456,  350,  465,  594,  346,  354,
+      354,  354,  352,  347,  348,  325,   84,  325,  355,  355,
+
+      355,  356,  356,  356,  357,  358,  358,  358,  332,  332,
+      332,   32,  359,  360,  360,  360,  361,  361,  361,  366,
+      367,  367,  367,  369,  372,  372,  374,  372,  591,  588,
+      373,  393,  585,  370,  376,  376,  376,  375,  371,  347,
+      347,  347,  347,  349,  378,  349,  371,  372,  377,  582,
+      379,  395,  548,  349,  354,  354,  354,  380,  325,  579,
+      325,  571,  347,  381,  381,  381,  371,  543,  325,  383,
+      383,  383,  384,  384,  384,  357,  385,  385,  385,  386,
+      386,  386,  359,  387,  387,  387,  361,  361,  361,  391,
+      391,  391,  366,  392,  392,  392,  393,  393,  372,  398,
+
+      372,  394,  576,  397,  427,  399,  541,  396,  372,  431,
+      565,  371,  371,  347,  401,  347,  400,  376,  376,  376,
+      401,  543,  427,  347,  406,  406,  406,  427,  427,  349,
+      372,  556,  543,  405,  407,  407,  407,  409,  409,  409,
+      546,  545,  349,  544,  325,  347,  322,  322,  322,  322,
+      322,  322,  322,  322,  322,  322,  322,  325,  410,  411,
+      411,  411,  414,  414,  414,  403,  416,  466,  418,  393,
+      539,  393,  470,  481,  415,  393,  417,  372,  485,  538,
+      404,  322,  322,  322,  371,  533,  371,  435,  435,  435,
+      371,  528,  347,  344,  344,  344,  344,  344,  344,  344,
+
+      344,  344,  344,  344,  423,  423,  423,  422,  436,  436,
+      436,  526,  420,  437,  437,  437,  372,  372,  438,  438,
+      438,  439,  439,  439,  441,  441,  441,  421,  344,  344,
+      344,  347,  347,  322,  322,  322,  322,  322,  322,  322,
+      322,  322,  322,  322,  410,  440,  440,  440,  443,  443,
+      443,  444,  425,  448,  473,  473,  473,  500,  500,  500,
+      393,  489,  393,  460,  460,  460,  493,  426,  322,  322,
+      322,  322,  322,  322,  322,  371,  372,  371,  525,  512,
+      322,  322,  474,  475,  475,  475,  476,  418,  507,  523,
+      428,  347,  441,  441,  441,  452,  522,  452,  494,  461,
+
+      456,  452,  452,  498,  465,  429,  322,  322,  322,  322,
+      322,  322,  322,  499,  499,  499,  401,  461,  322,  322,
+      466,  401,  461,  474,  466,  470,  372,  507,  428,  466,
+      461,  494,  511,  430,  481,  466,  501,  501,  501,  485,
+      489,  347,  481,  429,  322,  322,  322,  322,  322,  322,
+      322,  322,  322,  322,  322,  322,  322,  322,  503,  503,
+      503,  474,  504,  504,  504,  444,  433,  481,  512,  489,
+      489,  494,  481,  516,  493,  489,  498,  505,  502,  481,
+      466,  434,  322,  322,  322,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  418,  418,  494,  518,
+
+      518,  518,  444,  494,  446,  519,  519,  519,  461,  452,
+      489,  494,  521,  521,  521,  410,  507,  472,  471,  447,
+      368,  368,  368,  344,  344,  344,  344,  344,  344,  344,
+      344,  344,  344,  344,  427,  507,  507,  517,  517,  517,
+      511,  507,  450,  512,  512,  527,  527,  527,  516,  512,
+      372,  442,  444,  371,  524,  524,  524,  451,  344,  344,
+      344,  344,  344,  344,  344,  347,  512,  372,  366,  555,
+      344,  344,  531,  531,  531,  530,  530,  530,  548,  311,
+      453,  565,  347,  532,  532,  532,  569,  412,  372,  372,
+      536,  536,  536,  543,  359,  454,  344,  344,  344,  344,
+
+      344,  344,  344,  347,  347,  541,  535,  548,  344,  344,
+      537,  537,  537,  357,  548,  542,  548,  550,  453,  549,
+      543,  554,  543,  455,  408,  571,  380,  565,  347,  543,
+      575,  543,  569,  454,  344,  344,  344,  344,  344,  344,
+      344,  344,  344,  344,  344,  344,  344,  344,  557,  565,
+      390,  557,  571,  571,  565,  557,  458,  575,  571,  388,
+      382,  325,  565,  317,  548,  571,  365,  363,  362,  300,
+      311,  459,  344,  344,  344,  322,  322,  322,  322,  543,
+      311,  339,  311,  335,  322,  322,  334,  328,  326,  241,
+      315,  314,  313,  312,  462,  311,  309,  305,  304,  303,
+
+      302,  222,  297,  296,  296,  296,  296,  296,  296,  463,
+      322,  322,  322,  322,  322,  322,  322,  296,  296,  248,
+      292,  279,  322,  322,  278,  277,  231,  276,  275,  274,
+      273,  272,  462,  271,  218,  265,  264,  464,  263,  262,
+      259,  258,  247,  239,  238,  237,  236,  463,  322,  322,
+      322,  322,  322,  322,  322,  235,  234,  231,  230,  228,
+      322,  322,  227,  226,  224,  202,  201,  200,  198,  195,
+      467,  193,  192,  191,  187,  185,  182,  180,  179,  178,
+      177,  174,  127,  164,  163,  468,  322,  322,  322,  322,
+      322,  322,  322,  162,  161,  160,  158,  157,  322,  322,
+
+      156,  155,  154,  153,  152,  151,  150,  149,  467,  148,
+      147,  146,  145,  469,  144,  141,  140,  139,  138,  137,
+      136,  135,  134,  468,  322,  322,  322,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  133,  127,
+      126,  125,  124,  123,  122,  121,  479,   90,  120,  119,
+      116,  115,  114,  113,  110,   90,  109,  108,   90,  107,
+      104,  480,  368,  368,  368,  368,  368,  368,  368,   90,
+      101,  100,   99,   90,  368,  368,   98,   97,   96,   95,
+       90,   94,   93,   92,  482,   91,   90,   90,   89,   32,
+       82,   81,   63,   58,   53,   52,   47,  621,  621,  483,
+
+      368,  368,  368,  368,  368,  368,  368,  621,  621,  621,
+      621,  621,  368,  368,  621,  621,  621,  621,  621,  621,
+      621,  621,  482,  621,  621,  621,  621,  484,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  483,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  621,  621,  621,  621,  621,  621,  621,  621,
+      487,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  488,  368,  368,  368,  344,
+      344,  344,  344,  621,  621,  621,  621,  621,  344,  344,
+      621,  621,  621,  621,  621,  621,  621,  621,  490,  621,
+
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  491,  344,  344,  344,  344,  344,  344,
+      344,  621,  621,  621,  621,  621,  344,  344,  621,  621,
+      621,  621,  621,  621,  621,  621,  490,  621,  621,  621,
+      621,  492,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  491,  344,  344,  344,  344,  344,  344,  344,  621,
+      621,  621,  621,  621,  344,  344,  621,  621,  621,  621,
+      621,  621,  621,  621,  495,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  496,
+      344,  344,  344,  344,  344,  344,  344,  621,  621,  621,
+
+      621,  621,  344,  344,  621,  621,  621,  621,  621,  621,
+      621,  621,  495,  621,  621,  621,  621,  497,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  496,  344,  344,
+      344,  368,  368,  368,  368,  621,  621,  621,  621,  621,
+      368,  368,  621,  621,  621,  621,  621,  621,  621,  621,
+      508,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  509,  368,  368,  368,  368,
+      368,  368,  368,  621,  621,  621,  621,  621,  368,  368,
+      621,  621,  621,  621,  621,  621,  621,  621,  508,  621,
+      621,  621,  621,  510,  621,  621,  621,  621,  621,  621,
+
+      621,  621,  621,  509,  368,  368,  368,  368,  368,  368,
+      368,  621,  621,  621,  621,  621,  368,  368,  621,  621,
+      621,  621,  621,  621,  621,  621,  513,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  514,  368,  368,  368,  368,  368,  368,  368,  621,
+      621,  621,  621,  621,  368,  368,  621,  621,  621,  621,
+      621,  621,  621,  621,  513,  621,  621,  621,  621,  515,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  514,
+      368,  368,  368,  540,  540,  540,  540,  540,  540,  540,
+      540,  540,  540,  540,  621,  621,  621,  621,  621,  621,
+
+      621,  621,  559,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  560,  540,  540,
+      540,  540,  540,  540,  540,  540,  540,  540,  540,  540,
+      540,  540,  621,  621,  621,  621,  621,  621,  621,  621,
+      563,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  564,  540,  540,  540,  540,
+      540,  540,  540,  621,  621,  621,  621,  621,  540,  540,
+      621,  621,  621,  621,  621,  621,  621,  621,  566,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  567,  540,  540,  540,  540,  540,  540,
+
+      540,  621,  621,  621,  621,  621,  540,  540,  621,  621,
+      621,  621,  621,  621,  621,  621,  566,  621,  621,  621,
+      621,  568,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  567,  540,  540,  540,  540,  540,  540,  540,  621,
+      621,  621,  621,  621,  540,  540,  621,  621,  621,  621,
+      621,  621,  621,  621,  572,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  573,
+      540,  540,  540,  540,  540,  540,  540,  621,  621,  621,
+      621,  621,  540,  540,  621,  621,  621,  621,  621,  621,
+      621,  621,  572,  621,  621,  621,  621,  574,  621,  621,
+
+      621,  621,  621,  621,  621,  621,  621,  573,  540,  540,
+      540,   30,   30,   30,   30,   30,   30,   30,   30,   36,
+       36,   36,   36,   36,   83,  621,   83,   83,   83,   83,
+       83,   83,   83,   83,  143,  143,  143,  181,  181,  181,
+      181,  181,  184,  184,  621,  184,  188,  188,  188,  203,
+      203,  203,  203,  203,  203,  203,  203,  229,  229,  621,
+      229,  232,  621,  232,  232,  233,  233,  233,  233,  233,
+      248,  248,  248,  248,  248,  248,  248,  248,  286,  286,
+      621,  286,  287,  287,  621,  287,  291,  291,  621,  291,
+      306,  306,  621,  306,  307,  307,  621,  307,  308,  308,
+
+      308,  310,  310,  621,  310,  322,  322,  322,  322,  322,
+      322,  322,  322,  336,  336,  621,  336,  337,  337,  337,
+      337,  337,  338,  338,  338,  344,  344,  344,  344,  344,
+      344,  344,  344,  364,  364,  364,  364,  364,  368,  368,
+      368,  368,  368,  368,  368,  368,  389,  389,  621,  389,
+      402,  402,  402,  402,  402,  402,  402,  402,  413,  413,
+      621,  413,  419,  419,  419,  419,  419,  419,  419,  419,
+      424,  424,  424,  424,  424,  424,  424,  424,  427,  427,
+      427,  427,  427,  427,  427,  427,  432,  432,  432,  432,
+      432,  432,  432,  432,  445,  445,  445,  445,  445,  445,
+
+      445,  445,  449,  449,  449,  449,  449,  449,  449,  449,
+      452,  452,  452,  452,  452,  452,  452,  452,  457,  457,
+      457,  457,  457,  457,  457,  457,  461,  461,  461,  461,
+      461,  461,  461,  461,  466,  466,  466,  466,  466,  466,
+      466,  466,  477,  477,  621,  477,  478,  478,  478,  478,
+      478,  478,  478,  478,  481,  481,  481,  481,  481,  481,
+      481,  481,  486,  486,  486,  486,  486,  486,  486,  486,
+      489,  489,  489,  489,  489,  489,  489,  489,  494,  494,
+      494,  494,  494,  494,  494,  494,  506,  506,  621,  506,
+      507,  507,  507,  507,  507,  507,  507,  507,  512,  512,
+
+      512,  512,  512,  512,  512,  512,  520,  520,  520,  520,
+      520,  520,  520,  529,  529,  621,  529,  534,  534,  621,
+      534,  540,  540,  540,  540,  540,  540,  540,  540,  547,
+      547,  621,  547,  551,  551,  551,  551,  551,  551,  551,
+      552,  552,  552,  552,  552,  552,  552,  553,  553,  621,
+      553,  558,  558,  558,  558,  558,  558,  558,  558,  561,
+      561,  621,  561,  562,  562,  562,  562,  562,  562,  562,
+      562,  565,  565,  565,  565,  565,  565,  565,  565,  570,
+      570,  621,  570,  571,  571,  571,  571,  571,  571,  571,
+      571,  577,  577,  621,  577,  578,  578,  621,  578,  580,
+
+      580,  621,  580,  581,  581,  621,  581,  583,  583,  621,
+      583,  584,  584,  621,  584,  586,  586,  621,  586,  587,
+      587,  621,  587,  589,  589,  621,  589,  590,  590,  621,
+      590,  592,  592,  621,  592,  593,  593,  621,  593,  595,
+      595,  621,  595,  596,  596,  621,  596,  598,  598,  621,
+      598,  599,  599,  621,  599,  601,  601,  621,  601,  602,
+      602,  621,  602,  604,  604,  621,  604,  605,  605,  621,
+      605,  607,  607,  621,  607,  608,  608,  621,  608,  610,
+      610,  621,  610,  611,  611,  621,  611,  613,  613,  621,
+      613,  614,  614,  621,  614,  616,  616,  621,  616,  617,
+
+      617,  621,  617,  619,  619,  621,  619,  620,  620,  621,
+      620,    3,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621
+    } ;
+
+static yyconst flex_int16_t yy_chk[2472] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    6,
+        7,    7,    7,    8,   10,   11,   17,   13,   19,   16,
+       13,   23,   21,   19,   10,   11,   13,   21,   11,   16,
+       25,   17,   10,   57,   57,   23,   21,   19,    6,   24,
+       13,   11,   25,    6,    6,   19,   22,   25,   29,    8,
+
+       24,   25,   24,    8,    6,   30,   22,   22,   24,   32,
+       33,   34,   35,   35,   35,   55,   24,   29,   55,   32,
+       30,   62,   59,   68,   32,   33,   34,   62,   73,   85,
+       84,   86,   29,   68,   34,   84,   33,   59,   34,   73,
+       87,   88,   88,   88,   85,   84,   86,  101,  101,  101,
+      128,  129,   85,  130,  132,   87,  121,  121,  121,  128,
+      131,  151,   86,  132,  261,  261,  129,  151,  130,   87,
+      133,  133,  133,  617,  128,  131,  136,  136,  136,  205,
+      134,  130,  129,  198,  205,  131,  134,  134,  134,  137,
+      137,  137,  142,  142,  142,  145,  145,  145,  148,  148,
+
+      148,  155,  155,  155,  157,  157,  157,  158,  158,  158,
+      159,  159,  159,  161,  161,  161,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  166,  170,  170,
+      170,  167,  198,  251,  168,  165,  171,  171,  171,  172,
+      172,  172,  166,  174,  174,  174,  167,  251,  208,  168,
+      165,  165,  165,  165,  167,  166,  168,  169,  208,  212,
+      169,  262,  169,  175,  175,  175,  169,  262,  614,  169,
+      169,  169,  173,  208,  212,  169,  611,  608,  173,  173,
+      173,  176,  176,  176,  176,  178,  178,  178,  183,  183,
+      183,  186,  186,  186,  194,  194,  194,  196,  196,  196,
+
+      197,  197,  197,  197,  199,  199,  199,  200,  200,  200,
+      201,  201,  201,  203,  203,  203,  203,  209,  206,  207,
+      254,  209,  203,  203,  217,  217,  217,  218,  218,  218,
+      254,  605,  203,  206,  207,  220,  220,  220,  221,  221,
+      221,  206,  222,  222,  222,  254,  207,  203,  203,  203,
+      203,  204,  204,  204,  204,  223,  223,  223,  223,  322,
+      204,  204,  225,  225,  225,  602,  250,  237,  237,  237,
+      204,  250,  237,  599,  322,  204,  237,  240,  240,  240,
+      237,  241,  241,  241,  252,  204,  204,  204,  204,  252,
+      253,  237,  237,  242,  242,  242,  242,  245,  245,  245,
+
+      246,  246,  246,  255,  596,  253,  267,  267,  267,  268,
+      268,  268,  269,  269,  269,  269,  294,  253,  280,  280,
+      280,  293,  255,  288,  288,  288,  289,  289,  289,  289,
+      292,  292,  292,  295,  324,  294,  293,  255,  293,  297,
+      297,  297,  404,  295,  299,  299,  299,  404,  295,  324,
+      294,  300,  300,  300,  301,  301,  301,  301,  302,  302,
+      302,  303,  303,  303,  316,  316,  316,  317,  317,  317,
+      318,  318,  318,  318,  319,  319,  319,  320,  321,  421,
+      323,  426,  325,  326,  421,  323,  426,  593,  321,  326,
+      326,  326,  325,  321,  321,  323,  320,  325,  327,  327,
+
+      327,  328,  328,  328,  330,  330,  330,  330,  332,  332,
+      332,  320,  333,  333,  333,  333,  334,  334,  334,  341,
+      341,  341,  341,  343,  344,  345,  346,  347,  590,  587,
+      345,  368,  584,  343,  348,  348,  348,  347,  343,  344,
+      345,  346,  347,  349,  350,  351,  368,  348,  349,  581,
+      351,  370,  540,  350,  353,  353,  353,  354,  349,  578,
+      351,  571,  348,  354,  354,  354,  370,  540,  350,  356,
+      356,  356,  357,  357,  357,  358,  358,  358,  358,  359,
+      359,  359,  360,  360,  360,  360,  361,  361,  361,  366,
+      366,  366,  367,  367,  367,  367,  369,  371,  372,  373,
+
+      374,  369,  570,  372,  429,  374,  542,  371,  373,  429,
+      565,  369,  371,  372,  430,  374,  376,  376,  376,  376,
+      377,  542,  431,  373,  380,  380,  380,  431,  430,  377,
+      376,  553,  550,  379,  382,  382,  382,  384,  384,  384,
+      538,  537,  379,  536,  377,  376,  378,  378,  378,  378,
+      378,  378,  378,  378,  378,  378,  378,  379,  386,  386,
+      386,  386,  391,  391,  391,  378,  394,  434,  397,  393,
+      534,  395,  434,  447,  393,  394,  395,  397,  447,  533,
+      378,  378,  378,  378,  393,  528,  395,  406,  406,  406,
+      394,  522,  397,  398,  398,  398,  398,  398,  398,  398,
+
+      398,  398,  398,  398,  400,  400,  400,  399,  407,  407,
+      407,  519,  398,  408,  408,  408,  399,  400,  409,  409,
+      409,  410,  410,  410,  412,  412,  412,  398,  398,  398,
+      398,  399,  400,  401,  401,  401,  401,  401,  401,  401,
+      401,  401,  401,  401,  411,  411,  411,  411,  414,  414,
+      414,  415,  401,  417,  437,  437,  437,  471,  471,  471,
+      415,  451,  417,  423,  423,  423,  451,  401,  401,  401,
+      401,  402,  402,  402,  402,  415,  423,  417,  518,  512,
+      402,  402,  439,  439,  439,  439,  441,  455,  507,  506,
+      402,  423,  441,  441,  441,  454,  505,  456,  459,  463,
+
+      454,  455,  456,  459,  463,  402,  402,  402,  402,  403,
+      403,  403,  403,  460,  460,  460,  464,  465,  403,  403,
+      468,  469,  465,  504,  470,  468,  460,  480,  403,  470,
+      464,  494,  480,  403,  483,  469,  472,  472,  472,  483,
+      489,  460,  481,  403,  403,  403,  403,  405,  405,  405,
+      405,  405,  405,  405,  405,  405,  405,  405,  474,  474,
+      474,  475,  475,  475,  475,  484,  405,  485,  488,  491,
+      493,  496,  485,  488,  491,  493,  496,  476,  473,  484,
+      466,  405,  405,  405,  405,  416,  416,  416,  416,  416,
+      416,  416,  416,  416,  416,  416,  492,  497,  498,  500,
+
+      500,  500,  510,  498,  416,  501,  501,  501,  461,  452,
+      492,  497,  503,  503,  503,  440,  510,  436,  435,  416,
+      416,  416,  416,  418,  418,  418,  418,  418,  418,  418,
+      418,  418,  418,  418,  427,  509,  511,  499,  499,  499,
+      509,  511,  418,  514,  516,  521,  521,  521,  514,  516,
+      499,  413,  515,  396,  517,  517,  517,  418,  418,  418,
+      418,  419,  419,  419,  419,  499,  515,  517,  392,  549,
+      419,  419,  525,  525,  525,  524,  524,  524,  549,  390,
+      419,  560,  517,  526,  526,  526,  560,  388,  524,  530,
+      531,  531,  531,  549,  387,  419,  419,  419,  419,  420,
+
+      420,  420,  420,  524,  530,  535,  530,  543,  420,  420,
+      532,  532,  532,  385,  541,  535,  548,  543,  420,  541,
+      535,  548,  543,  420,  383,  564,  381,  567,  375,  541,
+      564,  548,  567,  420,  420,  420,  420,  422,  422,  422,
+      422,  422,  422,  422,  422,  422,  422,  422,  568,  569,
+      365,  574,  573,  575,  569,  554,  422,  573,  575,  362,
+      355,  352,  568,  342,  554,  574,  339,  336,  335,  331,
+      315,  422,  422,  422,  422,  424,  424,  424,  424,  554,
+      314,  313,  312,  305,  424,  424,  304,  298,  296,  290,
+      285,  284,  283,  282,  424,  281,  278,  274,  273,  272,
+
+      271,  270,  266,  265,  264,  263,  260,  259,  258,  424,
+      424,  424,  424,  425,  425,  425,  425,  257,  256,  248,
+      247,  236,  425,  425,  235,  234,  232,  230,  229,  228,
+      227,  226,  425,  224,  219,  216,  215,  425,  214,  213,
+      211,  210,  202,  195,  193,  192,  191,  425,  425,  425,
+      425,  432,  432,  432,  432,  190,  189,  187,  185,  182,
+      432,  432,  180,  179,  177,  164,  163,  162,  160,  156,
+      432,  154,  153,  152,  149,  147,  144,  141,  140,  139,
+      138,  135,  127,  126,  125,  432,  432,  432,  432,  433,
+      433,  433,  433,  124,  123,  122,  119,  118,  433,  433,
+
+      117,  116,  114,  112,  111,  110,  109,  108,  433,  107,
+      106,  105,  104,  433,  103,  100,   99,   98,   97,   94,
+       93,   91,   90,  433,  433,  433,  433,  444,  444,  444,
+      444,  444,  444,  444,  444,  444,  444,  444,   89,   83,
+       82,   81,   80,   79,   78,   77,  444,   76,   75,   74,
+       72,   71,   70,   69,   67,   66,   65,   64,   63,   61,
+       58,  444,  444,  444,  444,  445,  445,  445,  445,   56,
+       54,   53,   52,   51,  445,  445,   50,   49,   48,   47,
+       46,   45,   44,   42,  445,   41,   39,   38,   37,   31,
+       27,   26,   20,   18,   15,   14,   12,    3,    0,  445,
+
+      445,  445,  445,  446,  446,  446,  446,    0,    0,    0,
+        0,    0,  446,  446,    0,    0,    0,    0,    0,    0,
+        0,    0,  446,    0,    0,    0,    0,  446,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  446,  446,  446,
+      446,  448,  448,  448,  448,  448,  448,  448,  448,  448,
+      448,  448,    0,    0,    0,    0,    0,    0,    0,    0,
+      448,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,  448,  448,  448,  448,  449,
+      449,  449,  449,    0,    0,    0,    0,    0,  449,  449,
+        0,    0,    0,    0,    0,    0,    0,    0,  449,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,  449,  449,  449,  449,  450,  450,  450,
+      450,    0,    0,    0,    0,    0,  450,  450,    0,    0,
+        0,    0,    0,    0,    0,    0,  450,    0,    0,    0,
+        0,  450,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,  450,  450,  450,  450,  457,  457,  457,  457,    0,
+        0,    0,    0,    0,  457,  457,    0,    0,    0,    0,
+        0,    0,    0,    0,  457,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,  457,
+      457,  457,  457,  458,  458,  458,  458,    0,    0,    0,
+
+        0,    0,  458,  458,    0,    0,    0,    0,    0,    0,
+        0,    0,  458,    0,    0,    0,    0,  458,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  458,  458,  458,
+      458,  478,  478,  478,  478,    0,    0,    0,    0,    0,
+      478,  478,    0,    0,    0,    0,    0,    0,    0,    0,
+      478,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,  478,  478,  478,  478,  479,
+      479,  479,  479,    0,    0,    0,    0,    0,  479,  479,
+        0,    0,    0,    0,    0,    0,    0,    0,  479,    0,
+        0,    0,    0,  479,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,  479,  479,  479,  479,  486,  486,  486,
+      486,    0,    0,    0,    0,    0,  486,  486,    0,    0,
+        0,    0,    0,    0,    0,    0,  486,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,  486,  486,  486,  486,  487,  487,  487,  487,    0,
+        0,    0,    0,    0,  487,  487,    0,    0,    0,    0,
+        0,    0,    0,    0,  487,    0,    0,    0,    0,  487,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,  487,
+      487,  487,  487,  555,  555,  555,  555,  555,  555,  555,
+      555,  555,  555,  555,    0,    0,    0,    0,    0,    0,
+
+        0,    0,  555,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  555,  555,  555,
+      555,  557,  557,  557,  557,  557,  557,  557,  557,  557,
+      557,  557,    0,    0,    0,    0,    0,    0,    0,    0,
+      557,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,  557,  557,  557,  557,  558,
+      558,  558,  558,    0,    0,    0,    0,    0,  558,  558,
+        0,    0,    0,    0,    0,    0,    0,    0,  558,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,  558,  558,  558,  558,  559,  559,  559,
+
+      559,    0,    0,    0,    0,    0,  559,  559,    0,    0,
+        0,    0,    0,    0,    0,    0,  559,    0,    0,    0,
+        0,  559,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,  559,  559,  559,  559,  562,  562,  562,  562,    0,
+        0,    0,    0,    0,  562,  562,    0,    0,    0,    0,
+        0,    0,    0,    0,  562,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,  562,
+      562,  562,  562,  563,  563,  563,  563,    0,    0,    0,
+        0,    0,  563,  563,    0,    0,    0,    0,    0,    0,
+        0,    0,  563,    0,    0,    0,    0,  563,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,  563,  563,  563,
+      563,  622,  622,  622,  622,  622,  622,  622,  622,  623,
+      623,  623,  623,  623,  624,    0,  624,  624,  624,  624,
+      624,  624,  624,  624,  625,  625,  625,  626,  626,  626,
+      626,  626,  627,  627,    0,  627,  628,  628,  628,  629,
+      629,  629,  629,  629,  629,  629,  629,  630,  630,    0,
+      630,  631,    0,  631,  631,  632,  632,  632,  632,  632,
+      633,  633,  633,  633,  633,  633,  633,  633,  634,  634,
+        0,  634,  635,  635,    0,  635,  636,  636,    0,  636,
+      637,  637,    0,  637,  638,  638,    0,  638,  639,  639,
+
+      639,  640,  640,    0,  640,  641,  641,  641,  641,  641,
+      641,  641,  641,  642,  642,    0,  642,  643,  643,  643,
+      643,  643,  644,  644,  644,  645,  645,  645,  645,  645,
+      645,  645,  645,  646,  646,  646,  646,  646,  647,  647,
+      647,  647,  647,  647,  647,  647,  648,  648,    0,  648,
+      649,  649,  649,  649,  649,  649,  649,  649,  650,  650,
+        0,  650,  651,  651,  651,  651,  651,  651,  651,  651,
+      652,  652,  652,  652,  652,  652,  652,  652,  653,  653,
+      653,  653,  653,  653,  653,  653,  654,  654,  654,  654,
+      654,  654,  654,  654,  655,  655,  655,  655,  655,  655,
+
+      655,  655,  656,  656,  656,  656,  656,  656,  656,  656,
+      657,  657,  657,  657,  657,  657,  657,  657,  658,  658,
+      658,  658,  658,  658,  658,  658,  659,  659,  659,  659,
+      659,  659,  659,  659,  660,  660,  660,  660,  660,  660,
+      660,  660,  661,  661,    0,  661,  662,  662,  662,  662,
+      662,  662,  662,  662,  663,  663,  663,  663,  663,  663,
+      663,  663,  664,  664,  664,  664,  664,  664,  664,  664,
+      665,  665,  665,  665,  665,  665,  665,  665,  666,  666,
+      666,  666,  666,  666,  666,  666,  667,  667,    0,  667,
+      668,  668,  668,  668,  668,  668,  668,  668,  669,  669,
+
+      669,  669,  669,  669,  669,  669,  670,  670,  670,  670,
+      670,  670,  670,  671,  671,    0,  671,  672,  672,    0,
+      672,  673,  673,  673,  673,  673,  673,  673,  673,  674,
+      674,    0,  674,  675,  675,  675,  675,  675,  675,  675,
+      676,  676,  676,  676,  676,  676,  676,  677,  677,    0,
+      677,  678,  678,  678,  678,  678,  678,  678,  678,  679,
+      679,    0,  679,  680,  680,  680,  680,  680,  680,  680,
+      680,  681,  681,  681,  681,  681,  681,  681,  681,  682,
+      682,    0,  682,  683,  683,  683,  683,  683,  683,  683,
+      683,  684,  684,    0,  684,  685,  685,    0,  685,  686,
+
+      686,    0,  686,  687,  687,    0,  687,  688,  688,    0,
+      688,  689,  689,    0,  689,  690,  690,    0,  690,  691,
+      691,    0,  691,  692,  692,    0,  692,  693,  693,    0,
+      693,  694,  694,    0,  694,  695,  695,    0,  695,  696,
+      696,    0,  696,  697,  697,    0,  697,  698,  698,    0,
+      698,  699,  699,    0,  699,  700,  700,    0,  700,  701,
+      701,    0,  701,  702,  702,    0,  702,  703,  703,    0,
+      703,  704,  704,    0,  704,  705,  705,    0,  705,  706,
+      706,    0,  706,  707,  707,    0,  707,  708,  708,    0,
+      708,  709,  709,    0,  709,  710,  710,    0,  710,  711,
+
+      711,    0,  711,  712,  712,    0,  712,  713,  713,    0,
+      713,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621,  621,  621,  621,  621,  621,  621,  621,  621,  621,
+      621
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int nf_flex_debug;
+int nf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *nftext;
+#line 1 "netfilter.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: netfilter.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "netfilter.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void nf_parse_start_hn(char *input);
+void nf_parse_start(char *input);
+void nf_parse_isostart_hn(char *input);
+void nf_parse_prefix(char *input, unsigned char mode);
+void nf_parse_ip(char *input, unsigned char mode);
+void nf_parse_proto(char *input);
+#line 1271 "netfilter.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int nflex_destroy (void );
+
+int nfget_debug (void );
+
+void nfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE nfget_extra (void );
+
+void nfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *nfget_in (void );
+
+void nfset_in  (FILE * in_str  );
+
+FILE *nfget_out (void );
+
+void nfset_out  (FILE * out_str  );
+
+int nfget_leng (void );
+
+char *nfget_text (void );
+
+int nfget_lineno (void );
+
+void nfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int nfwrap (void );
+#else
+extern int nfwrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( nftext, nfleng, 1, nfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( nfin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( nfin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, nfin))==0 && ferror(nfin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(nfin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int nflex (void);
+
+#define YY_DECL int nflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after nftext and nfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 39 "netfilter.l"
+
+
+#line 1459 "netfilter.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! nfin )
+			nfin = stdin;
+
+		if ( ! nfout )
+			nfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			nfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				nf_create_buffer(nfin,YY_BUF_SIZE );
+		}
+
+		nf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of nftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 622 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 621 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 41 "netfilter.l"
+nf_parse_start_hn(nftext);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 42 "netfilter.l"
+nf_parse_start(nftext);
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 43 "netfilter.l"
+nf_parse_start_hn(nftext+5);
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 44 "netfilter.l"
+nf_parse_start(nftext+5);
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 45 "netfilter.l"
+nf_parse_isostart_hn(nftext);
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 46 "netfilter.l"
+nf_parse_prefix(nftext+18, NF_OPT_PREFIX_KTIME);
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 47 "netfilter.l"
+nf_parse_prefix(nftext+12, NF_OPT_NOPREFIX);
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 48 "netfilter.l"
+nf_parse_prefix(nftext+9, NF_OPT_PREFIX);
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 49 "netfilter.l"
+nf_parse_prefix(nftext+13, NF_OPT_NOPREFIX);
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 50 "netfilter.l"
+nf_parse_prefix(nftext+10, NF_OPT_PREFIX);
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 51 "netfilter.l"
+nf_parse_prefix(nftext+11, NF_OPT_NOPREFIX);
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 52 "netfilter.l"
+nf_parse_prefix(nftext+8, NF_OPT_PREFIX);
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 53 "netfilter.l"
+nf_parse_prefix(nftext+1, NF_OPT_PREFIX);
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 54 "netfilter.l"
+nf_parse_prefix(nftext+3, NF_OPT_NOPREFIX);
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 55 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 56 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 57 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 58 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 59 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 60 "netfilter.l"
+nf_parse_ip(nftext+4, NF_OPT_SRC);
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 61 "netfilter.l"
+nf_parse_ip(nftext+4, NF_OPT_DST);
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 62 "netfilter.l"
+opt.line->datalen = atoi(nftext+4);
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 63 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 64 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 65 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 66 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 67 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 68 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 69 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 70 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 71 "netfilter.l"
+nf_parse_proto(nftext+6);
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 72 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 73 "netfilter.l"
+{ opt.line->sport = atoi(nftext+5); opt.parser=opt.parser|NF_TYPE; }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 74 "netfilter.l"
+{ opt.line->dport = atoi(nftext+5); opt.parser=opt.parser|NF_CODE; }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 75 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 76 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 77 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 78 "netfilter.l"
+{ opt.line->sport = atoi(nftext+4); opt.parser=opt.parser|NF_SPT; }
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 79 "netfilter.l"
+{ opt.line->dport = atoi(nftext+4); opt.parser=opt.parser|NF_DPT; }
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 80 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 81 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 82 "netfilter.l"
+opt.line->flags = opt.line->flags | TCP_URG;
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 83 "netfilter.l"
+opt.line->flags = opt.line->flags | TCP_ACK;
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 84 "netfilter.l"
+opt.line->flags = opt.line->flags | TCP_PSH;
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 85 "netfilter.l"
+opt.line->flags = opt.line->flags | TCP_RST;
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 86 "netfilter.l"
+opt.line->flags = opt.line->flags | TCP_SYN;
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 87 "netfilter.l"
+opt.line->flags = opt.line->flags | TCP_FIN;
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 88 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 89 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 90 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 91 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 92 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 93 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 94 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 95 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 96 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 97 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 98 "netfilter.l"
+/* ignore */
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 99 "netfilter.l"
+/* ignore whitespace */
+	YY_BREAK
+case 60:
+/* rule 60 can match eol */
+YY_RULE_SETUP
+#line 100 "netfilter.l"
+return 0;
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 101 "netfilter.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", nftext);
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 102 "netfilter.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", nftext);
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 104 "netfilter.l"
+ECHO;
+	YY_BREAK
+#line 1854 "netfilter.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed nfin at a new source and called
+			 * nflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = nfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( nfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * nftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of nflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					nfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			nfrestart(nfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) nfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 622 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 622 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 621);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					nfrestart(nfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( nfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve nftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void nfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        nfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            nf_create_buffer(nfin,YY_BUF_SIZE );
+	}
+
+	nf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	nf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void nf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		nfpop_buffer_state();
+	 *		nfpush_buffer_state(new_buffer);
+     */
+	nfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	nf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (nfwrap()) processing, but the only time this flag
+	 * is looked at is after nfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void nf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	nfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE nf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) nfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in nf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) nfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in nf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	nf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with nf_create_buffer()
+ * 
+ */
+    void nf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		nffree((void *) b->yy_ch_buf  );
+
+	nffree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a nfrestart() or at EOF.
+ */
+    static void nf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	nf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then nf_init_buffer was _probably_
+     * called from nfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void nf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		nf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void nfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	nfensure_buffer_stack();
+
+	/* This block is copied from nf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from nf_switch_to_buffer. */
+	nf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void nfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	nf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		nf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void nfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)nfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in nfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)nfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in nfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE nf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) nfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in nf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	nf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to nflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       nf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE nf_scan_string (yyconst char * yystr )
+{
+    
+	return nf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to nflex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE nf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) nfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in nf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = nf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in nf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up nftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		nftext[nfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = nftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		nfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int nfget_lineno  (void)
+{
+        
+    return nflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *nfget_in  (void)
+{
+        return nfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *nfget_out  (void)
+{
+        return nfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int nfget_leng  (void)
+{
+        return nfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *nfget_text  (void)
+{
+        return nftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void nfset_lineno (int  line_number )
+{
+    
+    nflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see nf_switch_to_buffer
+ */
+void nfset_in (FILE *  in_str )
+{
+        nfin = in_str ;
+}
+
+void nfset_out (FILE *  out_str )
+{
+        nfout = out_str ;
+}
+
+int nfget_debug  (void)
+{
+        return nf_flex_debug;
+}
+
+void nfset_debug (int  bdebug )
+{
+        nf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from nflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    nfin = stdin;
+    nfout = stdout;
+#else
+    nfin = (FILE *) 0;
+    nfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * nflex_init()
+     */
+    return 0;
+}
+
+/* nflex_destroy is for both reentrant and non-reentrant scanners. */
+int nflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		nf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		nfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	nffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * nflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *nfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *nfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void nffree (void * ptr )
+{
+	free( (char *) ptr );	/* see nfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 104 "netfilter.l"
+
+
+
+void nf_parse_start_hn(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 6) {
+    return;
+  }
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | NF_DATE;
+}
+
+void nf_parse_start(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d", smonth, &day, &hour, &minute, &second);
+  if (retval != 5) {
+    return;
+  }
+
+  build_time(smonth, day, hour, minute, second);
+  xstrncpy(opt.line->hostname, "-", SHORTLEN);
+
+  opt.parser = opt.parser | NF_DATE;
+}
+
+void nf_parse_isostart_hn(char *input)
+{
+  int retval, year, month, day, hour, minute, second;
+  struct tm *t;
+
+  retval = sscanf(input, "%4d:%2d:%2d-%2d:%2d:%2d %32s", &year, &month, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 7) {
+    return;
+  }
+
+  t = xmalloc(sizeof(struct tm));
+  t->tm_year = year - 1900;
+  t->tm_mon = month - 1;
+  t->tm_mday = day;
+  t->tm_hour = hour;
+  t->tm_min = minute;
+  t->tm_sec = second;
+  t->tm_isdst = -1;
+  opt.line->time = mktime(t);
+  free(t);
+
+  opt.parser = opt.parser | NF_DATE;
+}
+
+void nf_parse_prefix(char *input, unsigned char mode)
+{
+  size_t i = 0;
+  char *pnt;
+
+  if (mode == NF_OPT_PREFIX_KTIME) {
+    pnt = strchr(input, ']');
+    pnt += 2;
+  } else {
+    pnt = input;
+  }
+  if (mode == NF_OPT_PREFIX || mode == NF_OPT_PREFIX_KTIME) {
+    i = strlen(pnt);
+    while (i > 0) {
+      if (pnt[i] == '=') {
+	if (pnt[i - 1] == 'N') {
+	  if (pnt[i - 2] == 'I') {
+	    pnt[i - 2] = '\0';
+	    xstrncpy(opt.line->chainlabel, pnt, SHORTLEN);
+	    xstrncpy(opt.line->interface, pnt + i + 1, SHORTLEN);
+	    break;
+	  }
+	}
+      }
+      i--;
+    }
+  } else {
+    xstrncpy(opt.line->chainlabel, "-", SHORTLEN);
+    xstrncpy(opt.line->interface, pnt, SHORTLEN);
+  }
+
+  opt.parser = opt.parser | NF_IN;
+}
+
+void nf_parse_ip(char *input, unsigned char mode)
+{
+  if (mode == NF_OPT_SRC) {
+    if (convert_ip(input, &opt.line->shost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | NF_SRC;
+  } else {
+    if (convert_ip(input, &opt.line->dhost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | NF_DST;
+  }
+}
+
+void nf_parse_proto(char *input)
+{
+  if (isdigit((int) input[0])) {
+    opt.line->protocol = atoi(input);
+  } else {
+    if (strncmp(input, "TCP", 3) == 0)
+      opt.line->protocol = 6;
+    else if (strncmp(input, "UDP", 3) == 0)
+      opt.line->protocol = 17;
+    else if (strncmp(input, "ICMP", 4) == 0)
+      opt.line->protocol = 1;
+    else if (strncmp(input, "ESP", 3) == 0)
+      opt.line->protocol = 50;
+    else if (strncmp(input, "AH", 2) == 0)
+      opt.line->protocol = 51;
+    else if (strncmp(input, "ICMPv6", 6) == 0)
+      opt.line->protocol = 58;
+  }
+
+  if (opt.line->protocol != 0)
+    opt.parser = opt.parser | NF_PROTO;
+}
+
+unsigned char flex_netfilter(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  nf_scan_string(input);
+  nflex();
+  nf_delete_buffer(YY_CURRENT_BUFFER);
+
+  xstrncpy(opt.line->branchname, "-", SHORTLEN);
+  opt.line->count = 1;
+
+  if (((opt.line->protocol == 6) || (opt.line->protocol == 17)) && (opt.parser == (NF_DATE | NF_PROTO | NF_IN | NF_SRC | NF_DST | NF_SPT | NF_DPT))) {
+    return PARSE_OK;
+  }
+  if ((opt.line->protocol == 1) && (opt.parser == (NF_DATE | NF_PROTO | NF_IN | NF_SRC | NF_DST | NF_TYPE | NF_CODE))) {
+    return PARSE_OK;
+  }
+  if (((opt.line->protocol == 2) || (opt.line->protocol == 9) || (opt.line->protocol == 41) || (opt.line->protocol == 46) || (opt.line->protocol == 47)
+       || (opt.line->protocol == 50) || (opt.line->protocol == 54) || (opt.line->protocol == 103)) && (opt.parser == (NF_DATE | NF_PROTO | NF_IN | NF_SRC | NF_DST))) {
+    return PARSE_OK;
+  }
+  if (opt.verbose)
+    fprintf(stderr, "netfilter parse error in line %d, ignoring.\n", linenum);
+  if (opt.verbose == 2)
+    fprintf(stderr, "input was: \"%s\"\n", input);
+  return PARSE_WRONG_FORMAT;
+}
+
diff -Naur fwlogwatch-1.2.orig/netscreen.c fwlogwatch-1.2/netscreen.c
--- fwlogwatch-1.2.orig/netscreen.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/netscreen.c	2011-09-08 11:36:18.831516014 +0200
@@ -0,0 +1,3174 @@
+#line 2 "netscreen.c"
+
+#line 4 "netscreen.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer ns_create_buffer
+#define yy_delete_buffer ns_delete_buffer
+#define yy_flex_debug ns_flex_debug
+#define yy_init_buffer ns_init_buffer
+#define yy_flush_buffer ns_flush_buffer
+#define yy_load_buffer_state ns_load_buffer_state
+#define yy_switch_to_buffer ns_switch_to_buffer
+#define yyin nsin
+#define yyleng nsleng
+#define yylex nslex
+#define yylineno nslineno
+#define yyout nsout
+#define yyrestart nsrestart
+#define yytext nstext
+#define yywrap nswrap
+#define yyalloc nsalloc
+#define yyrealloc nsrealloc
+#define yyfree nsfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE nsrestart(nsin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int nsleng;
+
+extern FILE *nsin, *nsout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up nstext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up nstext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via nsrestart()), so that the user can continue scanning by
+	 * just pointing nsin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when nstext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int nsleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow nswrap()'s to do buffer switches
+ * instead of setting up a fresh nsin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void nsrestart (FILE *input_file  );
+void ns_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ns_create_buffer (FILE *file,int size  );
+void ns_delete_buffer (YY_BUFFER_STATE b  );
+void ns_flush_buffer (YY_BUFFER_STATE b  );
+void nspush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void nspop_buffer_state (void );
+
+static void nsensure_buffer_stack (void );
+static void ns_load_buffer_state (void );
+static void ns_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ns_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ns_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ns_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ns_scan_bytes (yyconst char *bytes,int len  );
+
+void *nsalloc (yy_size_t  );
+void *nsrealloc (void *,yy_size_t  );
+void nsfree (void *  );
+
+#define yy_new_buffer ns_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        nsensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ns_create_buffer(nsin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        nsensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ns_create_buffer(nsin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define nswrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *nsin = (FILE *) 0, *nsout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int nslineno;
+
+int nslineno = 1;
+
+extern char *nstext;
+#define yytext_ptr nstext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up nstext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	nsleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 48
+#define YY_END_OF_BUFFER 49
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[1497] =
+    {   0,
+        0,    0,   49,   47,   45,   44,   47,   47,   47,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   47,   46,   46,   46,   46,   46,   46,   46,
+       46,   44,    0,    0,    0,   46,    0,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,    0,    0,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+        0,    0,    0,    0,    0,   46,   46,   46,   46,   46,
+       46,   46,    0,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,    0,
+
+        0,    0,    0,    0,   46,    0,    0,   46,   46,   46,
+        0,    0,   46,   46,   46,    0,    0,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,    0,   46,    0,   46,
+       46,   46,   46,    0,    0,    0,    0,    0,   46,    0,
+        0,    0,    0,   46,    0,    0,    0,   46,   46,   46,
+        0,    0,   46,   46,    0,    0,   46,   46,    0,    0,
+       46,    0,   46,    0,   46,   46,   46,   46,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   46,   46,   46,    0,    0,    0,
+       46,   46,    0,    0,   46,    0,   17,   16,   46,    0,
+
+       46,    0,    0,   46,   46,   46,   46,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   46,   46,    0,    0,    0,   46,
+       46,    0,    0,   46,   11,   46,    0,   46,    0,    0,
+       46,   46,   46,   46,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   15,   46,   46,    0,    0,    0,   46,   46,    0,
+        0,   46,    0,    0,   46,    0,    0,   46,   46,   46,
+       46,   46,   46,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,   46,   46,    0,    0,    0,    0,    0,    0,    0,
+       46,   10,   10,   10,    0,   46,    0,    0,    0,   46,
+       46,   46,   46,   46,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   14,
+        0,    0,   21,    8,    0,    0,    0,    0,   10,   10,
+       13,   46,    0,    0,   20,   46,   46,   46,   46,   46,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    3,   12,   14,   19,    0,   21,   22,
+
+        0,    9,    0,   10,   10,   13,    0,   18,    0,   20,
+        0,   46,   46,   46,    0,    0,    0,    0,    0,    0,
+        2,    0,    0,    0,   25,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   15,    3,
+       12,   19,   21,    0,    0,   10,    0,    0,   18,   20,
+        0,   46,   46,   46,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   19,   21,    0,   10,
+       10,    0,    0,   18,   20,    0,   46,   46,   46,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   21,
+        0,   10,    0,    0,   20,    0,   46,   46,   46,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    1,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   10,    0,    0,    0,   46,   46,   46,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    1,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   46,   46,   46,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       46,   46,    6,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   46,   46,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    6,    0,    0,    0,    0,    0,
+        0,   46,   46,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,   46,   46,    0,    0,   43,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    4,   46,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    5,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    4,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    5,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   38,   24,    0,    0,   23,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   38,   24,    0,    0,   23,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   24,
+        0,    0,   23,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   31,    0,    0,    0,    0,    0,    0,    0,
+        0,   24,    0,   23,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   34,    0,
+
+        0,   24,    7,   23,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   42,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   37,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+       37,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   39,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   40,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   40,    0,    0,
+        0,   33,    0,    0,    0,    0,    0,    0,    0,    0,
+       40,    0,    0,    0,    0,   36,    0,    0,    0,    0,
+        0,    0,   40,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   40,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   40,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   28,    0,    0,    0,    0,    0,    0,    0,   27,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,   29,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   29,
+        0,    0,    0,    0,    0,    0,    0,    0,   30,    0,
+        0,    0,    0,   26,    0,   32,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   41,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   35,    0
+
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    1,    4,    1,    1,    1,    1,    5,    6,
+        7,    1,    1,    8,    9,   10,   11,   12,   13,   14,
+       15,   15,   15,   15,   15,   16,   15,   17,    1,   18,
+       19,   20,    1,   21,   22,   23,   24,   25,   26,   27,
+       28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
+       29,   38,   39,   40,   29,   41,   42,   43,   29,   29,
+       44,    1,   45,    1,   46,    1,   47,   48,   49,   50,
+
+       51,   52,   53,   54,   55,   29,   56,   57,   58,   59,
+       60,   61,   29,   62,   63,   64,   65,   66,   67,   68,
+       69,   70,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[71] =
+    {   0,
+        1,    2,    3,    4,    1,    5,    6,    1,    7,    8,
+        9,   10,   10,   10,   10,   10,   11,    1,    1,   12,
+       13,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,    1,   15,   16,   17,   17,   17,   17,
+       17,   17,   14,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14
+    } ;
+
+static yyconst flex_int16_t yy_base[1524] =
+    {   0,
+        0,    0, 2884, 2885, 2885, 2880,   68, 2879, 2861,   55,
+     2863,   56,   57,   58,   59,   61,   62,   69,   70,   71,
+       75,   74, 2834,   78,   79,   82,   76,   77,   83,   84,
+       81, 2875,  142,   59, 2874, 2859, 2872,   94,   87,   97,
+       98,   93,   86,  101,  116,  119,  100,   72,  123,  144,
+      146,  147,  148, 2829, 2810,  149,  150,  153,  154,  155,
+      161,  157,  164,  162,  159,  165,  160,  163,  166,  167,
+      189, 2821, 2849, 2852, 2834,  168,  183,  171,  176,  173,
+      177,  194, 2799,  178,  179,  190,  223,  213,  214,  218,
+      221,  220,  222,  226,  227,  242,  229,  230,  233,  286,
+
+     2818, 2801,  240, 2814,  245,  265,  251,  254,  232,  270,
+     2801, 2800,  253,  257,  268, 2792,  295,  269,  241,  309,
+      311,  280,  279,  299,  302,  298, 2791,  303,  319,  305,
+      306,  307,  310,  333, 2809, 2795,  347, 2794,  334,  362,
+      369,  376, 2808,  335, 2807, 2786, 2790,  308,  347,  323,
+     2793,  387,  348,  324, 2788, 2793,  326,  337,  397,  402,
+      376, 2790,  363,  414,  377,  387,  338,  388,  435, 2794,
+     2794,  427,  443, 2808, 2781,  448, 2842,  453,  460, 2784,
+      355, 2783, 2779, 2790,  402,  389,  429, 2781,  465,  473,
+      437,  454, 2770, 2787,  390,  478,  488,  493,  465, 2778,
+
+      478,  505,  514,  479,  480,  414,  493,  533, 2770, 2832,
+      541, 2824, 2784, 2769,  519,  548, 2821, 2771, 2812,  495,
+     2769, 2763, 2768,    0,  520,  505, 2774,  556, 2814,  521,
+      522, 2762, 2759,  535,  564,  415, 2770,  542,  579, 2810,
+      550,  556,  557,  565,  606, 2768, 2761,  584,  618, 2755,
+     2765, 2798,  589,  625, 2762, 2810, 2754, 2808, 2758, 2758,
+     2799, 2804,  567,  566, 2787,  630,  637,  494,  569, 2754,
+     2741,  609,  572, 2784,  610,  642,  650,  591,  619,  631,
+      650,  651,  652,  667, 2752, 2741,  679, 2790, 2748, 2736,
+      659,  692, 2787, 2741,  687, 2732, 2764, 2738, 2734,  657,
+
+     2785,  668,  669,    0,  716, 2780,  706,  721, 2770, 2741,
+      680, 2784,  693,  675,    0,  696,  735, 2776,  726,  706,
+      710,  697,  698,  726,  755, 2782, 2731,  740,  765, 2732,
+     2779,  770,  775,  782, 2728, 2732, 2719, 2746, 2726, 2723,
+     2716, 2721, 2770, 2713, 2711, 2723,    0,    0,    0,    0,
+      787,  794,  799,  804,  809, 2716,  814, 2762,  770,  802,
+        0,  828,  827,  834,  839,  746,  776,  815,  816,  854,
+      864, 2720, 2711,  846, 2755, 2705,    0, 2746,  870, 2752,
+     2696, 2700, 2701, 2732, 2694,  860, 2701, 2690, 2705, 2701,
+     2688, 2689, 2743,    0,    0,    0,  879, 2739,  884,  889,
+
+     2697,  894,    0,  520, 2744,    0, 2691,  899, 2735,  904,
+     2740,  870,  820,  871, 2688,  921, 2739, 2682,  927, 2737,
+     2885, 2736,  936,  941, 2885, 2676, 2675, 2675, 2732, 2673,
+     2703, 2677, 2667, 2668, 2672, 2668, 2672, 2667, 2885,    0,
+        0,  950,  955, 2722, 2717,  861,  925, 2662,  960,  965,
+      970,  929,  872,  942, 2661,  990, 2662, 2717, 2699, 2681,
+      811,  976, 2697, 2669, 2651, 2657, 2651, 2652, 2686, 2660,
+     2654, 2661, 2647, 2644, 2653, 2649, 2885,  982, 2641, 2885,
+      957, 2647, 2682, 2885,  996, 1001,  983, 1001, 1003, 2681,
+     1019, 2639,  877, 2644, 2650, 2636, 2692, 2630, 2642, 2641,
+
+     2640, 2631, 2686, 2641, 2623, 2637, 2627, 2629, 2624, 2885,
+     2631, 1018, 2615, 1011, 2885, 1025, 1012, 1025,  757, 1031,
+     1045, 2616, 2611, 2631, 2630, 2629, 2612, 2621,    0, 2618,
+     2622, 2607, 2607, 2619, 2650, 2603, 2611, 2609, 2617, 2614,
+     2609, 2600, 2657, 2608, 1053, 1065, 1032, 1034, 1076, 1087,
+     1101, 2603, 2596, 2601, 2592, 2591, 2650,  870,    0, 2592,
+     2648, 2599, 2588, 2597, 2627, 2595, 2585, 2641, 2579, 2595,
+     2632, 2589, 1046, 2636, 1093, 1109, 2629, 1036, 1056, 1114,
+     1120, 1127, 1135, 2585, 2581, 2578, 2631, 2582, 2575, 2580,
+     2571, 2570, 2569, 2577, 2566, 2563, 2604, 2606, 2572, 2562,
+
+     2566, 2564, 2554, 1141, 2570, 2561, 2609, 1148, 2604, 1153,
+     1053, 1128, 2610, 1160, 2602, 1168, 2556, 2548, 2558, 2561,
+     2604, 2556, 2602, 2601, 2552, 2599, 2542, 2597, 2596, 2595,
+     2594, 2549, 2535, 2539, 1177, 2529, 2534, 2527, 1183, 1190,
+     1195, 1066, 1142, 1200, 1207, 1215, 2541, 2538, 2538, 2539,
+     2573, 2582, 2537, 2532, 2529, 1203, 2531, 2517, 1047, 2520,
+     2514, 2514, 2517, 2515, 2885, 2523, 2522, 2523, 1226, 2561,
+     2561, 1231, 1169, 1244, 2559, 2561, 2520, 2516, 2562, 2504,
+     2546, 1206, 2498, 2502, 2500, 2506, 2511, 2497, 2505, 2491,
+     2494, 2502, 2501, 2491, 2547, 2540, 2489, 2497, 2485, 1237,
+
+     1255, 1260, 1265, 1271, 1277, 1284, 2885, 2481, 2541, 2491,
+     2480, 2538, 2481, 1236, 2475, 2488, 2473, 2483, 2480, 2472,
+     2471, 2485, 2473, 2467, 2476, 2525, 2479, 1290, 2517, 2522,
+     2517, 1304, 2513, 1296, 2519, 1309, 1324, 2511, 2465, 2472,
+     2457, 2452, 2484, 2510, 2448, 2458, 2457, 2452, 2444, 2446,
+     2501, 2498, 2438, 2436, 2435, 2433, 2462, 2439, 1316, 1329,
+     1334, 2426, 1348, 2483, 2418, 2477, 2416, 1353, 2416, 2416,
+     2412, 2421, 2410, 1305, 2410, 2414, 2415, 2394, 2438, 2374,
+     2383, 2371, 2377, 2372, 2367, 2393, 2376, 2885, 1364, 1370,
+     2366, 2421, 1375, 2361, 2360, 2416, 2356, 2363, 2408, 2359,
+
+     2353, 2346, 2350, 2343, 2398, 2336, 2336, 2340, 2333, 2345,
+     2327, 2338, 2327, 2325, 2376, 2318, 2885, 2312, 2313, 1380,
+     2327, 2311, 2369, 2368, 2317, 2305, 2306, 2317, 2298, 2313,
+     2305, 2295, 2293, 2300, 2287, 2346, 2283, 2293, 2295, 2293,
+     2336, 2283, 2272, 2318, 2282, 2269, 2274, 2261, 2279, 2270,
+     2321, 2319, 2248, 2255, 2259, 2263, 2249, 2304, 1060, 2255,
+     2253, 2239, 2252, 2236, 2242, 2280, 1385, 2246, 2278, 2245,
+     2248, 2228, 2244, 2247, 2248, 2281, 2222, 2214, 2227, 2274,
+     2223, 2242, 2245, 2216, 2215, 2199, 2202,   52,  197, 1390,
+     1395,  289, 1400,  359,  452,  492,  637,  708,  784,  792,
+
+      811,  871,  942, 1037, 1013, 1056, 1065, 1117, 1143, 1119,
+     1125, 1176, 1170, 1405, 1217, 1186, 1410, 1199, 1260, 1197,
+     1262, 1266, 1277, 1288, 1349, 1294, 1334, 1291, 1320, 1324,
+     1313, 1310, 1316, 1376, 1381, 2885, 1417, 1422, 1432, 1428,
+     1398, 1382, 1400, 1398, 1443, 1391, 1388, 1404, 1402, 1434,
+     1445, 1405, 1431, 1455, 1408, 1400, 1398, 1399, 1399, 1452,
+     1457, 1457, 1463, 1427, 1430, 1413, 1480, 1430, 1434, 1430,
+     1436, 1435, 2885, 1440, 1451, 1433, 1439, 1490, 1484, 1432,
+     1445, 1485, 1498, 1491, 1457, 1447, 1507, 1452, 1448, 1449,
+     1511, 1466, 1456, 1453, 1479, 1459, 1460, 1457, 2885, 1519,
+
+     1473, 2885, 2885, 2885, 1521, 1467, 1508, 1476, 1464, 1526,
+        0, 1483, 1467, 1481, 1503, 1484, 1471, 1482, 1525, 1539,
+     1491, 1489, 1525, 1493, 1486, 1496,    0, 1484, 1495, 1501,
+     1511, 1502, 1499, 1504, 1546, 1493, 1503, 1505, 1545, 1558,
+     1507, 1561, 1507, 1507, 1524, 1569, 1547, 1571, 1528, 1573,
+     1565, 1572, 1529, 1527, 1543, 1588, 1528, 1590, 1534, 1544,
+     1532, 1562, 1539, 1535, 1548, 1591, 1592, 1546, 1607, 1547,
+     1547, 1558, 1556, 1557, 1613, 1562, 1596, 1568, 1565, 1566,
+     1571, 1611, 1618, 1569,    0, 1584, 1573, 1590, 1591, 1636,
+     1576, 1581, 1602, 1590, 1584, 1583, 1595, 1637, 1638, 1589,
+
+        0, 1605, 1605, 1593, 1599, 1647, 1610, 1606, 1663, 1607,
+     1609, 1606, 1608, 1659, 1666, 1624, 1680, 1622, 1630, 1639,
+     1677, 1637, 1631, 1640, 1632, 1634, 1634, 1694, 1697, 1691,
+     1648, 1651, 1645, 1645, 1653, 1702, 1709, 1704, 1705, 1661,
+     1671, 1724, 1725, 1666, 1665, 1728, 1729, 1673, 1687, 1676,
+     1685, 1735, 1727, 1674, 1672, 1743, 1705, 1686, 1696, 1752,
+     1697, 1755, 1724, 1698, 1703, 1699, 1705, 1752, 1759, 1715,
+     1721, 1725, 1714, 1724, 1729, 1730, 1730, 1733, 1744, 1782,
+     1735, 1784, 1737, 1779, 1780, 1738, 1733, 1736, 1744, 1736,
+     1738, 1751, 1752, 1767, 1740, 1803, 1752, 1749, 1797, 1804,
+
+     1764, 1767, 1762, 1763, 1770, 1762, 1764, 1765, 1818, 1766,
+     1812, 1772, 1768, 1821, 1829, 1837, 1838, 1783, 1784, 1841,
+     1798, 1843, 1844, 2885, 1797, 1829, 1847, 1848, 1840, 1846,
+     1806, 1817, 1801, 1803, 1828, 1815, 1811, 1818, 1809, 1852,
+     1865, 1816, 1869, 1859, 1874, 1823, 1876, 1877, 1871, 1845,
+     1832, 1829, 1826, 1888, 1845, 1832, 1842, 1892, 1838, 1879,
+     1838, 2885, 1869, 1890, 1844, 1855, 1841, 1854, 1850, 1864,
+     1909, 1858, 1902, 1867, 1917, 2885, 1875, 1869, 1877, 1870,
+     1868, 1876, 1929, 1869, 1934, 1931, 1917, 1877, 1886, 1874,
+     1936, 1876, 1894, 1949, 1950, 1946, 1892, 1937, 1911, 1956,
+
+     1898, 1903, 1959, 1912, 1910, 1902, 1912, 1947, 1960, 1911,
+     1952, 1902, 1912, 1957, 1924, 1928, 1925, 1926, 1975, 1928,
+     1960, 1964, 1932, 1971, 1974, 1922, 1937, 1984, 1924, 1986,
+     1970, 1988, 1989, 1942, 1987, 2885, 1992, 1936, 1935, 1933,
+        0, 1952, 1988, 1995, 1955, 1948, 1957, 1950, 2007, 1947,
+     2004, 2885, 1956, 1965, 1963, 1963, 1975, 2021, 2022, 2885,
+     1979, 2024, 1968, 1978, 1961, 2013, 1968, 1972, 1977, 1971,
+     1979, 2034, 2026, 1988, 1981, 1990, 1995, 2044, 2001, 2039,
+     1992, 2005, 2005, 2055, 2029, 2010, 2049, 2056, 2016, 2023,
+     2023, 2025, 2051, 2019, 2068, 2069, 2025, 2076, 2023, 2037,
+
+     2086, 2035, 2079, 2086, 2032, 2100, 2049, 2039, 2088, 2048,
+     2098, 2099, 2051, 2110, 2059, 2063, 2107, 2069, 2113, 2120,
+     2114, 2130, 2087, 2090, 2128, 2082, 2137, 2136, 2144, 2885,
+     2147, 2145, 2105, 2150, 2095, 2148, 2155, 2157, 2885, 2156,
+     2164, 2112, 2155, 2885, 2166, 2885, 2130, 2136, 2125, 2121,
+     2136, 2127, 2185, 2127, 2133, 2188, 2137, 2145, 2142, 2126,
+     2145, 2194, 2134, 2152, 2145, 2151, 2144, 2145, 2153, 2150,
+     2203, 2148, 2190, 2206, 2198,    0, 2203,    0, 2217, 2158,
+     2171, 2175, 2165, 2167, 2177, 2165, 2218, 2212, 2219, 2224,
+     2238, 2210, 2220, 2235, 2885, 2885, 2239, 2254, 2265, 2276,
+
+     2234, 2244, 2291, 2245, 2246, 2302, 2313, 2327, 2338, 2349,
+     2364, 2377, 2385, 2400, 2411, 2426, 2443, 2453, 2461, 2471,
+     2481, 2493, 2501
+    } ;
+
+static yyconst flex_int16_t yy_def[1524] =
+    {   0,
+     1496,    1, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1497,
+     1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497,
+     1497, 1497, 1498, 1497, 1497, 1497, 1497, 1497, 1497, 1497,
+     1497, 1496, 1496, 1496, 1496, 1497, 1496, 1497, 1497, 1497,
+     1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497,
+     1497, 1497, 1497, 1498, 1496, 1497, 1497, 1497, 1497, 1497,
+     1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497,
+     1496, 1496, 1496, 1496, 1496, 1497, 1497, 1497, 1497, 1497,
+     1497, 1497, 1496, 1497, 1497, 1497, 1497, 1497, 1497, 1497,
+     1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1497, 1496,
+
+     1496, 1496, 1496, 1496, 1497, 1496, 1496, 1497, 1497, 1497,
+     1496, 1496, 1497, 1497, 1497, 1496, 1496, 1497, 1497, 1497,
+     1497, 1497, 1497, 1497, 1497, 1497, 1496, 1497, 1496, 1497,
+     1497, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1497, 1496,
+     1496, 1496, 1496, 1497, 1496, 1496, 1496, 1497, 1497, 1497,
+     1496, 1496, 1497, 1497, 1496, 1496, 1497, 1497, 1496, 1496,
+     1497, 1496, 1497, 1496, 1497, 1497, 1497, 1497, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1497, 1497, 1497, 1496, 1496, 1496,
+     1497, 1497, 1496, 1496, 1497, 1496, 1496, 1496, 1497, 1496,
+
+     1497, 1496, 1496, 1497, 1497, 1497, 1497, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1499, 1497, 1497, 1496, 1496, 1496, 1497,
+     1497, 1496, 1496, 1497, 1496, 1497, 1496, 1497, 1496, 1496,
+     1497, 1497, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1499, 1497, 1497, 1496, 1496, 1496, 1497, 1497, 1496,
+     1496, 1497, 1500, 1496, 1497, 1496, 1496, 1497, 1497, 1497,
+     1497, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1497, 1497, 1501, 1496, 1496, 1496, 1496, 1496, 1496,
+     1497, 1500, 1500, 1500, 1502, 1497, 1496, 1496, 1496, 1497,
+     1497, 1497, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1503, 1504, 1505, 1506,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1500, 1500,
+     1507, 1497, 1496, 1496, 1496, 1497, 1497, 1497, 1497, 1497,
+     1496, 1496, 1496, 1496, 1496, 1496, 1508, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1503, 1509, 1510, 1506, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1511, 1500, 1500, 1507, 1496, 1496, 1496, 1496,
+     1496, 1497, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1508, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1509,
+     1510, 1496, 1496, 1496, 1511, 1500, 1496, 1496, 1496, 1496,
+     1496, 1497, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1500, 1496, 1496, 1496, 1496, 1496, 1497, 1497, 1497, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1500, 1496, 1496, 1496, 1496, 1497, 1497, 1497, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1512, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1500, 1496, 1496, 1496, 1497, 1497, 1497, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1512, 1496,
+     1496, 1496, 1496, 1496, 1513, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1497, 1497, 1497,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1513, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1497, 1497, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1497, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1514, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1514,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1515, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1516, 1496, 1496, 1496, 1515, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1516, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1517, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1517, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1518, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1518,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1519, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1519, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1520, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1520, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1521, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1521, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1522, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1522, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1523, 1496, 1523, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496,    0, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496
+    } ;
+
+static yyconst flex_int16_t yy_nxt[2956] =
+    {   0,
+        4,    5,    6,    4,    4,    7,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    8,    4,    4,    9,
+        4,   10,   11,   11,   12,   11,   13,   11,   11,   14,
+       15,   11,   16,   17,   18,   19,   20,   11,   21,   22,
+       11,   11,   11,   23,    4,    4,   24,   11,   11,   25,
+       11,   11,   11,   11,   26,   11,   27,   11,   11,   11,
+       28,   29,   30,   31,   11,   11,   11,   11,   11,   11,
+       33,   37,   37,   37,   37,   37,   33,   37,   37,   33,
+       33,   33,   33,   33,   33,   37,   37,   37,   37,   43,
+       37,   37,   37,   37,   37,   37,   72,   37,   37,   37,
+
+       37,   73,   37,   37,   38,   44,   41,   42,   47,   37,
+       37,   78,  912,   37,   37,   39,   37,   37,   49,   40,
+       46,   51,   62,   45,   50,   52,   56,   53,   48,   57,
+       61,   65,   37,   58,   66,   37,   63,   77,   64,   37,
+       77,   59,   70,   60,   71,   67,   77,   68,   77,   77,
+       71,   76,   69,   71,   71,   71,   71,   71,   71,   77,
+       37,   77,   37,   37,   37,   37,   37,   79,   77,   37,
+       37,   37,   77,   37,   77,   37,   37,   37,   37,   37,
+       37,   37,   37,   37,   37,  106,   77,   37,  107,   37,
+       80,  100,   37,   37,   37,   37,  111,  100,   82,   37,
+
+      100,  100,  100,  100,  100,  100,   37,   77,   96,   97,
+       37,   81,   84,   99,   86,   85,   88,   87,   89,   90,
+       91,   92,  105,   94,   93,  116,   95,  110,   98,   37,
+       37,  108,  113,  114,   37,  109,   37,   37,   37,   37,
+      115,  117,   37,   37,  127,   37,   37,  913,   37,   37,
+      128,  137,  137,  137,  137,  137,  143,   37,   37,  119,
+      129,   37,  142,  142,  142,  142,  142,  140,  118,   37,
+       37,  124,  145,   37,  120,  122,  141,  141,  141,  141,
+      141,  121,  144,  123,   37,   37,   37,  130,  134,  125,
+      131,  133,  126,  132,  134,   37,   37,  134,  134,  134,
+
+      134,  134,  134,  139,  154,  149,  152,  152,  152,  152,
+      152,  155,  148,  156,   37,   37,  150,  159,   37,   37,
+      160,   37,   37,   37,   37,   37,   37,   37,  157,  153,
+      164,  164,  164,  164,  164,  169,  175,  181,  158,   37,
+       37,  169,   37,  916,  169,  169,  169,  169,  169,  169,
+       37,   37,  161,   37,   37,  196,  172,  167,  173,  173,
+      173,  173,  173,   37,   37,  165,  185,  219,  220,  166,
+      163,  176,  168,  141,  141,  141,  141,  141,  192,   37,
+      177,  177,  177,  177,  177,  178,  187,  179,  179,  179,
+      179,  179,   37,   37,  195,  206,  189,  186,  190,  190,
+
+      190,  190,  190,   37,   37,   37,   37,  191,  197,  197,
+      197,  197,  197,  198,  198,  198,  198,  198,   37,  201,
+      224,  918,  243,  202,  199,  203,  203,  203,  203,  203,
+       37,   37,  205,  273,  225,  234,  204,  208,  211,  211,
+      211,  211,  211,  208,  207,   37,  208,  208,  208,  208,
+      208,  208,  172,   37,  212,  212,  212,  212,  212,  215,
+      215,  215,  215,  215,  216,  216,  216,  216,  216,  178,
+       37,  217,  217,  217,  217,  217,  228,  228,  228,  228,
+      228,   37,  189,  226,  229,  229,  229,  229,  229,  235,
+      235,  235,  235,  235,   37,   37,   37,  257,  230,  197,
+
+      197,  197,  197,  197,  198,  198,  198,  198,  198,   37,
+       37,  258,  307,  231,  919,  236,  239,  239,  239,  239,
+      239,   37,  358,  202,  238,  240,  240,  240,  240,  240,
+      252,  252,  252,  252,  252,  245,   37,   37,   37,  244,
+      241,  245,  920,  242,  245,  245,  245,  245,  245,  245,
+      248,   37,  249,  249,  249,  249,  249,  253,   37,  254,
+      254,  254,  254,  254,  264,  266,   37,  267,  267,  267,
+      267,  267,   37,   37,  263,  235,  235,  235,  235,  235,
+      269,   37,   37,   37,  268,   37,  446,  308,  276,  272,
+      277,  277,  277,  277,  277,  287,  287,  287,  287,  287,
+
+      292,  292,  292,  292,  292,  275,  313,   37,  284,  319,
+      279,  280,  314,  278,  284,  281,  302,  284,  284,  284,
+      284,  284,  284,  282,  303,   37,   37,  248,  283,  288,
+      288,  288,  288,  288,  253,   37,  293,  293,  293,  293,
+      293,  305,  305,  305,  305,  305,  266,   37,  306,  306,
+      306,  306,  306,  317,  317,  317,  317,  317,  311,  276,
+      316,  318,  318,  318,  318,  318,   37,   37,   37,  325,
+      332,  332,  332,  332,  332,  325,  320,  358,  325,  325,
+      325,  325,  325,  325,   37,   37,  348,  349,  328,  321,
+      329,  329,  329,  329,  329,  358,   37,  323,  357,  360,
+
+      921,  333,  324,  334,  334,  334,  334,  334,  336,  322,
+      337,  344,   37,   37,   37,  345,  338,  353,  353,  353,
+      353,  353,   37,  346,  339,  351,   37,  352,  352,  352,
+      352,  352,  354,  354,  354,  354,  354,  365,  365,  365,
+      365,  365,   37,  359,  363,  362,  364,  364,  364,  364,
+      364,  374,  374,  374,  374,  374,  366,  371,  922,  369,
+      368,  367,   37,  371,  411,  549,  371,  371,  371,  371,
+      371,  371,  358,   37,  328,  370,  375,  375,  375,  375,
+      375,  378,  378,  378,  378,  378,  379,  379,  379,  379,
+      379,  333,   37,  380,  380,  380,  380,  380,  397,  397,
+
+      397,  397,  397,  351,  358,  398,  398,  398,  398,  398,
+      399,  399,  399,  399,  399,  354,  354,  354,  354,  354,
+      400,  400,  400,  400,  400,  402,  402,  402,  402,  402,
+      407,   37,   37,  404,  923,  412,   37,  405,  408,  408,
+      408,  408,  408,  363,   37,  409,  409,  409,  409,  409,
+      410,  410,  410,  410,  410,  924,  415,  419,  419,  419,
+      419,  419,  431,  358,  495,  420,  416,  496,  432,  413,
+       37,  453,  416,  925,  414,  416,  416,  416,  416,  416,
+      416,  424,  424,  424,  424,  424,   37,   37,   37,  425,
+      442,  442,  442,  442,  442,  443,  443,  443,  443,  443,
+
+      400,  400,  400,  400,  400,  402,  402,  402,  402,  402,
+      449,  449,  449,  449,  449,  450,  450,  450,  450,  450,
+      481,  779,  590,  456,  591,  454,  488,  523,  524,  456,
+      403,  452,  456,  456,  456,  456,  456,  456,  459,  459,
+      459,  459,  459,  525,  926,   37,  420,  462,  462,  462,
+      462,  462,  463,  463,  463,  463,  463,  482,   37,  358,
+      425,  477,  477,  477,  477,  477,  478,  478,  478,  478,
+      478,  484,  484,  484,  484,  484,  485,  485,  485,  485,
+      485,  486,  486,  486,  486,  486,  487,  497,  497,  497,
+      497,  497,  491,  510,  510,  510,  510,  510,  491,   37,
+
+      489,  491,  491,  491,  491,  491,  491,  515,  515,  515,
+      515,  515,  516,  516,  516,  516,  516,   37,  512,   37,
+      358,  521,  545,  545,  545,  545,  545,  521,   37,  517,
+      521,  521,  521,  521,  521,  521,  546,  546,  546,  546,
+      546,   37,  550,  550,  550,  550,  550,  551,   37,  518,
+       37,  403,   37,  551,  927,  519,  551,  551,  551,  551,
+      551,  551,  575,  928,  576,  576,  576,  576,  576,   37,
+      691,  548,   37,  543,  672,  547,  577,  577,  577,  577,
+      577,  882,   37,  929,  692,  606,  578,  580,  580,  580,
+      580,  580,   37,  883,  930,  611,  581,  579,  582,  582,
+
+      582,  582,  582,  583,  608,  608,  608,  608,  608,  583,
+      612,  642,  583,  583,  583,  583,  583,  583,  575,  931,
+      609,  609,  609,  609,  609,  580,  580,  580,  580,  580,
+      613,  614,  614,  614,  614,  614,  581,  616,  615,  615,
+      615,  615,  615,  616,   37,  932,  616,  616,  616,  616,
+      616,  616,  635,  635,  635,  635,  635,  639,   37,  640,
+      640,  640,  640,  640,  641,  641,  641,  641,  641,  644,
+      646,  645,  645,  645,  645,  645,  646,  704,  933,  646,
+      646,  646,  646,  646,  646,   37,  934,  643,  635,  635,
+      635,  635,  635,  665,  669,  669,  669,  669,  669,  639,
+
+      673,  670,  670,  670,  670,  670,  671,  671,  671,  671,
+      671,  674,  674,  674,  674,  674,  644,  676,  675,  675,
+      675,  675,  675,  676,  686,  935,  676,  676,  676,  676,
+      676,  676,  936,  938,  939,  700,  687,  701,  701,  701,
+      701,  701,  703,  703,  703,  703,  703,   37,  732,  732,
+      732,  732,  732,  705,  688,  706,  706,  706,  706,  706,
+      713,  941,  942,  943,  700,  714,  733,  733,  733,  733,
+      733,  734,  734,  734,  734,  734,  703,  703,  703,  703,
+      703,  735,  736,  736,  736,  736,  736,   37,  737,  737,
+      737,  737,  737,  705,  744,  738,  738,  738,  738,  738,
+
+      745,  759,  759,  759,  759,  759,  762,  764,  764,  764,
+      764,  764,  944,  945,  765,  763,  763,  763,  763,  763,
+      736,  736,  736,  736,  736,  766,  767,  759,  759,  759,
+      759,  759,  788,  946,  947,  768,  768,  768,  768,  768,
+      789,  789,  789,  789,  789,  790,  790,  790,  790,  790,
+      762,  948,  949,  951,  952,  767,  802,  953,  954,  792,
+      792,  792,  792,  792,  796,  796,  796,  796,  796,  765,
+      803,  955,  818,  956,  957,  789,  789,  789,  789,  789,
+      817,  790,  790,  790,  790,  790,  820,  820,  820,  820,
+      820,  844,  844,  844,  844,  844,  891,  891,  891,  891,
+
+      891,  914,  914,  914,  914,  914,  915,  915,  915,  915,
+      915,  917,  917,  917,  917,  917,  937,  937,  937,  937,
+      937,  940,  940,  940,  940,  940,  958,  959,  960,  960,
+      960,  960,  960,  961,  961,  961,  961,  961,  962,  963,
+      963,  963,  963,  963,  964,  965,  966,  967,  968,  969,
+      970,  971,  972,  951,  973,  974,  975,  976,  977,  978,
+      979,  980,  981,  982,  982,  982,  982,  982,  983,  983,
+      983,  983,  983,  817,  984,  984,  984,  984,  984,  985,
+      986,  987,  988,  989,  990,  991,  992,  993,  994,  995,
+      996,  997,  998,  999, 1000, 1001, 1002, 1002, 1002, 1002,
+
+     1002, 1003, 1004, 1004, 1004, 1004, 1004, 1005, 1006, 1007,
+     1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017,
+     1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1028,
+     1029, 1030, 1031, 1032, 1033, 1034, 1035, 1035, 1035, 1035,
+     1035, 1036, 1037, 1038, 1040, 1041, 1042, 1043, 1044, 1045,
+     1046, 1047, 1048, 1049, 1050, 1051, 1053, 1052, 1052, 1052,
+     1052, 1052, 1054, 1055, 1040, 1056, 1057, 1058, 1059, 1060,
+     1061, 1062,  954, 1063, 1064, 1065, 1066, 1066, 1066, 1066,
+     1066, 1051, 1068, 1067, 1067, 1067, 1067, 1067, 1069, 1070,
+     1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080,
+
+     1082, 1051, 1083, 1083, 1083, 1083, 1083, 1084, 1081, 1085,
+     1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095,
+     1096, 1097, 1098, 1098, 1098, 1098, 1098, 1082, 1100, 1099,
+     1099, 1099, 1099, 1099, 1102, 1103, 1104, 1105, 1106, 1107,
+     1108, 1109, 1110, 1111, 1112, 1113, 1114, 1082, 1115, 1115,
+     1115, 1115, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1121,
+     1121, 1121, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128,
+     1129, 1129, 1129, 1129, 1129, 1114, 1131, 1130, 1130, 1130,
+     1130, 1130, 1132, 1133, 1134, 1135, 1136, 1138, 1137, 1137,
+     1137, 1137, 1137, 1139, 1140, 1141, 1142, 1143, 1144, 1145,
+
+     1114, 1147, 1148, 1149, 1150, 1151, 1154, 1155, 1146, 1146,
+     1146, 1146, 1146, 1152, 1152, 1152, 1152, 1152, 1136, 1156,
+     1153, 1153, 1153, 1153, 1153, 1157, 1158, 1159, 1160, 1161,
+     1145, 1163, 1164, 1165, 1166, 1167, 1136, 1170, 1171, 1162,
+     1162, 1162, 1162, 1162, 1168, 1172, 1169, 1169, 1169, 1169,
+     1169, 1173, 1174, 1175, 1177, 1178, 1176, 1145, 1179, 1180,
+     1181, 1182, 1183, 1184, 1184, 1184, 1184, 1184, 1168, 1186,
+     1185, 1185, 1185, 1185, 1185, 1187, 1188, 1189, 1190, 1191,
+     1192, 1080, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1168,
+     1200, 1200, 1200, 1200, 1200, 1201, 1202, 1203, 1204, 1205,
+
+     1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1214,
+     1214, 1214, 1214, 1199, 1216, 1215, 1215, 1215, 1215, 1215,
+     1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226,
+     1227, 1228, 1229, 1229, 1229, 1229, 1229, 1230, 1199, 1231,
+     1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1241, 1242,
+     1243, 1244, 1244, 1244, 1244, 1244, 1230, 1245, 1245, 1245,
+     1245, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1175, 1252,
+     1253, 1241, 1254, 1255, 1256, 1230, 1257, 1259, 1260, 1261,
+     1262, 1263, 1264, 1265, 1266, 1258, 1258, 1258, 1258, 1258,
+     1267, 1268, 1269, 1270, 1257, 1272, 1273, 1274, 1275, 1276,
+
+     1277, 1278, 1279, 1271, 1271, 1271, 1271, 1271, 1280, 1281,
+     1282, 1257, 1284, 1285, 1285, 1285, 1285, 1285, 1286, 1287,
+     1283, 1283, 1283, 1283, 1283, 1288, 1289, 1290, 1291, 1292,
+     1293, 1257, 1295, 1297, 1298, 1299, 1300, 1301, 1302, 1303,
+     1294, 1294, 1294, 1294, 1294, 1285, 1285, 1285, 1285, 1285,
+     1304, 1257, 1305, 1296, 1306, 1307, 1309, 1310, 1311, 1312,
+     1313, 1314, 1315, 1316, 1317, 1318, 1309, 1319, 1320, 1321,
+     1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1332,
+     1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1332,
+     1342, 1343, 1344, 1010, 1345, 1346, 1347, 1348, 1350, 1351,
+
+     1351, 1351, 1351, 1351, 1352, 1353, 1354, 1355, 1356, 1357,
+     1358, 1359, 1361, 1360, 1362, 1351, 1351, 1351, 1351, 1351,
+     1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372,
+     1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1380, 1380,
+     1380, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1389,
+     1388, 1388, 1388, 1388, 1388, 1390, 1391, 1392, 1393, 1394,
+     1395, 1395, 1395, 1395, 1395, 1387, 1397, 1396, 1396, 1396,
+     1396, 1396, 1398, 1399, 1400, 1401, 1402, 1403, 1387, 1404,
+     1404, 1404, 1404, 1404, 1405, 1406, 1407, 1408, 1409, 1410,
+     1411, 1411, 1411, 1411, 1411, 1403, 1413, 1412, 1412, 1412,
+
+     1412, 1412, 1414, 1415, 1416, 1417, 1418, 1419, 1403, 1420,
+     1420, 1420, 1420, 1420, 1421, 1422, 1423, 1424, 1425, 1425,
+     1425, 1425, 1425, 1426, 1427, 1427, 1427, 1427, 1427, 1419,
+     1429, 1428, 1428, 1428, 1428, 1428, 1430, 1432, 1433, 1425,
+     1425, 1425, 1425, 1425, 1435, 1419, 1438, 1434, 1436, 1436,
+     1436, 1436, 1436, 1430, 1439, 1440, 1437, 1441, 1442, 1443,
+     1443, 1443, 1443, 1443, 1444, 1446, 1447, 1437, 1445, 1445,
+     1445, 1445, 1445, 1448, 1437, 1360, 1449, 1445, 1445, 1445,
+     1445, 1445, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457,
+     1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467,
+
+     1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477,
+     1477, 1477, 1477, 1477, 1477, 1477, 1477, 1477, 1477, 1480,
+     1481, 1482, 1479, 1483, 1484, 1485, 1486, 1487, 1488, 1489,
+     1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490, 1490,
+     1492, 1493, 1494, 1491, 1495,   36,   36,  350,   36,   36,
+      350,  911,   36,  910,   36,   36,   54,  361,  394,  395,
+      361,  394,  395,   54,  909,  908,  907,   54,   54,  906,
+       54,  262,  905,  262,  262,  262,  904,  903,  262,  902,
+      901,  262,  312,  900,  312,  312,  312,  899,  898,  312,
+      897,  896,  312,  393,  895,  894,  893,  892,  890,  889,
+
+      888,  887,  886,  885,  393,  884,  881,  393,  396,  396,
+      880,  396,  879,  878,  877,  396,  876,  396,  396,  406,
+      406,  875,  406,  874,  873,  872,  406,  871,  406,  406,
+      422,  870,  869,  868,  867,  866,  422,  865,  864,  863,
+      422,  862,  861,  422,  440,  440,  860,  440,  859,  858,
+      857,  440,  856,  440,  440,  441,  441,  855,  441,  854,
+      853,  744,  441,  852,  441,  441,  445,  851,  850,  849,
+      848,  847,  846,  845,  843,  842,  841,  445,  840,  839,
+      445,  559,  559,  559,  559,  838,  559,  559,  837,  836,
+      559,  835,  559,  559,  597,  834,  597,  833,  832,  831,
+
+      830,  597,  950,  829,  828,  827,  950,  826,  679,  950,
+      825,  950,  824,  950,  823,  950,  950, 1027,  767,  822,
+     1027, 1027,  821,  762, 1027,  819,  816, 1027, 1039,  815,
+      814,  813, 1039,  812,  811, 1039,  810, 1039,  809, 1039,
+      808, 1039, 1039, 1101,  807, 1101, 1101, 1101, 1101, 1101,
+     1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101, 1101,
+     1240,  806, 1240,  805, 1240, 1240, 1240,  804,  801, 1240,
+     1308,  800, 1308,  799,  798,  797,  795, 1308, 1331,   75,
+     1331,  794, 1331, 1331, 1331,  793,  791, 1331, 1349,  787,
+     1349,  786,  785, 1349, 1349,  784,  783, 1349, 1431,  782,
+
+      781, 1431, 1431,  780,  779,  778,  777,  776,  775, 1431,
+     1478,  744,  774,  773, 1478,  772,  771, 1478,  770,  769,
+      705,   75,  700,  480,  761,  760,  758,  757,  756,  755,
+      754,  753,  752,  751,  750,  749,  748,  747,  746,  744,
+      743,  742,  741,  740,  739,  731,  730,  729,  728,  727,
+      726,  725,  724,  723,  722,  721,  720,  719,  718,  717,
+      716,  715,  712,  711,  710,  709,  708,  707,  644,  702,
+      639,  699,  480,  698,  697,  696,  695,  694,  693,  690,
+      689,  685,  684,  683,  682,  681,  680,  679,  678,  677,
+      668,  667,  666,  664,  663,  662,  661,  660,  659,  658,
+
+      657,  656,  655,  654,  653,  652,  651,  650,  649,  648,
+      647,  581,   75,  575,  638,  637,  636,  634,  633,  632,
+      631,  630,  629,  598,  628,  627,  626,  625,  624,  623,
+      622,  496,  621,  620,  619,  618,  617,  610,  607,  605,
+      604,  603,  602,  601,  600,  599,  598,  596,  595,  594,
+      593,  592,  589,  588,  587,  586,  585,  584,  574,  573,
+      572,  571,  570,  569,  568,  567,  566,  565,  564,  563,
+      562,  561,  560,  558,  557,  556,  555,  554,  553,  552,
+      544,  542,  541,  540,  539,  538,  537,  536,  535,  534,
+      533,  532,  531,  530,  529,  528,  527,  526,  522,  520,
+
+      514,  513,  511,  509,  508,  507,  506,  505,  504,  503,
+      503,  502,  501,  500,  499,  498,  425,  494,  420,  493,
+      492,  490,  483,  480,  479,  476,  475,  474,  473,  472,
+      471,  470,  469,  468,  467,  466,  465,  464,  461,  460,
+      458,  457,  455,  451,  363,  448,  447,  444,  351,  439,
+      438,  437,  436,  435,  434,  433,  430,  429,  428,  427,
+      426,  333,  423,  421,  328,  418,  417,  403,  401,  392,
+      391,  390,  389,  388,  387,  386,  385,  384,  383,  382,
+      381,  377,  376,  373,  372,  276,  358,  356,  355,  266,
+      347,  343,  342,  341,  340,  335,  253,  331,  330,  248,
+
+      327,  326,  315,  310,  309,  304,  301,  300,  299,  298,
+      297,  296,  295,  294,  291,  290,  289,  286,  285,  202,
+      274,  271,  270,  189,  265,  261,  260,  259,  256,  255,
+      178,  251,  250,  172,  247,  246,  237,  233,  232,  227,
+      223,  222,  221,  218,  176,  214,  213,  210,  209,  200,
+      194,  193,  188,  184,  183,  182,  180,  174,  171,  170,
+      162,  151,  147,  146,  138,  136,  135,  112,  104,  103,
+      102,  101,   83,   55,   75,   37,   74,   32,   55,   37,
+       35,   34,   32, 1496,    3, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496
+    } ;
+
+static yyconst flex_int16_t yy_chk[2956] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        7,   10,   12,   13,   14,   15,    7,   16,   17,    7,
+        7,    7,    7,    7,    7,   18,   19,   20,   48,   14,
+       22,   21,   27,   28,   24,   25,   34,   31,   26,   29,
+
+       30,   34,   43,   39,   10,   15,   12,   13,   17,   42,
+       38,   43,  888,   40,   41,   10,   47,   44,   19,   10,
+       16,   21,   27,   15,   20,   21,   24,   22,   18,   25,
+       26,   29,   45,   25,   30,   46,   28,   48,   28,   49,
+       42,   25,   31,   25,   33,   30,   41,   30,   39,   40,
+       33,   38,   30,   33,   33,   33,   33,   33,   33,   44,
+       50,   47,   51,   52,   53,   56,   57,   46,   47,   58,
+       59,   60,   45,   62,   45,   65,   67,   61,   64,   68,
+       63,   66,   69,   70,   76,   77,   49,   78,   78,   80,
+       50,   71,   79,   81,   84,   85,   82,   71,   53,   77,
+
+       71,   71,   71,   71,   71,   71,   86,   52,   67,   68,
+       82,   51,   56,   70,   58,   57,   60,   59,   61,   62,
+       63,   64,   76,   66,   65,   87,   66,   81,   69,   88,
+       89,   79,   84,   85,   90,   80,   92,   91,   93,   87,
+       86,   87,   94,   95,   96,   97,   98,  889,  109,   99,
+       96,  103,  103,  103,  103,  103,  108,  119,   96,   88,
+       96,  105,  107,  107,  107,  107,  107,  106,   87,  113,
+      108,   93,  110,  114,   89,   91,  106,  106,  106,  106,
+      106,   90,  109,   92,  115,  118,  110,   96,  100,   94,
+       97,   99,   95,   98,  100,  123,  122,  100,  100,  100,
+
+      100,  100,  100,  105,  119,  114,  117,  117,  117,  117,
+      117,  120,  113,  121,  126,  124,  115,  124,  125,  128,
+      125,  130,  131,  132,  148,  120,  133,  121,  122,  118,
+      129,  129,  129,  129,  129,  134,  139,  144,  123,  150,
+      154,  134,  157,  892,  134,  134,  134,  134,  134,  134,
+      139,  144,  126,  158,  167,  158,  137,  132,  137,  137,
+      137,  137,  137,  149,  153,  130,  148,  181,  181,  131,
+      128,  141,  133,  140,  140,  140,  140,  140,  154,  163,
+      141,  141,  141,  141,  141,  142,  150,  142,  142,  142,
+      142,  142,  161,  165,  157,  167,  152,  149,  152,  152,
+
+      152,  152,  152,  166,  168,  186,  195,  153,  159,  159,
+      159,  159,  159,  160,  160,  160,  160,  160,  185,  163,
+      185,  894,  206,  164,  161,  164,  164,  164,  164,  164,
+      206,  236,  166,  236,  186,  195,  165,  169,  172,  172,
+      172,  172,  172,  169,  168,  187,  169,  169,  169,  169,
+      169,  169,  173,  191,  173,  173,  173,  173,  173,  176,
+      176,  176,  176,  176,  178,  178,  178,  178,  178,  179,
+      192,  179,  179,  179,  179,  179,  189,  189,  189,  189,
+      189,  199,  190,  187,  190,  190,  190,  190,  190,  196,
+      196,  196,  196,  196,  201,  204,  205,  220,  191,  197,
+
+      197,  197,  197,  197,  198,  198,  198,  198,  198,  207,
+      268,  220,  268,  192,  895,  199,  202,  202,  202,  202,
+      202,  226,  404,  203,  201,  203,  203,  203,  203,  203,
+      215,  215,  215,  215,  215,  208,  225,  230,  231,  207,
+      204,  208,  896,  205,  208,  208,  208,  208,  208,  208,
+      211,  234,  211,  211,  211,  211,  211,  216,  238,  216,
+      216,  216,  216,  216,  226,  228,  241,  228,  228,  228,
+      228,  228,  242,  243,  225,  235,  235,  235,  235,  235,
+      231,  244,  264,  263,  230,  269,  404,  269,  239,  234,
+      239,  239,  239,  239,  239,  248,  248,  248,  248,  248,
+
+      253,  253,  253,  253,  253,  238,  273,  278,  245,  278,
+      242,  243,  273,  241,  245,  243,  263,  245,  245,  245,
+      245,  245,  245,  243,  264,  272,  275,  249,  244,  249,
+      249,  249,  249,  249,  254,  279,  254,  254,  254,  254,
+      254,  266,  266,  266,  266,  266,  267,  280,  267,  267,
+      267,  267,  267,  276,  276,  276,  276,  276,  272,  277,
+      275,  277,  277,  277,  277,  277,  281,  282,  283,  284,
+      291,  291,  291,  291,  291,  284,  279,  314,  284,  284,
+      284,  284,  284,  284,  302,  303,  302,  303,  287,  280,
+      287,  287,  287,  287,  287,  313,  311,  282,  311,  314,
+
+      897,  292,  283,  292,  292,  292,  292,  292,  295,  281,
+      295,  300,  316,  322,  323,  300,  295,  307,  307,  307,
+      307,  307,  320,  300,  295,  305,  321,  305,  305,  305,
+      305,  305,  308,  308,  308,  308,  308,  319,  319,  319,
+      319,  319,  324,  313,  317,  316,  317,  317,  317,  317,
+      317,  328,  328,  328,  328,  328,  320,  325,  898,  323,
+      322,  321,  366,  325,  366,  519,  325,  325,  325,  325,
+      325,  325,  359,  519,  329,  324,  329,  329,  329,  329,
+      329,  332,  332,  332,  332,  332,  333,  333,  333,  333,
+      333,  334,  367,  334,  334,  334,  334,  334,  351,  351,
+
+      351,  351,  351,  352,  360,  352,  352,  352,  352,  352,
+      353,  353,  353,  353,  353,  354,  354,  354,  354,  354,
+      355,  355,  355,  355,  355,  357,  357,  357,  357,  357,
+      362,  368,  369,  359,  899,  367,  413,  360,  363,  363,
+      363,  363,  363,  364,  362,  364,  364,  364,  364,  364,
+      365,  365,  365,  365,  365,  900,  370,  374,  374,  374,
+      374,  374,  386,  446,  461,  374,  371,  461,  386,  368,
+      370,  413,  371,  901,  369,  371,  371,  371,  371,  371,
+      371,  379,  379,  379,  379,  379,  412,  414,  453,  379,
+      397,  397,  397,  397,  397,  399,  399,  399,  399,  399,
+
+      400,  400,  400,  400,  400,  402,  402,  402,  402,  402,
+      408,  408,  408,  408,  408,  410,  410,  410,  410,  410,
+      446,  902,  558,  416,  558,  414,  453,  493,  493,  416,
+      447,  412,  416,  416,  416,  416,  416,  416,  419,  419,
+      419,  419,  419,  493,  903,  452,  419,  423,  423,  423,
+      423,  423,  424,  424,  424,  424,  424,  447,  454,  481,
+      424,  442,  442,  442,  442,  442,  443,  443,  443,  443,
+      443,  449,  449,  449,  449,  449,  450,  450,  450,  450,
+      450,  451,  451,  451,  451,  451,  452,  462,  462,  462,
+      462,  462,  456,  478,  478,  478,  478,  478,  456,  487,
+
+      454,  456,  456,  456,  456,  456,  456,  485,  485,  485,
+      485,  485,  486,  486,  486,  486,  486,  488,  481,  489,
+      512,  491,  514,  514,  514,  514,  514,  491,  517,  487,
+      491,  491,  491,  491,  491,  491,  516,  516,  516,  516,
+      516,  518,  520,  520,  520,  520,  520,  521,  547,  488,
+      548,  573,  578,  521,  904,  489,  521,  521,  521,  521,
+      521,  521,  545,  905,  545,  545,  545,  545,  545,  611,
+      659,  518,  579,  512,  642,  517,  546,  546,  546,  546,
+      546,  859,  642,  906,  659,  573,  547,  549,  549,  549,
+      549,  549,  549,  859,  907,  578,  550,  548,  550,  550,
+
+      550,  550,  550,  551,  575,  575,  575,  575,  575,  551,
+      579,  611,  551,  551,  551,  551,  551,  551,  576,  908,
+      576,  576,  576,  576,  576,  580,  580,  580,  580,  580,
+      580,  581,  581,  581,  581,  581,  582,  583,  582,  582,
+      582,  582,  582,  583,  612,  909,  583,  583,  583,  583,
+      583,  583,  604,  604,  604,  604,  604,  608,  643,  608,
+      608,  608,  608,  608,  610,  610,  610,  610,  610,  614,
+      616,  614,  614,  614,  614,  614,  616,  673,  910,  616,
+      616,  616,  616,  616,  616,  673,  911,  612,  635,  635,
+      635,  635,  635,  635,  639,  639,  639,  639,  639,  640,
+
+      643,  640,  640,  640,  640,  640,  641,  641,  641,  641,
+      641,  644,  644,  644,  644,  644,  645,  646,  645,  645,
+      645,  645,  645,  646,  656,  912,  646,  646,  646,  646,
+      646,  646,  913,  915,  916,  669,  656,  669,  669,  669,
+      669,  669,  672,  672,  672,  672,  672,  672,  700,  700,
+      700,  700,  700,  674,  656,  674,  674,  674,  674,  674,
+      682,  918,  919,  920,  701,  682,  701,  701,  701,  701,
+      701,  702,  702,  702,  702,  702,  703,  703,  703,  703,
+      703,  703,  704,  704,  704,  704,  704,  704,  705,  705,
+      705,  705,  705,  706,  714,  706,  706,  706,  706,  706,
+
+      714,  728,  728,  728,  728,  728,  732,  734,  734,  734,
+      734,  734,  921,  922,  736,  732,  732,  732,  732,  732,
+      736,  736,  736,  736,  736,  736,  737,  759,  759,  759,
+      759,  759,  759,  923,  924,  737,  737,  737,  737,  737,
+      760,  760,  760,  760,  760,  761,  761,  761,  761,  761,
+      763,  925,  926,  927,  928,  768,  774,  929,  930,  763,
+      763,  763,  763,  763,  768,  768,  768,  768,  768,  789,
+      774,  931,  790,  932,  933,  789,  789,  789,  789,  789,
+      789,  790,  790,  790,  790,  790,  793,  793,  793,  793,
+      793,  820,  820,  820,  820,  820,  867,  867,  867,  867,
+
+      867,  890,  890,  890,  890,  890,  891,  891,  891,  891,
+      891,  893,  893,  893,  893,  893,  914,  914,  914,  914,
+      914,  917,  917,  917,  917,  917,  934,  935,  937,  937,
+      937,  937,  937,  938,  938,  938,  938,  938,  939,  940,
+      940,  940,  940,  940,  941,  942,  943,  944,  945,  946,
+      947,  948,  949,  950,  951,  952,  953,  954,  955,  956,
+      957,  958,  959,  960,  960,  960,  960,  960,  961,  961,
+      961,  961,  961,  962,  963,  963,  963,  963,  963,  964,
+      965,  966,  967,  968,  969,  970,  971,  972,  974,  975,
+      976,  977,  978,  979,  980,  981,  982,  982,  982,  982,
+
+      982,  983,  984,  984,  984,  984,  984,  985,  986,  987,
+      988,  989,  990,  991,  992,  993,  994,  995,  996,  997,
+      998, 1000, 1001, 1005, 1006, 1007, 1008, 1009, 1010, 1012,
+     1013, 1014, 1015, 1016, 1017, 1018, 1019, 1019, 1019, 1019,
+     1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1028, 1029,
+     1030, 1031, 1032, 1033, 1034, 1035, 1036, 1035, 1035, 1035,
+     1035, 1035, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044,
+     1045, 1046, 1047, 1048, 1049, 1050, 1051, 1051, 1051, 1051,
+     1051, 1052, 1053, 1052, 1052, 1052, 1052, 1052, 1054, 1055,
+     1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065,
+
+     1066, 1067, 1066, 1066, 1066, 1066, 1066, 1068, 1065, 1069,
+     1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079,
+     1080, 1081, 1082, 1082, 1082, 1082, 1082, 1083, 1084, 1083,
+     1083, 1083, 1083, 1083, 1086, 1087, 1088, 1089, 1090, 1091,
+     1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1098, 1098,
+     1098, 1098, 1098, 1100, 1102, 1103, 1104, 1105, 1106, 1106,
+     1106, 1106, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113,
+     1114, 1114, 1114, 1114, 1114, 1115, 1116, 1115, 1115, 1115,
+     1115, 1115, 1117, 1118, 1119, 1120, 1121, 1122, 1121, 1121,
+     1121, 1121, 1121, 1123, 1124, 1125, 1126, 1127, 1128, 1129,
+
+     1130, 1131, 1132, 1133, 1134, 1135, 1138, 1139, 1129, 1129,
+     1129, 1129, 1129, 1136, 1136, 1136, 1136, 1136, 1137, 1140,
+     1137, 1137, 1137, 1137, 1137, 1141, 1142, 1143, 1144, 1145,
+     1146, 1147, 1148, 1149, 1150, 1151, 1153, 1154, 1155, 1146,
+     1146, 1146, 1146, 1146, 1152, 1156, 1152, 1152, 1152, 1152,
+     1152, 1157, 1158, 1159, 1160, 1161, 1159, 1162, 1163, 1164,
+     1165, 1166, 1167, 1168, 1168, 1168, 1168, 1168, 1169, 1170,
+     1169, 1169, 1169, 1169, 1169, 1171, 1172, 1173, 1174, 1175,
+     1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185,
+     1184, 1184, 1184, 1184, 1184, 1186, 1187, 1188, 1189, 1190,
+
+     1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1199,
+     1199, 1199, 1199, 1200, 1201, 1200, 1200, 1200, 1200, 1200,
+     1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211,
+     1212, 1213, 1214, 1214, 1214, 1214, 1214, 1214, 1215, 1216,
+     1217, 1218, 1219, 1220, 1221, 1222, 1223, 1225, 1226, 1227,
+     1228, 1229, 1229, 1229, 1229, 1229, 1229, 1230, 1230, 1230,
+     1230, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238,
+     1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248,
+     1249, 1250, 1251, 1252, 1253, 1245, 1245, 1245, 1245, 1245,
+     1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1263, 1264,
+
+     1265, 1266, 1267, 1258, 1258, 1258, 1258, 1258, 1268, 1269,
+     1270, 1271, 1272, 1273, 1273, 1273, 1273, 1273, 1274, 1275,
+     1271, 1271, 1271, 1271, 1271, 1277, 1278, 1279, 1280, 1281,
+     1282, 1283, 1284, 1286, 1287, 1288, 1289, 1290, 1291, 1292,
+     1283, 1283, 1283, 1283, 1283, 1285, 1285, 1285, 1285, 1285,
+     1293, 1294, 1295, 1285, 1296, 1297, 1298, 1299, 1300, 1301,
+     1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311,
+     1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321,
+     1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331,
+     1332, 1333, 1334, 1335, 1337, 1338, 1339, 1340, 1342, 1343,
+
+     1343, 1343, 1343, 1343, 1344, 1345, 1346, 1347, 1348, 1349,
+     1350, 1351, 1353, 1351, 1354, 1351, 1351, 1351, 1351, 1351,
+     1355, 1356, 1357, 1358, 1359, 1361, 1362, 1363, 1364, 1365,
+     1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1373, 1373,
+     1373, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381,
+     1380, 1380, 1380, 1380, 1380, 1382, 1383, 1384, 1385, 1386,
+     1387, 1387, 1387, 1387, 1387, 1388, 1389, 1388, 1388, 1388,
+     1388, 1388, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1395,
+     1395, 1395, 1395, 1395, 1397, 1398, 1399, 1400, 1401, 1402,
+     1403, 1403, 1403, 1403, 1403, 1404, 1405, 1404, 1404, 1404,
+
+     1404, 1404, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1411,
+     1411, 1411, 1411, 1411, 1413, 1414, 1415, 1416, 1417, 1417,
+     1417, 1417, 1417, 1418, 1419, 1419, 1419, 1419, 1419, 1420,
+     1421, 1420, 1420, 1420, 1420, 1420, 1422, 1423, 1424, 1425,
+     1425, 1425, 1425, 1425, 1426, 1428, 1429, 1425, 1427, 1427,
+     1427, 1427, 1427, 1431, 1432, 1433, 1427, 1434, 1435, 1436,
+     1436, 1436, 1436, 1436, 1437, 1440, 1441, 1436, 1438, 1438,
+     1438, 1438, 1438, 1442, 1443, 1445, 1447, 1445, 1445, 1445,
+     1445, 1445, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455,
+     1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465,
+
+     1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475,
+     1475, 1475, 1475, 1475, 1477, 1477, 1477, 1477, 1477, 1479,
+     1480, 1481, 1477, 1482, 1483, 1484, 1485, 1486, 1487, 1488,
+     1489, 1489, 1489, 1489, 1489, 1490, 1490, 1490, 1490, 1490,
+     1491, 1492, 1493, 1490, 1494, 1497, 1497, 1501, 1497, 1497,
+     1501,  887, 1497,  886, 1497, 1497, 1498, 1502, 1504, 1505,
+     1502, 1504, 1505, 1498,  885,  884,  883, 1498, 1498,  882,
+     1498, 1499,  881, 1499, 1499, 1499,  880,  879, 1499,  878,
+      877, 1499, 1500,  876, 1500, 1500, 1500,  875,  874, 1500,
+      873,  872, 1500, 1503,  871,  870,  869,  868,  866,  865,
+
+      864,  863,  862,  861, 1503,  860,  858, 1503, 1506, 1506,
+      857, 1506,  856,  855,  854, 1506,  853, 1506, 1506, 1507,
+     1507,  852, 1507,  851,  850,  849, 1507,  848, 1507, 1507,
+     1508,  847,  846,  845,  844,  843, 1508,  842,  841,  840,
+     1508,  839,  838, 1508, 1509, 1509,  837, 1509,  836,  835,
+      834, 1509,  833, 1509, 1509, 1510, 1510,  832, 1510,  831,
+      830,  829, 1510,  828, 1510, 1510, 1511,  827,  826,  825,
+      824,  823,  822,  821,  819,  818,  816, 1511,  815,  814,
+     1511, 1512, 1512, 1512, 1512,  813, 1512, 1512,  812,  811,
+     1512,  810, 1512, 1512, 1513,  809, 1513,  808,  807,  806,
+
+      805, 1513, 1514,  804,  803,  802, 1514,  801,  800, 1514,
+      799, 1514,  798, 1514,  797, 1514, 1514, 1515,  796,  795,
+     1515, 1515,  794,  792, 1515,  791,  787, 1515, 1516,  786,
+      785,  784, 1516,  783,  782, 1516,  781, 1516,  780, 1516,
+      779, 1516, 1516, 1517,  778, 1517, 1517, 1517, 1517, 1517,
+     1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,
+     1518,  777, 1518,  776, 1518, 1518, 1518,  775,  773, 1518,
+     1519,  772, 1519,  771,  770,  769,  767, 1519, 1520,  766,
+     1520,  765, 1520, 1520, 1520,  764,  762, 1520, 1521,  758,
+     1521,  757,  756, 1521, 1521,  755,  754, 1521, 1522,  753,
+
+      752, 1522, 1522,  751,  750,  749,  748,  747,  746, 1522,
+     1523,  745,  744,  743, 1523,  742,  741, 1523,  740,  739,
+      738,  735,  733,  731,  730,  729,  727,  726,  725,  724,
+      723,  722,  721,  720,  719,  718,  717,  716,  715,  713,
+      712,  711,  710,  709,  708,  699,  698,  697,  696,  695,
+      694,  693,  692,  691,  690,  689,  688,  687,  686,  685,
+      684,  683,  681,  680,  679,  678,  677,  676,  675,  671,
+      670,  668,  667,  666,  664,  663,  662,  661,  660,  658,
+      657,  655,  654,  653,  652,  651,  650,  649,  648,  647,
+      638,  637,  636,  634,  633,  632,  631,  630,  629,  628,
+
+      627,  626,  625,  624,  623,  622,  621,  620,  619,  618,
+      617,  615,  613,  609,  607,  606,  605,  603,  602,  601,
+      600,  599,  598,  597,  596,  595,  594,  593,  592,  591,
+      590,  589,  588,  587,  586,  585,  584,  577,  574,  572,
+      571,  570,  569,  568,  567,  566,  565,  564,  563,  562,
+      561,  560,  557,  556,  555,  554,  553,  552,  544,  543,
+      542,  541,  540,  539,  538,  537,  536,  535,  534,  533,
+      532,  531,  530,  528,  527,  526,  525,  524,  523,  522,
+      513,  511,  509,  508,  507,  506,  505,  504,  503,  502,
+      501,  500,  499,  498,  497,  496,  495,  494,  492,  490,
+
+      483,  482,  479,  476,  475,  474,  473,  472,  471,  470,
+      469,  468,  467,  466,  465,  464,  463,  460,  459,  458,
+      457,  455,  448,  445,  444,  438,  437,  436,  435,  434,
+      433,  432,  431,  430,  429,  428,  427,  426,  422,  420,
+      418,  417,  415,  411,  409,  407,  405,  401,  398,  393,
+      392,  391,  390,  389,  388,  387,  385,  384,  383,  382,
+      381,  380,  378,  376,  375,  373,  372,  358,  356,  346,
+      345,  344,  343,  342,  341,  340,  339,  338,  337,  336,
+      335,  331,  330,  327,  326,  318,  312,  310,  309,  306,
+      301,  299,  298,  297,  296,  294,  293,  290,  289,  288,
+
+      286,  285,  274,  271,  270,  265,  262,  261,  260,  259,
+      258,  257,  256,  255,  252,  251,  250,  247,  246,  240,
+      237,  233,  232,  229,  227,  223,  222,  221,  219,  218,
+      217,  214,  213,  212,  210,  209,  200,  194,  193,  188,
+      184,  183,  182,  180,  177,  175,  174,  171,  170,  162,
+      156,  155,  151,  147,  146,  145,  143,  138,  136,  135,
+      127,  116,  112,  111,  104,  102,  101,   83,   75,   74,
+       73,   72,   55,   54,   37,   36,   35,   32,   23,   11,
+        9,    8,    6,    3, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496, 1496,
+     1496, 1496, 1496, 1496, 1496
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int ns_flex_debug;
+int ns_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *nstext;
+#line 1 "netscreen.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: netscreen.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "netscreen.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void ns_parse_date(char *input);
+void ns_parse_ip(char *input, unsigned char mode);
+#line 1648 "netscreen.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int nslex_destroy (void );
+
+int nsget_debug (void );
+
+void nsset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE nsget_extra (void );
+
+void nsset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *nsget_in (void );
+
+void nsset_in  (FILE * in_str  );
+
+FILE *nsget_out (void );
+
+void nsset_out  (FILE * out_str  );
+
+int nsget_leng (void );
+
+char *nsget_text (void );
+
+int nsget_lineno (void );
+
+void nsset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int nswrap (void );
+#else
+extern int nswrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( nstext, nsleng, 1, nsout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( nsin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( nsin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, nsin))==0 && ferror(nsin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(nsin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int nslex (void);
+
+#define YY_DECL int nslex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after nstext and nsleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 32 "netscreen.l"
+
+
+#line 1836 "netscreen.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! nsin )
+			nsin = stdin;
+
+		if ( ! nsout )
+			nsout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			nsensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ns_create_buffer(nsin,YY_BUF_SIZE );
+		}
+
+		ns_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of nstext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 1497 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 1496 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 34 "netscreen.l"
+ns_parse_date(nstext);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 35 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 36 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 37 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 38 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 39 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 40 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 41 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 42 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 43 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 44 "netscreen.l"
+{opt.line->protocol=atoi(nstext+6); opt.parser=opt.parser|NS_PROTO;}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 45 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 46 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 47 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 48 "netscreen.l"
+{xstrncpy(opt.line->branchname,nstext+7,SHORTLEN); opt.parser=opt.parser|NS_BN;}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 49 "netscreen.l"
+opt.line->datalen=opt.line->datalen+atoi(nstext+5);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 50 "netscreen.l"
+opt.line->datalen=opt.line->datalen+atoi(nstext+5);
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 51 "netscreen.l"
+ns_parse_ip(nstext+4,NETSCREEN_OPT_SRC);
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 52 "netscreen.l"
+ns_parse_ip(nstext+4,NETSCREEN_OPT_DST);
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 53 "netscreen.l"
+{opt.line->sport=atoi(nstext+9); opt.parser=opt.parser|NS_SPORT;}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 54 "netscreen.l"
+{opt.line->dport=atoi(nstext+9); opt.parser=opt.parser|NS_DPORT;}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 55 "netscreen.l"
+{opt.line->sport=atoi(nstext+10); opt.line->sport=0; opt.parser=opt.parser|NS_SPORT|NS_DPORT;}
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 56 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 57 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 58 "netscreen.l"
+opt.parser=opt.parser|NS_NO_HIT;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 59 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 60 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 61 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 62 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 63 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 64 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 65 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 66 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 67 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 68 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 69 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 70 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 71 "netscreen.l"
+opt.parser=opt.parser|NS_NO_HIT; /* only enters parser when last entry was IKE */
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 72 "netscreen.l"
+opt.parser=opt.parser|NS_NO_HIT;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 73 "netscreen.l"
+opt.parser=opt.parser|NS_NO_HIT;
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 74 "netscreen.l"
+opt.parser=opt.parser|NS_NO_HIT;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 75 "netscreen.l"
+opt.parser=opt.parser|NS_NO_HIT;
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 76 "netscreen.l"
+/* ignore */
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 77 "netscreen.l"
+/* ignore whitespace */
+	YY_BREAK
+case 45:
+/* rule 45 can match eol */
+YY_RULE_SETUP
+#line 78 "netscreen.l"
+return 0;
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 79 "netscreen.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", nstext);
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 80 "netscreen.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", nstext);
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 82 "netscreen.l"
+ECHO;
+	YY_BREAK
+#line 2156 "netscreen.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed nsin at a new source and called
+			 * nslex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = nsin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( nswrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * nstext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of nslex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					nsrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			nsrestart(nsin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) nsrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 1497 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 1497 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 1496);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					nsrestart(nsin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( nswrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve nstext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void nsrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        nsensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ns_create_buffer(nsin,YY_BUF_SIZE );
+	}
+
+	ns_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ns_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ns_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		nspop_buffer_state();
+	 *		nspush_buffer_state(new_buffer);
+     */
+	nsensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ns_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (nswrap()) processing, but the only time this flag
+	 * is looked at is after nswrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ns_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	nsin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ns_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) nsalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ns_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) nsalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ns_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ns_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ns_create_buffer()
+ * 
+ */
+    void ns_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		nsfree((void *) b->yy_ch_buf  );
+
+	nsfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a nsrestart() or at EOF.
+ */
+    static void ns_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ns_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ns_init_buffer was _probably_
+     * called from nsrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ns_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ns_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void nspush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	nsensure_buffer_stack();
+
+	/* This block is copied from ns_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ns_switch_to_buffer. */
+	ns_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void nspop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ns_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ns_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void nsensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)nsalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in nsensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)nsrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in nsensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ns_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) nsalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ns_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ns_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to nslex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ns_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ns_scan_string (yyconst char * yystr )
+{
+    
+	return ns_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to nslex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ns_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) nsalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ns_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ns_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ns_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up nstext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		nstext[nsleng] = (yy_hold_char); \
+		(yy_c_buf_p) = nstext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		nsleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int nsget_lineno  (void)
+{
+        
+    return nslineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *nsget_in  (void)
+{
+        return nsin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *nsget_out  (void)
+{
+        return nsout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int nsget_leng  (void)
+{
+        return nsleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *nsget_text  (void)
+{
+        return nstext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void nsset_lineno (int  line_number )
+{
+    
+    nslineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ns_switch_to_buffer
+ */
+void nsset_in (FILE *  in_str )
+{
+        nsin = in_str ;
+}
+
+void nsset_out (FILE *  out_str )
+{
+        nsout = out_str ;
+}
+
+int nsget_debug  (void)
+{
+        return ns_flex_debug;
+}
+
+void nsset_debug (int  bdebug )
+{
+        ns_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from nslex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    nsin = stdin;
+    nsout = stdout;
+#else
+    nsin = (FILE *) 0;
+    nsout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * nslex_init()
+     */
+    return 0;
+}
+
+/* nslex_destroy is for both reentrant and non-reentrant scanners. */
+int nslex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ns_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		nspop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	nsfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * nslex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *nsalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *nsrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void nsfree (void * ptr )
+{
+	free( (char *) ptr );	/* see nsrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 82 "netscreen.l"
+
+
+
+void ns_parse_date(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 6) {
+    return;
+  }
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | NS_DATE;
+}
+
+void ns_parse_ip(char *input, unsigned char mode)
+{
+  if (mode == NETSCREEN_OPT_SRC) {
+    if (convert_ip(input, &opt.line->shost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | NS_SRC;
+  } else {
+    if (convert_ip(input, &opt.line->dhost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | NS_DST;
+  }
+}
+
+unsigned char flex_netscreen(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  ns_scan_string(input);
+  nslex();
+  ns_delete_buffer(YY_CURRENT_BUFFER);
+
+  xstrncpy(opt.line->chainlabel, "-", SHORTLEN);
+  xstrncpy(opt.line->interface, "-", SHORTLEN);
+  opt.line->count = 1;
+
+  if (opt.parser & NS_NO_HIT)
+    return PARSE_NO_HIT;
+
+  if (opt.parser == (NS_DATE | NS_SRC | NS_DST | NS_SPORT | NS_DPORT | NS_BN | NS_PROTO)) {
+    return PARSE_OK;
+  } else {
+    if (opt.verbose)
+      fprintf(stderr, "netscreen parse error in line %d, ignoring.\n", linenum);
+    if (opt.verbose == 2)
+      fprintf(stderr, "input was: \"%s\"\n", input);
+    return PARSE_WRONG_FORMAT;
+  }
+}
+
diff -Naur fwlogwatch-1.2.orig/snort.c fwlogwatch-1.2/snort.c
--- fwlogwatch-1.2.orig/snort.c	1970-01-01 01:00:00.000000000 +0100
+++ fwlogwatch-1.2/snort.c	2011-09-08 11:36:25.521537076 +0200
@@ -0,0 +1,2085 @@
+#line 2 "snort.c"
+
+#line 4 "snort.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer snort_create_buffer
+#define yy_delete_buffer snort_delete_buffer
+#define yy_flex_debug snort_flex_debug
+#define yy_init_buffer snort_init_buffer
+#define yy_flush_buffer snort_flush_buffer
+#define yy_load_buffer_state snort_load_buffer_state
+#define yy_switch_to_buffer snort_switch_to_buffer
+#define yyin snortin
+#define yyleng snortleng
+#define yylex snortlex
+#define yylineno snortlineno
+#define yyout snortout
+#define yyrestart snortrestart
+#define yytext snorttext
+#define yywrap snortwrap
+#define yyalloc snortalloc
+#define yyrealloc snortrealloc
+#define yyfree snortfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE snortrestart(snortin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int snortleng;
+
+extern FILE *snortin, *snortout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up snorttext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up snorttext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via snortrestart()), so that the user can continue scanning by
+	 * just pointing snortin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when snorttext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int snortleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow snortwrap()'s to do buffer switches
+ * instead of setting up a fresh snortin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void snortrestart (FILE *input_file  );
+void snort_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE snort_create_buffer (FILE *file,int size  );
+void snort_delete_buffer (YY_BUFFER_STATE b  );
+void snort_flush_buffer (YY_BUFFER_STATE b  );
+void snortpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void snortpop_buffer_state (void );
+
+static void snortensure_buffer_stack (void );
+static void snort_load_buffer_state (void );
+static void snort_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER snort_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE snort_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE snort_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE snort_scan_bytes (yyconst char *bytes,int len  );
+
+void *snortalloc (yy_size_t  );
+void *snortrealloc (void *,yy_size_t  );
+void snortfree (void *  );
+
+#define yy_new_buffer snort_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        snortensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            snort_create_buffer(snortin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        snortensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            snort_create_buffer(snortin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define snortwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *snortin = (FILE *) 0, *snortout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int snortlineno;
+
+int snortlineno = 1;
+
+extern char *snorttext;
+#define yytext_ptr snorttext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up snorttext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	snortleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 18
+#define YY_END_OF_BUFFER 19
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[181] =
+    {   0,
+       16,   16,   19,   17,   15,   14,   17,   16,   16,   16,
+       16,   16,   16,   16,   16,   16,   16,   16,   17,   16,
+       17,   14,    0,    5,   16,    0,   16,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    0,    0,
+        0,    5,    5,    0,    0,    0,    0,    5,    0,    0,
+        0,    5,    5,    0,    0,    0,    0,    0,    0,    0,
+        0,    5,   16,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    5,    5,    5,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    5,    5,    0,    0,    0,
+        0,    4,    0,    0,    2,    0,    5,    5,    0,    0,
+
+        0,    0,    0,    0,    0,    5,    5,    0,    0,    0,
+        0,    0,    0,    0,    0,    5,    5,    0,    0,   10,
+        0,    0,    0,    0,    3,    5,    5,    0,    0,   10,
+        0,    0,    0,    0,    5,   16,    0,    0,   10,   11,
+        0,    0,    0,    5,    0,    0,    0,   11,    0,    0,
+        0,    0,   13,    8,    0,   11,    0,    0,    7,   12,
+       13,    8,    0,   11,    1,    0,   12,    8,    9,   11,
+        1,    0,    9,    0,    9,    0,    6,    9,    9,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    3,    4,    4,    4,    4,    4,    4,    4,    5,
+        6,    4,    4,    4,    7,    8,    9,   10,   10,   10,
+       10,   11,   10,   10,   10,   10,   10,   12,    4,    4,
+        4,   13,    4,    4,   14,   15,   16,   17,   15,   18,
+       15,   15,   19,   20,   15,   15,   21,   22,   23,   24,
+       15,   15,   25,   26,   27,   15,   15,   15,   15,   15,
+       28,    4,   29,    4,   30,    4,   31,   32,   33,   15,
+
+       34,   35,   36,   15,   37,   15,   15,   38,   39,   40,
+       41,   42,   15,   43,   44,   45,   46,   47,   15,   15,
+       48,   15,   49,    4,   50,    4,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[51] =
+    {   0,
+        1,    2,    3,    4,    5,    5,    6,    6,    3,    6,
+        6,    7,    8,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    1,    4,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    4,    4
+    } ;
+
+static yyconst flex_int16_t yy_base[188] =
+    {   0,
+        0,    0,  364,  439,  439,  360,   48,  349,  348,   76,
+      120,  326,  325,   21,  327,  316,  323,  316,   50,   22,
+       44,  345,  148,  176,  332,  341,    0,    0,  300,  306,
+      308,  308,  299,   35,   29,  291,  292,  294,   78,  297,
+      291,  292,  290,  315,  314,  312,   58,  325,   81,  291,
+      283,  274,  286,  294,  290,  289,   85,  204,   87,  268,
+      270,  265,   58,  285,  258,   93,   97,  232,  260,   99,
+      263,  263,   89,  264,  259,  300,  103,  294,  288,  316,
+      272,  263,  257,  289,  105,  246,  245,  109,  122,  126,
+      344,  439,  252,  241,  439,  131,  240,  250,  135,  153,
+
+      275,  372,  245,  233,  268,  235,  247,  128,  157,  137,
+      161,  163,  244,  264,  263,  231,  199,  180,  228,  165,
+      221,  182,  188,  207,  439,  177,  194,  184,  188,  190,
+      193,  185,  144,  206,  142,  168,  210,  162,  154,  212,
+      214,  125,  125,  140,  146,  216,  220,  222,  234,  103,
+      128,  132,    0,  236,  116,  239,  118,   72,  439,    0,
+        0,  241,  244,  246,    0,   82,    0,   68,  248,  439,
+        0,   73,  250,   36,  262,   25,  439,  264,  439,  439,
+      400,  401,  407,  413,  421,  425,  430
+    } ;
+
+static yyconst flex_int16_t yy_def[188] =
+    {   0,
+      180,    1,  180,  180,  180,  180,  181,  182,  182,  183,
+      183,   11,   11,   11,   11,   11,   11,   11,  180,   11,
+      180,  180,  181,  181,  182,  180,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,  180,  180,
+      180,   11,   11,  180,  180,  180,  180,   11,  180,  180,
+      180,   11,   11,  180,  180,  180,  180,  181,  180,  180,
+      180,   11,   11,  180,  180,  180,  180,  181,  181,  180,
+      180,  180,   11,   11,   11,  180,  180,  180,  181,  181,
+      180,  180,  180,  180,  180,   11,   11,  180,  180,  180,
+      181,  180,  180,  180,  180,  180,   11,   11,  180,  180,
+
+      180,  181,  180,  180,  180,   11,   11,  180,  180,  180,
+      180,  180,  180,  180,  180,   11,   11,  180,  180,  180,
+      180,  180,  180,  180,  180,   11,   11,  180,  180,  180,
+      180,  180,  180,  180,   11,   11,  180,  180,  180,  180,
+      180,  180,  180,   11,  180,  180,  180,  180,  180,  180,
+      180,  180,  184,  180,  180,  180,  180,  180,  180,  185,
+      184,  180,  180,  180,  186,  180,  185,  180,  180,  180,
+      186,  180,  180,  187,  180,  187,  180,  180,  180,    0,
+      180,  180,  180,  180,  180,  180,  180
+    } ;
+
+static yyconst flex_int16_t yy_nxt[490] =
+    {   0,
+        4,    5,    6,    4,    7,    4,    8,    9,    4,    9,
+        9,    4,    4,   10,   11,   11,   12,   13,   11,   14,
+       15,   16,   17,   11,   18,   11,   11,   19,    4,    9,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   20,   11,   11,   11,   11,   21,    4,
+       23,   33,   23,  177,   23,   23,   23,   23,   23,   39,
+       39,   42,   44,   43,  177,   40,   34,   57,   57,   45,
+       46,   48,   48,   41,   48,  174,   48,   23,   23,  163,
+       23,   24,   27,   27,   23,   27,   27,   39,   39,   49,
+       59,   59,   66,  172,   67,   67,   59,   59,   70,   74,
+
+       84,   75,   77,   77,   66,   27,   78,   78,   81,   81,
+       89,  166,   90,   90,   96,   96,   85,   29,   99,   99,
+      165,   30,   23,  146,   23,   24,   27,   27,   23,   27,
+       27,  100,  100,   89,  160,  101,  101,  118,  118,  159,
+       96,   96,  108,  158,  109,  109,  120,  120,  153,   27,
+       23,  152,   23,  151,   23,   23,   23,   23,   23,  105,
+      110,  150,  111,  111,  108,  131,  119,  119,  110,  128,
+      121,  121,  122,  122,  130,  130,  131,   23,   23,  145,
+       23,  144,   23,   23,   23,   23,   23,  128,  142,  129,
+      129,  132,  132,  137,  137,  128,  141,  138,  138,  139,
+
+      139,  131,  140,  140,  136,   23,   68,  135,   23,  134,
+       23,   23,   23,   69,   69,  143,  143,  146,  133,  147,
+      147,  148,  148,  149,  149,  154,  154,  146,  110,  155,
+      155,  156,  156,   23,   23,  108,   23,  127,   23,   23,
+       23,   69,   69,  157,  157,  162,  162,  163,  164,  164,
+      168,  168,  163,  169,  169,  170,  170,  173,  173,  175,
+      175,   23,   79,  126,   23,  125,   23,   23,   23,   80,
+       80,  178,  178,  179,  179,  124,  123,  117,  116,  115,
+      114,  113,   89,  107,  106,  104,  103,   98,   97,   23,
+       23,   95,   23,   94,   23,   23,   23,   91,   91,   93,
+
+       92,   66,   88,   87,   86,   83,   82,   76,   65,   73,
+       72,   71,   65,   65,   64,   63,   62,   23,   79,   61,
+       23,   60,   23,   23,   23,   23,   23,   58,   56,   55,
+       54,   53,   52,   51,   50,   48,   48,   48,   48,   48,
+       48,   48,   48,   47,  180,   23,   23,   22,   23,   38,
+       23,   23,   23,  102,  102,   37,   36,   35,   32,   31,
+      180,   26,   22,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,   23,   23,  180,   23,  180,   23,   23,
+       23,   23,   23,  112,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+
+      180,   23,   24,  180,   24,   24,   25,  180,   25,   28,
+      180,   28,   28,  161,  180,  161,  161,  161,  161,  161,
+      161,  167,  180,  167,  167,  167,  167,  167,  167,  171,
+      171,  171,  176,  176,  176,  176,  176,  176,    3,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180
+    } ;
+
+static yyconst flex_int16_t yy_chk[490] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        7,   14,    7,  176,    7,    7,    7,    7,    7,   19,
+       19,   20,   21,   20,  174,   19,   14,   47,   47,   21,
+       21,   35,   34,   19,   34,  172,   35,    7,   10,  168,
+       10,   10,   10,   10,   10,   10,   10,   39,   39,   39,
+       49,   49,   57,  166,   57,   57,   59,   59,   59,   63,
+
+       73,   63,   66,   66,   67,   10,   67,   67,   70,   70,
+       77,  158,   77,   77,   85,   85,   73,   10,   88,   88,
+      157,   10,   11,  155,   11,   11,   11,   11,   11,   11,
+       11,   89,   89,   90,  152,   90,   90,  108,  108,  151,
+       96,   96,   99,  150,   99,   99,  110,  110,  145,   11,
+       23,  144,   23,  143,   23,   23,   23,   23,   23,   96,
+      100,  142,  100,  100,  109,  139,  109,  109,  111,  138,
+      111,  111,  112,  112,  120,  120,  120,   23,   24,  136,
+       24,  135,   24,   24,   24,   24,   24,  118,  133,  118,
+      118,  122,  122,  128,  128,  129,  132,  129,  129,  130,
+
+      130,  130,  131,  131,  127,   24,   58,  126,   58,  124,
+       58,   58,   58,   58,   58,  134,  134,  137,  123,  137,
+      137,  140,  140,  141,  141,  146,  146,  147,  121,  147,
+      147,  148,  148,   58,   68,  119,   68,  117,   68,   68,
+       68,   68,   68,  149,  149,  154,  154,  154,  156,  156,
+      162,  162,  162,  163,  163,  164,  164,  169,  169,  173,
+      173,   68,   69,  116,   69,  115,   69,   69,   69,   69,
+       69,  175,  175,  178,  178,  114,  113,  107,  106,  105,
+      104,  103,  101,   98,   97,   94,   93,   87,   86,   69,
+       79,   84,   79,   83,   79,   79,   79,   79,   79,   82,
+
+       81,   78,   76,   75,   74,   72,   71,   65,   64,   62,
+       61,   60,   56,   55,   54,   53,   52,   79,   80,   51,
+       80,   50,   80,   80,   80,   80,   80,   48,   46,   45,
+       44,   43,   42,   41,   40,   38,   37,   36,   33,   32,
+       31,   30,   29,   26,   25,   80,   91,   22,   91,   18,
+       91,   91,   91,   91,   91,   17,   16,   15,   13,   12,
+        9,    8,    6,    3,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   91,  102,    0,  102,    0,  102,  102,
+      102,  102,  102,  102,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,  102,  181,    0,  181,  181,  182,    0,  182,  183,
+        0,  183,  183,  184,    0,  184,  184,  184,  184,  184,
+      184,  185,    0,  185,  185,  185,  185,  185,  185,  186,
+      186,  186,  187,  187,  187,  187,  187,  187,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180,  180,
+      180,  180,  180,  180,  180,  180,  180,  180,  180
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int snort_flex_debug;
+int snort_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *snorttext;
+#line 1 "snort.l"
+/* Copyright (C) 2000-2010 Boris Wesslowski */
+/* $Id: snort.l 706 2010-10-06 12:02:36Z bw $ */
+#line 9 "snort.l"
+#define YY_NO_INPUT
+
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include "main.h"
+#include "utils.h"
+
+extern struct options opt;
+
+void snort_parse_date(char *input);
+void snort_parse_branch(char *input);
+void snort_parse_ip(char *input, unsigned char mode);
+#line 661 "snort.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int snortlex_destroy (void );
+
+int snortget_debug (void );
+
+void snortset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE snortget_extra (void );
+
+void snortset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *snortget_in (void );
+
+void snortset_in  (FILE * in_str  );
+
+FILE *snortget_out (void );
+
+void snortset_out  (FILE * out_str  );
+
+int snortget_leng (void );
+
+char *snortget_text (void );
+
+int snortget_lineno (void );
+
+void snortset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int snortwrap (void );
+#else
+extern int snortwrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( snorttext, snortleng, 1, snortout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( snortin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( snortin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, snortin))==0 && ferror(snortin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(snortin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int snortlex (void);
+
+#define YY_DECL int snortlex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after snorttext and snortleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 35 "snort.l"
+
+
+#line 849 "snort.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! snortin )
+			snortin = stdin;
+
+		if ( ! snortout )
+			snortout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			snortensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				snort_create_buffer(snortin,YY_BUF_SIZE );
+		}
+
+		snort_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of snorttext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 181 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 180 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 37 "snort.l"
+snort_parse_date(snorttext);
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 38 "snort.l"
+/* ignore */
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 39 "snort.l"
+/* ignore */
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 40 "snort.l"
+/* ignore */
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 41 "snort.l"
+xstrncpy(opt.line->chainlabel, snorttext, SHORTLEN); opt.parser=opt.parser|SNORT_CHAIN;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 42 "snort.l"
+snort_parse_branch(snorttext+17);
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 43 "snort.l"
+/* ignore */
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 44 "snort.l"
+snort_parse_ip(snorttext+1, SNORT_OPT_SRC);
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 45 "snort.l"
+snort_parse_ip(snorttext+1, SNORT_OPT_SRC|SNORT_OPT_PORT);
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 46 "snort.l"
+snort_parse_ip(snorttext, SNORT_OPT_DST);
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 47 "snort.l"
+snort_parse_ip(snorttext, SNORT_OPT_DST|SNORT_OPT_PORT);
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 48 "snort.l"
+opt.parser=SNORT_NO_HIT;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 49 "snort.l"
+opt.parser=SNORT_NO_HIT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 50 "snort.l"
+/* ignore whitespace */
+	YY_BREAK
+case 15:
+/* rule 15 can match eol */
+YY_RULE_SETUP
+#line 51 "snort.l"
+/* ignore */
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 52 "snort.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized token: %s\n", snorttext);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 53 "snort.l"
+if(opt.verbose) fprintf(stderr, "Unrecognized character: %s\n", snorttext);
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 55 "snort.l"
+ECHO;
+	YY_BREAK
+#line 1019 "snort.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed snortin at a new source and called
+			 * snortlex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = snortin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( snortwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * snorttext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of snortlex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					snortrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			snortrestart(snortin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) snortrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 181 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 181 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 180);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					snortrestart(snortin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( snortwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve snorttext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void snortrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        snortensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            snort_create_buffer(snortin,YY_BUF_SIZE );
+	}
+
+	snort_init_buffer(YY_CURRENT_BUFFER,input_file );
+	snort_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void snort_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		snortpop_buffer_state();
+	 *		snortpush_buffer_state(new_buffer);
+     */
+	snortensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	snort_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (snortwrap()) processing, but the only time this flag
+	 * is looked at is after snortwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void snort_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	snortin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE snort_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) snortalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in snort_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) snortalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in snort_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	snort_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with snort_create_buffer()
+ * 
+ */
+    void snort_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		snortfree((void *) b->yy_ch_buf  );
+
+	snortfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a snortrestart() or at EOF.
+ */
+    static void snort_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	snort_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then snort_init_buffer was _probably_
+     * called from snortrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void snort_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		snort_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void snortpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	snortensure_buffer_stack();
+
+	/* This block is copied from snort_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from snort_switch_to_buffer. */
+	snort_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void snortpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	snort_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		snort_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void snortensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)snortalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in snortensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)snortrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in snortensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE snort_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) snortalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in snort_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	snort_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to snortlex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       snort_scan_bytes() instead.
+ */
+YY_BUFFER_STATE snort_scan_string (yyconst char * yystr )
+{
+    
+	return snort_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to snortlex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE snort_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) snortalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in snort_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = snort_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in snort_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up snorttext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		snorttext[snortleng] = (yy_hold_char); \
+		(yy_c_buf_p) = snorttext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		snortleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int snortget_lineno  (void)
+{
+        
+    return snortlineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *snortget_in  (void)
+{
+        return snortin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *snortget_out  (void)
+{
+        return snortout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int snortget_leng  (void)
+{
+        return snortleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *snortget_text  (void)
+{
+        return snorttext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void snortset_lineno (int  line_number )
+{
+    
+    snortlineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see snort_switch_to_buffer
+ */
+void snortset_in (FILE *  in_str )
+{
+        snortin = in_str ;
+}
+
+void snortset_out (FILE *  out_str )
+{
+        snortout = out_str ;
+}
+
+int snortget_debug  (void)
+{
+        return snort_flex_debug;
+}
+
+void snortset_debug (int  bdebug )
+{
+        snort_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from snortlex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    snortin = stdin;
+    snortout = stdout;
+#else
+    snortin = (FILE *) 0;
+    snortout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * snortlex_init()
+     */
+    return 0;
+}
+
+/* snortlex_destroy is for both reentrant and non-reentrant scanners. */
+int snortlex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		snort_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		snortpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	snortfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * snortlex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *snortalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *snortrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void snortfree (void * ptr )
+{
+	free( (char *) ptr );	/* see snortrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 55 "snort.l"
+
+
+
+void snort_parse_date(char *input)
+{
+  int retval, day, hour, minute, second;
+  char smonth[4];
+
+  retval = sscanf(input, "%3s %2d %2d:%2d:%2d %32s", smonth, &day, &hour, &minute, &second, opt.line->hostname);
+  if (retval != 6)
+    return;
+
+  build_time(smonth, day, hour, minute, second);
+
+  opt.parser = opt.parser | SNORT_DATE;
+}
+
+void snort_parse_branch(char *input)
+{
+  char *ptr;
+
+  ptr = strchr(input, ']');
+  *ptr = '\0';
+  xstrncpy(opt.line->branchname, input, SHORTLEN);
+  opt.parser = opt.parser | SNORT_BRANCH;
+}
+
+void snort_parse_ip(char *input, unsigned char mode)
+{
+  char ip[IPLEN];
+  int retval, host1, host2, host3, host4;
+
+  if ((mode & SNORT_OPT_SRC) != 0) {
+    char proto[8];
+    if ((mode & SNORT_OPT_PORT) != 0) {
+      retval = sscanf(input, "%8s %3d.%3d.%3d.%3d:%5d", proto, &host1, &host2, &host3, &host4, &opt.line->sport);
+      if (retval != 6)
+	return;
+    } else {
+      retval = sscanf(input, "%8s %3d.%3d.%3d.%3d", proto, &host1, &host2, &host3, &host4);
+      if (retval != 5)
+	return;
+    }
+
+    if (strncmp(proto, "TCP", 3) == 0)
+      opt.line->protocol = 6;
+    else if (strncmp(proto, "UDP", 3) == 0)
+      opt.line->protocol = 17;
+    else if (strncmp(proto, "ICMP", 4) == 0)
+      opt.line->protocol = 1;
+
+    if (opt.line->protocol != 0)
+      opt.parser = opt.parser | SNORT_PROTO;
+  } else if ((mode & SNORT_OPT_DST) != 0) {
+    if ((mode & SNORT_OPT_PORT) != 0) {
+      retval = sscanf(input, "-> %3d.%3d.%3d.%3d:%5d", &host1, &host2, &host3, &host4, &opt.line->sport);
+      if (retval != 5)
+	return;
+    } else {
+      retval = sscanf(input, "-> %3d.%3d.%3d.%3d", &host1, &host2, &host3, &host4);
+      if (retval != 4)
+	return;
+    }
+  } else {
+    return;
+  }
+
+  snprintf(ip, IPLEN, "%d.%d.%d.%d", host1, host2, host3, host4);
+
+  if ((mode & SNORT_OPT_SRC) != 0) {
+    if (convert_ip(ip, &opt.line->shost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | SNORT_SRC;
+  } else if ((mode & SNORT_OPT_DST) != 0) {
+    if (convert_ip(ip, &opt.line->dhost) == IN_ADDR_ERROR)
+      return;
+    opt.parser = opt.parser | SNORT_DST;
+  }
+}
+
+unsigned char flex_snort(char *input, int linenum)
+{
+  opt.parser = 0;
+  init_line();
+  snort_scan_string(input);
+  snortlex();
+  snort_delete_buffer(YY_CURRENT_BUFFER);
+
+  xstrncpy(opt.line->interface, "-", SHORTLEN);
+  opt.line->count = 1;
+
+  if (opt.parser & SNORT_NO_HIT)
+    return PARSE_NO_HIT;
+
+  if (opt.parser == (SNORT_DATE | SNORT_CHAIN | SNORT_BRANCH | SNORT_PROTO | SNORT_SRC | SNORT_DST)) {
+    return PARSE_OK;
+  } else {
+    if (opt.verbose)
+      fprintf(stderr, "snort parse error in line %d, ignoring.\n", linenum);
+    if (opt.verbose == 2)
+      fprintf(stderr, "input was: \"%s\"\n", input);
+    return PARSE_WRONG_FORMAT;
+  }
+}
+
