Patch extracted from here:
http://bazaar.launchpad.net/~ubuntu-branches/ubuntu/dapper/subversion/dapper-security/annotate/head%3A/debian/patches/fix-binary-diff-security.patch

diff -Nur -x '*.orig' -x '*~' subversion-1.3.1/subversion/libsvn_delta/svndiff.c subversion-1.3.1.new/subversion/libsvn_delta/svndiff.c
--- subversion-1.3.1/subversion/libsvn_delta/svndiff.c	2005-09-20 03:01:59.000000000 -0700
+++ subversion-1.3.1.new/subversion/libsvn_delta/svndiff.c	2009-08-06 16:09:56.000000000 -0700
@@ -40,10 +40,23 @@
   apr_pool_t *pool;
 };
 
+/* This is at least as big as the largest size of an integer that
+   encode_int can generate; it is sufficient for creating buffers for
+   it to write into.  This assumes that integers are at most 64 bits,
+   and so 10 bytes (with 7 bits of information each) are sufficient to
+   represent them. */
+#define MAX_ENCODED_INT_LEN 10
+/* This is at least as big as the largest size for a single instruction. */
+#define MAX_INSTRUCTION_LEN (2*MAX_ENCODED_INT_LEN+1)
+/* This is at least as big as the largest possible instructions
+   section: in theory, the instructions could be SVN_DELTA_WINDOW_SIZE
+   1-byte copy-from-source instructions (though this is very unlikely). */
+#define MAX_INSTRUCTION_SECTION_LEN (SVN_DELTA_WINDOW_SIZE*MAX_INSTRUCTION_LEN)
 
 /* Encode VAL into the buffer P using the variable-length svndiff
    integer format.  Return the incremented value of P after the
-   encoded bytes have been written.
+   encoded bytes have been written.  P must point to a buffer of size
+   at least MAX_ENCODED_INT_LEN.
 
    This encoding uses the high bit of each byte as a continuation bit
    and the other seven bits as data bits.  High-order data bits are
@@ -76,6 +89,8 @@
       n++;
     }
 
+  assert(n <= MAX_ENCODED_INT_LEN);
+
   /* Encode the remaining bytes; n is always the number of bytes
      coming after the one we're encoding.  */
   while (--n >= 0)
@@ -93,7 +108,7 @@
 append_encoded_int (svn_stringbuf_t *header, svn_filesize_t val,
                     apr_pool_t *pool)
 {
-  char buf[128], *p;
+  char buf[MAX_ENCODED_INT_LEN], *p;
 
   p = encode_int (buf, val);
   svn_stringbuf_appendbytes (header, buf, p - buf);
@@ -107,7 +122,7 @@
   apr_pool_t *pool = svn_pool_create (eb->pool);
   svn_stringbuf_t *instructions = svn_stringbuf_create ("", pool);
   svn_stringbuf_t *header = svn_stringbuf_create ("", pool);
-  char ibuf[128], *ip;
+  char ibuf[MAX_INSTRUCTION_LEN], *ip;
   const svn_txdelta_op_t *op;
   svn_error_t *err;
   apr_size_t len;
@@ -272,6 +287,10 @@
              const unsigned char *p,
              const unsigned char *end)
 {
+  if (p + MAX_ENCODED_INT_LEN < end)
+    end = p + MAX_ENCODED_INT_LEN;
+  if (p + MAX_ENCODED_INT_LEN < end)
+    end = p + MAX_ENCODED_INT_LEN;
   /* Decode bytes until we're done.  */
   *val = 0;
   while (p < end)
@@ -342,26 +361,26 @@
   while (p < end)
     {
       p = decode_instruction (&op, p, end);
-      if (p == NULL || op.length <= 0 || op.length > tview_len - tpos)
-        {
-          if (p == NULL)
-            return svn_error_createf
-              (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
-               _("Invalid diff stream: insn %d cannot be decoded"), n);
-          else if (op.length <= 0)
-            return svn_error_createf
-              (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
-               _("Invalid diff stream: insn %d has non-positive length"), n);
-          else
-            return svn_error_createf
-              (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
-               _("Invalid diff stream: insn %d overflows the target view"), n);
-        }
+
+      /* Detect any malformed operations from the instruction stream. */
+      if (p == NULL)
+        return svn_error_createf
+          (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
+           _("Invalid diff stream: insn %d cannot be decoded"), n);
+      else if (op.length == 0)
+        return svn_error_createf
+          (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
+           _("Invalid diff stream: insn %d has length zero"), n);
+      else if (op.length > tview_len - tpos)
+        return svn_error_createf
+          (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
+           _("Invalid diff stream: insn %d overflows the target view"), n);
 
       switch (op.action_code)
         {
         case svn_txdelta_source:
-          if (op.length > sview_len - op.offset)
+          if (op.length > sview_len - op.offset ||
+              op.offset > sview_len)
             return svn_error_createf
               (SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
                _("Invalid diff stream: "
@@ -518,6 +537,14 @@
       if (p == NULL)
         return SVN_NO_ERROR;
 
+      if (tview_len > SVN_DELTA_WINDOW_SIZE ||
+          sview_len > SVN_DELTA_WINDOW_SIZE ||
+          /* for svndiff1, newlen includes the original length */
+          newlen > SVN_DELTA_WINDOW_SIZE + MAX_ENCODED_INT_LEN ||
+          inslen > MAX_INSTRUCTION_SECTION_LEN)
+        return svn_error_create(SVN_ERR_SVNDIFF_CORRUPT_WINDOW, NULL,
+                                _("Svndiff contains a too-large window"));
+
       /* Check for integer overflow.  */
       if (sview_offset < 0 || inslen + newlen < inslen
           || sview_len + tview_len < sview_len
@@ -673,6 +700,14 @@
   SVN_ERR (read_one_size (inslen, stream));
   SVN_ERR (read_one_size (newlen, stream));
 
+  if (*tview_len > SVN_DELTA_WINDOW_SIZE ||
+      *sview_len > SVN_DELTA_WINDOW_SIZE ||
+      /* for svndiff1, newlen includes the original length */
+      *newlen > SVN_DELTA_WINDOW_SIZE + MAX_ENCODED_INT_LEN ||
+      *inslen > MAX_INSTRUCTION_SECTION_LEN)
+    return svn_error_create(SVN_ERR_SVNDIFF_CORRUPT_WINDOW, NULL,
+                            _("Svndiff contains a too-large window"));
+
   /* Check for integer overflow.  */
   if (*sview_offset < 0 || *inslen + *newlen < *inslen
       || *sview_len + *tview_len < *sview_len
diff -Nur -x '*.orig' -x '*~' subversion-1.3.1/subversion/libsvn_delta/text_delta.c subversion-1.3.1.new/subversion/libsvn_delta/text_delta.c
--- subversion-1.3.1/subversion/libsvn_delta/text_delta.c	2005-10-10 12:54:15.000000000 -0700
+++ subversion-1.3.1.new/subversion/libsvn_delta/text_delta.c	2009-08-06 16:09:56.000000000 -0700
@@ -472,8 +472,8 @@
 /* Functions for applying deltas.  */
 
 /* Ensure that BUF has enough space for VIEW_LEN bytes.  */
-static APR_INLINE void
-size_buffer (char **buf, apr_size_t *buf_size,
+static APR_INLINE svn_error_t *
+size_buffer(char **buf, apr_size_t *buf_size,
              apr_size_t view_len, apr_pool_t *pool)
 {
   if (view_len > *buf_size)
@@ -481,8 +481,13 @@
       *buf_size *= 2;
       if (*buf_size < view_len)
         *buf_size = view_len;
-      *buf = apr_palloc (pool, *buf_size);
+      if (APR_ALIGN_DEFAULT(*buf_size) < *buf_size)
+        return svn_error_create(SVN_ERR_SVNDIFF_INVALID_OPS, NULL,
+                                "Diff stream resulted in invalid buffer size.");
+      *buf = apr_palloc(pool, *buf_size);
     }
+
+  return SVN_NO_ERROR;
 }
 
 
@@ -570,7 +575,7 @@
                   >= ab->sbuf_offset + ab->sbuf_len)));
 
   /* Make sure there's enough room in the target buffer.  */
-  size_buffer (&ab->tbuf, &ab->tbuf_size, window->tview_len, ab->pool);
+  SVN_ERR(size_buffer(&ab->tbuf, &ab->tbuf_size, window->tview_len, ab->pool));
 
   /* Prepare the source buffer for reading from the input stream.  */
   if (window->sview_offset != ab->sbuf_offset
@@ -579,7 +584,8 @@
       char *old_sbuf = ab->sbuf;
 
       /* Make sure there's enough room.  */
-      size_buffer (&ab->sbuf, &ab->sbuf_size, window->sview_len, ab->pool);
+      SVN_ERR(size_buffer(&ab->sbuf, &ab->sbuf_size, window->sview_len,
+              ab->pool));
 
       /* If the existing view overlaps with the new view, copy the
        * overlap to the beginning of the new buffer.  */
