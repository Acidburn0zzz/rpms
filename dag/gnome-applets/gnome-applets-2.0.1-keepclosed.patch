--- gnome-applets-2.0.1/cdplayer/cdrom-linux.c.keepclosed	Fri Aug 23 20:37:01 2002
+++ gnome-applets-2.0.1/cdplayer/cdrom-linux.c	Fri Aug 23 22:49:49 2002
@@ -16,10 +16,39 @@
   (dest).second = (src).second; \
   (dest).frame = (src).frame; \
 }
+void
+cdrom_unuse(cdrom_device_t cdp)
+{
+	g_return_if_fail (cdp->use_count > 0);
+	cdp->use_count--;
+	if (cdp->use_count == 0) {
+		close(cdp->device);
+		cdp->device = -1;
+	}
+}
+gboolean
+cdrom_use(cdrom_device_t cdp, int *errcode)
+{
+	if (cdp->use_count == 0) {
+		cdp->device = open(cdp->device_name, O_RDONLY|O_NONBLOCK);
+		if (cdp->device == -1) {
+			*errcode = errno;
+			return FALSE;
+		}
+	}
+
+	cdp->use_count++;
+	return TRUE;
+}
+
 int
 cdrom_play(cdrom_device_t cdp, int start, int stop)
 {
 	struct cdrom_ti ti;
+	int result = DISC_NO_ERROR;
+
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
 
 	ti.cdti_trk0 = start;
 	ti.cdti_ind0 = 1;
@@ -27,18 +56,26 @@
 	ti.cdti_ind1 = 1;
 	if (ioctl(cdp->device, CDROMPLAYTRKIND, &ti) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
 	}
-	return DISC_NO_ERROR;
+
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
 cdrom_play_msf(cdrom_device_t cdp, cdrom_msf_t * start)
 {
 	struct cdrom_msf msf;
+	int result = DISC_NO_ERROR;
 
-	if (cdrom_read_track_info(cdp) == DISC_IO_ERROR)
+	if (!cdrom_use (cdp, &cdp->my_errno))
 		return DISC_IO_ERROR;
+
+	if (cdrom_read_track_info(cdp) == DISC_IO_ERROR) {
+		result = DISC_IO_ERROR;
+		goto out;
+	}
 	msf.cdmsf_min0 = start->minute;
 	msf.cdmsf_sec0 = start->second;
 	msf.cdmsf_frame0 = start->frame;
@@ -49,40 +86,62 @@
 
 	if (ioctl(cdp->device, CDROMPLAYMSF, &msf) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
 	}
-	return DISC_NO_ERROR;
+
+ out:
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
 cdrom_pause(cdrom_device_t cdp)
 {
-	if (ioctl(cdp->device, CDROMPAUSE, 0) == -1) {
+	int result = DISC_NO_ERROR;
+	
+	if (!cdrom_use (cdp, &cdp->my_errno))
 		return DISC_IO_ERROR;
+
+	if (ioctl(cdp->device, CDROMPAUSE, 0) == -1) {
+		result = DISC_IO_ERROR;
 		cdp->my_errno = errno;
 	}
-	return DISC_IO_ERROR;
+
+	return result;
 }
 
 int
 cdrom_resume(cdrom_device_t cdp)
 {
+	int result = DISC_NO_ERROR;
+	
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
+
 	if (ioctl(cdp->device, CDROMRESUME, 0) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
 	}
-	return DISC_NO_ERROR;
+
+	return result;
 }
 
 
 int
 cdrom_stop(cdrom_device_t cdp)
 {
+	int result = DISC_NO_ERROR;
+	
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
+
 	if (ioctl(cdp->device, CDROMSTOP, 0) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
 	}
-	return DISC_NO_ERROR;
+
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
@@ -92,16 +151,23 @@
 	struct cdrom_tocentry tocentry;
 
 	int i, j, nr_track;
+	int result = DISC_NO_ERROR;
+
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
 
 	if (ioctl(cdp->device, CDROMREADTOCHDR, &toc) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
+		goto out;
 	}
 	cdp->track0 = toc.cdth_trk0;
 	cdp->track1 = toc.cdth_trk1;
 	nr_track = toc.cdth_trk1 - toc.cdth_trk0 + 1;
-	if (nr_track <= 0)
-		return DISC_IO_ERROR;
+	if (nr_track <= 0) {
+		result = DISC_IO_ERROR;
+		goto out;
+	}
 
 	if (nr_track != cdp->nr_track) {
 		if (cdp->track_info)
@@ -115,7 +181,8 @@
 
 		if (ioctl(cdp->device, CDROMREADTOCENTRY, &tocentry) == -1) {
 			cdp->my_errno = errno;
-			return DISC_IO_ERROR;
+			result = DISC_IO_ERROR;
+			goto out;
 		}
 		/* fill the trackinfo field */
 		cdp->track_info[i].track = j;
@@ -128,13 +195,16 @@
 	tocentry.cdte_format = CDROM_MSF;
 	if (ioctl(cdp->device, CDROMREADTOCENTRY, &tocentry) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
+		goto out;
 	}
 	cdp->track_info[i].track = j;
 	cdp->track_info[i].audio_track = 0;
 	ASSIGN_MSF(cdp->track_info[i].address, tocentry.cdte_addr.msf);
 
-	return DISC_NO_ERROR;
+ out:
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
@@ -142,6 +212,10 @@
 {
 	struct cdrom_subchnl subchnl;
 	int status;
+	int result = DISC_NO_ERROR;
+
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
 
 /*if we have the uniform cdrom api, which I thought was on 2.0 kernels,
   but it doesn't seem to be*/
@@ -155,9 +229,11 @@
 		case CDS_DISC_OK:
 			break;
 		case CDS_TRAY_OPEN:
-			return DISC_TRAY_OPEN;
+			result = DISC_TRAY_OPEN;
+			goto out;
 		case CDS_DRIVE_NOT_READY:
-			return DISC_DRIVE_NOT_READY;
+			result = DISC_DRIVE_NOT_READY;
+			goto out;
 		default:
 			break;
 		}
@@ -167,7 +243,8 @@
 	subchnl.cdsc_format = CDROM_MSF;
 	if (ioctl(cdp->device, CDROMSUBCHNL, &subchnl) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
+		result = DISC_IO_ERROR;
+		goto out;
 	}
 	switch (subchnl.cdsc_audiostatus) {
 	case CDROM_AUDIO_PLAY:
@@ -190,7 +267,11 @@
 	stat->track = subchnl.cdsc_trk;
 	ASSIGN_MSF(stat->relative_address, subchnl.cdsc_reladdr.msf);
 	ASSIGN_MSF(stat->absolute_address, subchnl.cdsc_absaddr.msf);
-	return DISC_NO_ERROR;
+
+ out:
+	cdrom_unuse (cdp);
+
+	return result;
 }
 
 cdrom_device_t
@@ -199,13 +280,14 @@
 	cdrom_device_t cdp;
 
 	cdp = g_malloc(sizeof(struct cdrom_device));
+	cdp->device_name = g_strdup (device);
+	cdp->use_count = 0;
 
-	cdp->device = open(device, O_RDONLY|O_NONBLOCK);
-	if (cdp->device == -1) {
-		*errcode = errno;
+	if (!cdrom_use (cdp, errcode)) {
 		g_free(cdp);
 		return NULL;
 	}
+	cdrom_unuse (cdp);
 	cdp->nr_track = 0;
 	cdp->track_info = NULL;
 	return cdp;
@@ -214,30 +296,46 @@
 void
 cdrom_close(cdrom_device_t cdp)
 {
+	g_assert (cdp->use_count == 0);
+	
 	if (cdp->nr_track)
 		g_free(cdp->track_info);
-	close(cdp->device);
+	g_free(cdp->device_name);
 	g_free(cdp);
 }
 
 int
 cdrom_load(cdrom_device_t cdp)
 {
+	int result = DISC_NO_ERROR;
+	
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
+	
 	if (ioctl(cdp->device, CDROMCLOSETRAY, 0) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
-	};
-	return DISC_NO_ERROR;
+		result = DISC_IO_ERROR;
+	}
+
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
 cdrom_eject(cdrom_device_t cdp)
 {
+	int result = DISC_NO_ERROR;
+	
+	if (!cdrom_use (cdp, &cdp->my_errno))
+		return DISC_IO_ERROR;
+	
 	if (ioctl(cdp->device, CDROMEJECT, 0) == -1) {
 		cdp->my_errno = errno;
-		return DISC_IO_ERROR;
-	};
-	return DISC_NO_ERROR;
+		result = DISC_IO_ERROR;
+	}
+
+	cdrom_unuse (cdp);
+	return result;
 }
 
 
@@ -246,12 +344,22 @@
 {
 	cdrom_device_status_t stat;
 	int track;
+	int result = DISC_NO_ERROR;
 
-	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
-	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+	if (!cdrom_use (cdp, &cdp->my_errno))
 		return DISC_IO_ERROR;
+	
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR)) {
+		result = DISC_IO_ERROR;
+		goto out;
+	}
 	track = stat.track + 1;
-	return cdrom_play(cdp, stat.track + 1, cdp->track1);
+	result = cdrom_play(cdp, stat.track + 1, cdp->track1);
+
+ out:
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int 
@@ -259,23 +367,39 @@
 {
 	cdrom_device_status_t stat;
 	int track;
+	int result = DISC_NO_ERROR;
 
-	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
-	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+	if (!cdrom_use (cdp, &cdp->my_errno))
 		return DISC_IO_ERROR;
+	
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR)) {
+		result = DISC_IO_ERROR;
+		goto out;
+	}
 	track = stat.track - 1;
-	return cdrom_play(cdp, stat.track - 1, cdp->track1);
+	result = cdrom_play(cdp, stat.track - 1, cdp->track1);
+
+ out:
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
 cdrom_rewind(cdrom_device_t cdp)
 {
 	cdrom_device_status_t stat;
+	int result = DISC_NO_ERROR;
 	/* int track; */
 
-	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
-	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+	if (!cdrom_use (cdp, &cdp->my_errno))
 		return DISC_IO_ERROR;
+	
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR)) {
+		result = DISC_IO_ERROR;
+		goto out;
+	}
 	if (stat.absolute_address.second != 0)
 		stat.absolute_address.second--;
 	else {
@@ -284,25 +408,39 @@
 			stat.absolute_address.minute--;
 	}
 	stat.absolute_address.frame = 0;
-	return cdrom_play_msf(cdp, &stat.absolute_address);
+	result = cdrom_play_msf(cdp, &stat.absolute_address);
+
+ out:
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
 cdrom_ff(cdrom_device_t cdp)
 {
 	cdrom_device_status_t stat;
+	int result = DISC_NO_ERROR;
 	/* int track; */
 
-	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
-	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+	if (!cdrom_use (cdp, &cdp->my_errno))
 		return DISC_IO_ERROR;
+	
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR)) {
+		result = DISC_IO_ERROR;
+		goto out;
+	}
 	stat.absolute_address.second++;
 	if (stat.absolute_address.second >= 60) {
 		stat.absolute_address.minute++;
 		stat.absolute_address.second = 0;
 	}
 	stat.absolute_address.frame = 0;
-	return cdrom_play_msf(cdp, &stat.absolute_address);
+	result = cdrom_play_msf(cdp, &stat.absolute_address);
+
+ out:
+	cdrom_unuse (cdp);
+	return result;
 }
 
 int
--- gnome-applets-2.0.1/cdplayer/cdrom-interface.h.keepclosed	Fri Aug 23 20:49:38 2002
+++ gnome-applets-2.0.1/cdplayer/cdrom-interface.h	Fri Aug 23 21:08:13 2002
@@ -56,6 +56,8 @@
 
 	void *cdda;
 	int my_errno;
+	int use_count;
+	char *device_name;
 } *cdrom_device_t;
 
 cdrom_device_t cdrom_open(char *path, /* out */ int *errcode);
